# 构建系统配置

- **标题**: AI协作开发构建系统配置指南
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 构建系统架构

### 🏗️ CMake 项目结构

#### 根目录 CMakeLists.txt
```cmake
# CMakeLists.txt - 根目录配置
cmake_minimum_required(VERSION 3.20)

# 项目定义
project(radar_mvp_system
    VERSION 1.0.0
    DESCRIPTION "Radar MVP System with GPU Acceleration"
    LANGUAGES CXX CUDA
)

# 全局配置
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

set(CMAKE_CUDA_STANDARD 17)
set(CMAKE_CUDA_STANDARD_REQUIRED ON)

# 构建类型设置
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Build type" FORCE)
endif()

# 输出目录配置
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# 包含自定义 CMake 模块
list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")

# 导入配置文件
include(CompilerSettings)
include(PackageConfig)

# 子目录
add_subdirectory(src)
add_subdirectory(tests)

# 安装配置
include(GNUInstallDirs)
install(TARGETS radar_core radar_gpu_lib
    EXPORT RadarTargets
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
```

#### 编译器设置 (cmake/CompilerSettings.cmake)
```cmake
# cmake/CompilerSettings.cmake
# 编译器特定配置

# 通用编译选项
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra")

# GCC 特定设置
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    # 版本检查
    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "9.0")
        message(FATAL_ERROR "GCC version 9.0 or higher required")
    endif()

    # 优化选项
    set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG -march=native -mtune=native")
    set(CMAKE_CXX_FLAGS_DEBUG "-O0 -g3 -DDEBUG -fno-omit-frame-pointer")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g -DNDEBUG")
    set(CMAKE_CXX_FLAGS_MINSIZEREL "-Os -DNDEBUG")

    # 警告选项
    add_compile_options(
        -Wno-unused-parameter
        -Wno-missing-field-initializers
        -Wno-sign-compare
        -Wconversion
        -Wshadow
        -Wnon-virtual-dtor
        -Wold-style-cast
        -Wcast-align
        -Wunused
        -Woverloaded-virtual
        -Wpedantic
        -Wsign-conversion
        -Wmisleading-indentation
        -Wduplicated-cond
        -Wduplicated-branches
        -Wlogical-op
        -Wnull-dereference
        -Wuseless-cast
        -Wdouble-promotion
        -Wformat=2
    )

    # 链接时优化
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
    endif()

    # 调试信息增强
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        add_compile_options(-ggdb3)
    endif()

# Clang 特定设置
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # 版本检查
    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "12.0")
        message(FATAL_ERROR "Clang version 12.0 or higher required")
    endif()

    # 优化选项
    set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG -march=native -mtune=native")
    set(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -DDEBUG")

    # 警告选项
    add_compile_options(
        -Weverything
        -Wno-c++98-compat
        -Wno-c++98-compat-pedantic
        -Wno-padded
        -Wno-weak-vtables
        -Wno-exit-time-destructors
        -Wno-global-constructors
        -Wno-documentation-unknown-command
    )

# MSVC 特定设置
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    # 版本检查
    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "19.28")
        message(FATAL_ERROR "MSVC version 19.28 (VS 2019 16.8) or higher required")
    endif()

    # 优化选项
    set(CMAKE_CXX_FLAGS_RELEASE "/O2 /Ob2 /DNDEBUG")
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /Zi /DEBUG /DDEBUG")

    # 编译选项
    add_compile_options(
        /W4                 # 高警告级别
        /permissive-        # 严格标准符合性
        /Zc:__cplusplus     # 正确的 __cplusplus 宏
        /Zc:preprocessor    # 符合标准的预处理器
        /utf-8              # UTF-8 源码和执行字符集
        /bigobj             # 增加目标文件中的段数
    )

    # 链接选项
    add_link_options(
        /INCREMENTAL:NO     # 禁用增量链接 (Release)
        $<$<CONFIG:Debug>:/INCREMENTAL>  # Debug 启用增量链接
    )

    # 禁用特定警告
    add_compile_definitions(
        _CRT_SECURE_NO_WARNINGS
        _SCL_SECURE_NO_WARNINGS
        NOMINMAX
        WIN32_LEAN_AND_MEAN
    )
endif()

# CUDA 编译器设置
if(CMAKE_CUDA_COMPILER)
    # CUDA 架构
    set(CMAKE_CUDA_ARCHITECTURES "60;61;70;75;80;86;89")

    # CUDA 编译选项
    set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} --extended-lambda --expt-relaxed-constexpr")
    set(CMAKE_CUDA_FLAGS_RELEASE "-O3 -DNDEBUG --use_fast_math")
    set(CMAKE_CUDA_FLAGS_DEBUG "-O0 -g -G -DDEBUG")

    # CUDA 分离编译
    set(CMAKE_CUDA_SEPARABLE_COMPILATION ON)

    # PTX 生成
    set(CMAKE_CUDA_PTX_COMPILATION ON)
endif()

# 地址净化器 (Debug 构建)
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)
if(ENABLE_ASAN AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        add_compile_options(-fsanitize=address -fsanitize=undefined)
        add_link_options(-fsanitize=address -fsanitize=undefined)
    endif()
endif()

# 性能分析器支持
option(ENABLE_PROFILING "Enable profiling support" OFF)
if(ENABLE_PROFILING)
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        add_compile_options(-pg)
        add_link_options(-pg)
    endif()
endif()
```

#### 包配置 (cmake/PackageConfig.cmake)
```cmake
# cmake/PackageConfig.cmake
# 第三方包配置和查找

# vcpkg 集成
if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
    set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
        CACHE STRING "Vcpkg toolchain file")
endif()

# pkg-config 支持
find_package(PkgConfig QUIET)

# === 必需依赖 ===

# Boost
set(Boost_USE_STATIC_LIBS ON)
set(Boost_USE_MULTITHREADED ON)
find_package(Boost 1.75.0 REQUIRED
    COMPONENTS system filesystem thread program_options
)

# CUDA
find_package(CUDAToolkit 12.0 REQUIRED)

# yaml-cpp
find_package(yaml-cpp 0.7.0 REQUIRED)

# spdlog
find_package(spdlog 1.9.0 REQUIRED)

# OpenGL
find_package(OpenGL REQUIRED)
if(NOT OpenGL_GL_PREFERENCE)
    set(OpenGL_GL_PREFERENCE GLVND)
endif()

# GLFW
find_package(glfw3 3.3 REQUIRED)

# GLEW
find_package(GLEW 2.2.0 REQUIRED)

# === 可选依赖 ===

# Eigen3 (线性代数)
find_package(Eigen3 3.4.0 QUIET)
if(Eigen3_FOUND)
    message(STATUS "Found Eigen3: ${Eigen3_VERSION}")
    set(HAVE_EIGEN3 TRUE)
else()
    message(STATUS "Eigen3 not found - some features will be disabled")
    set(HAVE_EIGEN3 FALSE)
endif()

# Intel MKL (数学内核库)
find_package(MKL QUIET)
if(MKL_FOUND)
    message(STATUS "Found Intel MKL: ${MKL_VERSION}")
    set(HAVE_MKL TRUE)
else()
    message(STATUS "Intel MKL not found - fallback to standard libraries")
    set(HAVE_MKL FALSE)
endif()

# ImGui (GUI)
find_package(imgui QUIET)
if(imgui_FOUND)
    message(STATUS "Found ImGui")
    set(HAVE_IMGUI TRUE)
else()
    message(STATUS "ImGui not found - GUI features will be disabled")
    set(HAVE_IMGUI FALSE)
endif()

# === 测试依赖 ===
option(BUILD_TESTS "Build tests" ON)
if(BUILD_TESTS)
    # Google Test
    find_package(GTest 1.12.0 QUIET)
    if(NOT GTest_FOUND)
        include(FetchContent)
        FetchContent_Declare(
            googletest
            URL https://github.com/google/googletest/archive/03597a01ee50f33f9142904e5b22ac5a8b0ad4e3.zip
        )
        FetchContent_MakeAvailable(googletest)
    endif()

    # Google Benchmark
    find_package(benchmark QUIET)
    if(NOT benchmark_FOUND)
        include(FetchContent)
        FetchContent_Declare(
            googlebenchmark
            URL https://github.com/google/benchmark/archive/v1.7.1.zip
        )
        set(BENCHMARK_ENABLE_TESTING OFF)
        FetchContent_MakeAvailable(googlebenchmark)
    endif()
endif()

# === 依赖检查和报告 ===
function(print_dependency_summary)
    message(STATUS "=== Dependency Summary ===")
    message(STATUS "Required dependencies:")
    message(STATUS "  Boost: ${Boost_VERSION}")
    message(STATUS "  CUDA: ${CUDAToolkit_VERSION}")
    message(STATUS "  yaml-cpp: ${yaml-cpp_VERSION}")
    message(STATUS "  spdlog: ${spdlog_VERSION}")
    message(STATUS "  OpenGL: ${OPENGL_VERSION}")

    message(STATUS "Optional dependencies:")
    message(STATUS "  Eigen3: ${HAVE_EIGEN3}")
    message(STATUS "  Intel MKL: ${HAVE_MKL}")
    message(STATUS "  ImGui: ${HAVE_IMGUI}")

    if(BUILD_TESTS)
        message(STATUS "Test dependencies:")
        message(STATUS "  GTest: ${GTest_FOUND}")
        message(STATUS "  Benchmark: ${benchmark_FOUND}")
    endif()
    message(STATUS "========================")
endfunction()

# 生成配置头文件
configure_file(
    "${CMAKE_SOURCE_DIR}/include/common/config.h.in"
    "${CMAKE_BINARY_DIR}/include/common/config.h"
    @ONLY
)

# 调用依赖摘要
print_dependency_summary()
```

---

## 构建配置和选项

### ⚙️ 构建类型配置

#### 构建类型定义
```cmake
# 自定义构建类型
set(CMAKE_CONFIGURATION_TYPES "Debug;Release;RelWithDebInfo;MinSizeRel;Profile" CACHE STRING "" FORCE)

# Profile 构建类型
set(CMAKE_CXX_FLAGS_PROFILE "-O2 -g -DNDEBUG -DENABLE_PROFILING")
set(CMAKE_CUDA_FLAGS_PROFILE "-O2 -g -DNDEBUG")

# 构建选项
option(BUILD_SHARED_LIBS "Build shared libraries" OFF)
option(BUILD_TESTS "Build tests" ON)
option(BUILD_BENCHMARKS "Build benchmarks" OFF)
option(BUILD_DOCUMENTATION "Build documentation" OFF)
option(BUILD_EXAMPLES "Build examples" ON)

# 功能选项
option(ENABLE_CUDA "Enable CUDA support" ON)
option(ENABLE_OPENGL "Enable OpenGL support" ON)
option(ENABLE_GUI "Enable GUI components" ON)
option(ENABLE_PROFILING "Enable profiling support" OFF)
option(ENABLE_LOGGING "Enable detailed logging" ON)

# 性能选项
option(USE_FAST_MATH "Use fast math optimizations" ON)
option(ENABLE_LTO "Enable Link Time Optimization" ON)
option(ENABLE_NATIVE_ARCH "Enable native architecture optimization" ON)
```

#### 条件编译配置
```cmake
# 生成配置头文件模板
# include/common/config.h.in
#pragma once

// 版本信息
#define RADAR_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define RADAR_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define RADAR_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define RADAR_VERSION_STRING "@PROJECT_VERSION@"

// 功能开关
#cmakedefine HAVE_CUDA
#cmakedefine HAVE_OPENGL
#cmakedefine HAVE_EIGEN3
#cmakedefine HAVE_MKL
#cmakedefine HAVE_IMGUI

// 构建配置
#cmakedefine BUILD_SHARED_LIBS
#cmakedefine ENABLE_PROFILING
#cmakedefine ENABLE_LOGGING
#cmakedefine USE_FAST_MATH

// 编译器信息
#define COMPILER_ID "@CMAKE_CXX_COMPILER_ID@"
#define COMPILER_VERSION "@CMAKE_CXX_COMPILER_VERSION@"

// 构建信息
#define BUILD_TYPE "@CMAKE_BUILD_TYPE@"
#define BUILD_TIMESTAMP "@BUILD_TIMESTAMP@"
```

### 🎯 模块化构建配置

#### 核心模块 CMakeLists.txt
```cmake
# src/CMakeLists.txt
# 主要源码目录

# 添加子目录
add_subdirectory(common)
add_subdirectory(modules)
add_subdirectory(application)

# 主可执行文件
add_executable(radar_system main.cpp)

# 链接库
target_link_libraries(radar_system
    PRIVATE
        radar_app
        radar_common
        radar_modules
)

# 包含目录
target_include_directories(radar_system
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_BINARY_DIR}/include
)

# 编译定义
target_compile_definitions(radar_system
    PRIVATE
        $<$<CONFIG:Debug>:DEBUG_BUILD>
        $<$<CONFIG:Release>:RELEASE_BUILD>
)

# 链接选项
if(WIN32)
    target_link_options(radar_system PRIVATE /SUBSYSTEM:CONSOLE)
endif()
```

#### 模块构建配置
```cmake
# src/modules/CMakeLists.txt
# 模块库构建

# 创建模块库
add_library(radar_modules)

# 添加子模块
add_subdirectory(data_receiver)
add_subdirectory(protocol_parser)
add_subdirectory(gpu_processor)
add_subdirectory(display_control)
add_subdirectory(task_scheduler)

# 模块接口库
add_library(radar_module_interfaces INTERFACE)
target_include_directories(radar_module_interfaces
    INTERFACE
        ${CMAKE_SOURCE_DIR}/include/interfaces
)

# GPU 处理模块 (CUDA)
if(ENABLE_CUDA AND CMAKE_CUDA_COMPILER)
    add_subdirectory(gpu_processor)
    target_link_libraries(radar_modules
        PUBLIC
            radar_gpu_processor
            CUDA::cudart
            CUDA::cufft
            CUDA::cublas
    )
endif()

# 链接所有模块
target_link_libraries(radar_modules
    PUBLIC
        radar_module_interfaces
        radar_data_receiver
        radar_protocol_parser
        radar_display_control
        radar_task_scheduler
    PRIVATE
        Boost::system
        Boost::filesystem
        Boost::thread
        yaml-cpp
        spdlog::spdlog
)

# 导出符号 (Windows DLL)
if(WIN32 AND BUILD_SHARED_LIBS)
    target_compile_definitions(radar_modules
        PRIVATE RADAR_MODULES_EXPORTS
        INTERFACE RADAR_MODULES_IMPORTS
    )
endif()
```

#### CUDA 模块构建
```cmake
# src/modules/gpu_processor/CMakeLists.txt
# GPU 处理模块

if(NOT ENABLE_CUDA OR NOT CMAKE_CUDA_COMPILER)
    message(STATUS "CUDA disabled or not found, skipping GPU processor")
    return()
endif()

# CUDA 库
add_library(radar_gpu_processor)

# CUDA 源文件
target_sources(radar_gpu_processor
    PRIVATE
        gpu_processor.cpp
        cuda_kernels.cu
        fft_processor.cu
        signal_processor.cu
)

# CUDA 特定设置
set_target_properties(radar_gpu_processor PROPERTIES
    CUDA_STANDARD 17
    CUDA_STANDARD_REQUIRED ON
    CUDA_EXTENSIONS OFF
    CUDA_SEPARABLE_COMPILATION ON
    POSITION_INDEPENDENT_CODE ON
)

# CUDA 编译选项
target_compile_options(radar_gpu_processor
    PRIVATE
        $<$<COMPILE_LANGUAGE:CUDA>:
            --extended-lambda
            --expt-relaxed-constexpr
            --use_fast_math
            -Xcompiler=-fPIC
        >
)

# 架构特定优化
set(CUDA_ARCH_FLAGS)
foreach(arch IN LISTS CMAKE_CUDA_ARCHITECTURES)
    if(arch MATCHES "^([0-9]+)$")
        list(APPEND CUDA_ARCH_FLAGS "-gencode=arch=compute_${arch},code=sm_${arch}")
    endif()
endforeach()
target_compile_options(radar_gpu_processor
    PRIVATE
        $<$<COMPILE_LANGUAGE:CUDA>:${CUDA_ARCH_FLAGS}>
)

# 链接 CUDA 库
target_link_libraries(radar_gpu_processor
    PUBLIC
        CUDA::cudart
        CUDA::cufft
        CUDA::cublas
        CUDA::curand
    PRIVATE
        radar_common
)

# 包含目录
target_include_directories(radar_gpu_processor
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include/modules/gpu_processor
    PRIVATE
        ${CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES}
)
```

---

## 测试构建配置

### 🧪 测试框架集成

#### 测试根目录配置
```cmake
# tests/CMakeLists.txt
# 测试构建配置

if(NOT BUILD_TESTS)
    return()
endif()

enable_testing()

# 测试辅助函数
function(add_radar_test test_name)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs SOURCES LIBRARIES)
    cmake_parse_arguments(TEST "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    add_executable(${test_name} ${TEST_SOURCES})

    target_link_libraries(${test_name}
        PRIVATE
            ${TEST_LIBRARIES}
            GTest::gtest
            GTest::gtest_main
            GTest::gmock
    )

    target_include_directories(${test_name}
        PRIVATE
            ${CMAKE_SOURCE_DIR}/include
            ${CMAKE_SOURCE_DIR}/tests/mock
    )

    add_test(NAME ${test_name} COMMAND ${test_name})

    # 测试属性
    set_tests_properties(${test_name} PROPERTIES
        TIMEOUT 30
        LABELS "unit"
    )
endfunction()

# 添加测试子目录
add_subdirectory(unit_tests)
add_subdirectory(integration_tests)
if(BUILD_BENCHMARKS)
    add_subdirectory(performance_tests)
endif()

# 测试覆盖率配置
option(ENABLE_COVERAGE "Enable code coverage" OFF)
if(ENABLE_COVERAGE AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        target_compile_options(radar_test_common INTERFACE
            --coverage -fno-inline -fno-inline-small-functions -fno-default-inline
        )
        target_link_options(radar_test_common INTERFACE --coverage)
    endif()
endif()
```

#### 单元测试配置
```cmake
# tests/unit_tests/CMakeLists.txt
# 单元测试

# 测试通用库
add_library(radar_test_common INTERFACE)
target_include_directories(radar_test_common
    INTERFACE
        ${CMAKE_SOURCE_DIR}/tests/mock
        ${CMAKE_SOURCE_DIR}/include
)

# 模块单元测试
add_subdirectory(common)
add_subdirectory(data_receiver)
add_subdirectory(protocol_parser)
add_subdirectory(gpu_processor)
add_subdirectory(display_control)
add_subdirectory(task_scheduler)

# 数据接收器测试
add_radar_test(test_data_receiver
    SOURCES
        data_receiver/test_data_receiver.cpp
        data_receiver/test_packet_parser.cpp
    LIBRARIES
        radar_modules
        radar_test_common
)

# GPU 处理器测试
if(ENABLE_CUDA)
    add_radar_test(test_gpu_processor
        SOURCES
            gpu_processor/test_gpu_processor.cpp
            gpu_processor/test_cuda_kernels.cpp
        LIBRARIES
            radar_gpu_processor
            radar_test_common
            CUDA::cudart
    )

    # GPU 测试需要 GPU 硬件
    set_tests_properties(test_gpu_processor PROPERTIES
        LABELS "gpu;unit"
        RESOURCE_GROUPS "gpu:1"
    )
endif()
```

#### 性能测试配置
```cmake
# tests/performance_tests/CMakeLists.txt
# 性能基准测试

if(NOT BUILD_BENCHMARKS)
    return()
endif()

# 基准测试辅助函数
function(add_radar_benchmark benchmark_name)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs SOURCES LIBRARIES)
    cmake_parse_arguments(BENCH "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    add_executable(${benchmark_name} ${BENCH_SOURCES})

    target_link_libraries(${benchmark_name}
        PRIVATE
            ${BENCH_LIBRARIES}
            benchmark::benchmark
            benchmark::benchmark_main
    )

    target_include_directories(${benchmark_name}
        PRIVATE
            ${CMAKE_SOURCE_DIR}/include
    )

    # 基准测试不作为常规测试运行
    # add_test(NAME ${benchmark_name} COMMAND ${benchmark_name})
endfunction()

# GPU 处理性能测试
if(ENABLE_CUDA)
    add_radar_benchmark(benchmark_gpu_processor
        SOURCES
            gpu_fft_benchmark.cpp
            gpu_signal_processing_benchmark.cpp
        LIBRARIES
            radar_gpu_processor
    )
endif()

# 数据处理性能测试
add_radar_benchmark(benchmark_data_processing
    SOURCES
        data_receiver_benchmark.cpp
        protocol_parser_benchmark.cpp
    LIBRARIES
        radar_modules
)
```

---

## 包管理和依赖

### 📦 vcpkg 集成配置

#### vcpkg.json 配置
```json
{
  "name": "radar-mvp-system",
  "version": "1.0.0",
  "description": "Radar MVP System with GPU Acceleration",
  "dependencies": [
    {
      "name": "boost",
      "version>=": "1.75.0",
      "default-features": false,
      "features": ["system", "filesystem", "thread", "program-options"]
    },
    {
      "name": "yaml-cpp",
      "version>=": "0.7.0"
    },
    {
      "name": "spdlog",
      "version>=": "1.9.0",
      "features": ["std_format"]
    },
    {
      "name": "glfw3",
      "version>=": "3.3.0"
    },
    {
      "name": "glew",
      "version>=": "2.2.0"
    },
    {
      "name": "opengl",
      "platform": "!osx"
    },
    {
      "name": "eigen3",
      "version>=": "3.4.0"
    },
    {
      "name": "imgui",
      "version>=": "1.89.0",
      "features": ["opengl3-binding", "glfw-binding"]
    }
  ],
  "features": {
    "tests": {
      "description": "Build with testing support",
      "dependencies": [
        {
          "name": "gtest",
          "version>=": "1.12.0"
        },
        {
          "name": "benchmark",
          "version>=": "1.7.0"
        }
      ]
    },
    "mkl": {
      "description": "Intel MKL support",
      "dependencies": [
        {
          "name": "intel-mkl",
          "platform": "x64"
        }
      ]
    }
  },
  "builtin-baseline": "2023.08.09"
}
```

#### vcpkg 自定义端口
```cmake
# ports/cuda-toolkit/portfile.cmake
# 自定义 CUDA 工具包端口

set(VCPKG_POLICY_EMPTY_PACKAGE enabled)

if(NOT VCPKG_TARGET_IS_WINDOWS AND NOT VCPKG_TARGET_IS_LINUX)
    message(FATAL_ERROR "CUDA Toolkit is only supported on Windows and Linux")
endif()

# CUDA 版本检测
find_program(NVCC_EXECUTABLE nvcc
    HINTS
        $ENV{CUDA_PATH}/bin
        $ENV{CUDA_HOME}/bin
        /usr/local/cuda/bin
        /opt/cuda/bin
)

if(NOT NVCC_EXECUTABLE)
    message(FATAL_ERROR "CUDA Toolkit not found. Please install CUDA Toolkit 12.0 or later.")
endif()

# 版本检查
execute_process(
    COMMAND ${NVCC_EXECUTABLE} --version
    OUTPUT_VARIABLE NVCC_VERSION_OUTPUT
    ERROR_QUIET
)

string(REGEX MATCH "release ([0-9]+\\.[0-9]+)" NVCC_VERSION_MATCH "${NVCC_VERSION_OUTPUT}")
set(CUDA_VERSION ${CMAKE_MATCH_1})

if(CUDA_VERSION VERSION_LESS "12.0")
    message(FATAL_ERROR "CUDA Toolkit version ${CUDA_VERSION} found, but version 12.0 or later required")
endif()

message(STATUS "Found CUDA Toolkit version: ${CUDA_VERSION}")

# 创建目标
file(WRITE ${CURRENT_PACKAGES_DIR}/share/cuda-toolkit/cuda-toolkit-config.cmake
"set(CUDA_TOOLKIT_FOUND TRUE)
set(CUDA_TOOLKIT_VERSION \"${CUDA_VERSION}\")
")
```

### 🔧 Conan 集成配置

#### conanfile.py
```python
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, cmake_layout
from conan.tools.files import copy


class RadarMvpConan(ConanFile):
    name = "radar-mvp-system"
    version = "1.0.0"

    # 包信息
    description = "Radar MVP System with GPU Acceleration"
    topics = ("radar", "gpu", "signal-processing", "realtime")
    url = "https://github.com/your-org/radar-mvp-system"
    license = "MIT"

    # 设置
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "with_cuda": [True, False],
        "with_mkl": [True, False],
        "with_gui": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "with_cuda": True,
        "with_mkl": False,
        "with_gui": True,
    }

    # 依赖
    def requirements(self):
        # 核心依赖
        self.requires("boost/1.82.0")
        self.requires("yaml-cpp/0.7.0")
        self.requires("spdlog/1.12.0")

        # 图形依赖
        if self.options.with_gui:
            self.requires("glfw/3.3.8")
            self.requires("glew/2.2.0")
            self.requires("imgui/1.89.9")

        # 数学库
        self.requires("eigen/3.4.0")
        if self.options.with_mkl:
            self.requires("intel-oneapi-mkl/2023.1.0")

    def build_requirements(self):
        self.test_requires("gtest/1.13.0")
        self.test_requires("benchmark/1.8.0")

    def configure(self):
        if self.settings.os == "Windows":
            self.options["boost"].shared = True

    def layout(self):
        cmake_layout(self)

    def generate(self):
        tc = CMakeToolchain(self)
        tc.variables["WITH_CUDA"] = self.options.with_cuda
        tc.variables["WITH_MKL"] = self.options.with_mkl
        tc.variables["WITH_GUI"] = self.options.with_gui
        tc.generate()

        deps = CMakeDeps(self)
        deps.generate()
```

---

## 构建脚本和自动化

### 🤖 自动化构建脚本

#### Windows 构建脚本
```powershell
# scripts/build/build_windows.ps1
# Windows 自动化构建脚本

param(
    [string]$BuildType = "Release",
    [switch]$Clean = $false,
    [switch]$Tests = $true,
    [switch]$UseVcpkg = $true,
    [switch]$EnableCuda = $true,
    [int]$Jobs = 0
)

# 错误处理
$ErrorActionPreference = "Stop"

# 获取脚本目录
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$RootDir = Split-Path -Parent (Split-Path -Parent $ScriptDir)

Write-Host "=== Radar MVP System - Windows Build Script ===" -ForegroundColor Green
Write-Host "Build Type: $BuildType" -ForegroundColor Yellow
Write-Host "Root Directory: $RootDir" -ForegroundColor Yellow

# 检查必需工具
function Test-Command($Command) {
    try {
        Get-Command $Command -ErrorAction Stop | Out-Null
        return $true
    }
    catch {
        return $false
    }
}

Write-Host "Checking required tools..." -ForegroundColor Blue

if (-not (Test-Command "cmake")) {
    throw "CMake not found. Please install CMake 3.20 or later."
}

if (-not (Test-Command "ninja")) {
    Write-Warning "Ninja not found. Falling back to Visual Studio generator."
    $Generator = "Visual Studio 17 2022"
} else {
    $Generator = "Ninja"
}

if ($EnableCuda -and -not (Test-Command "nvcc")) {
    Write-Warning "NVCC not found. CUDA support will be disabled."
    $EnableCuda = $false
}

# 设置并行作业数
if ($Jobs -eq 0) {
    $Jobs = [Environment]::ProcessorCount
}

Write-Host "Using $Jobs parallel jobs" -ForegroundColor Blue

# 构建目录
$BuildDir = Join-Path $RootDir "build"
$InstallDir = Join-Path $RootDir "install"

# 清理构建
if ($Clean -and (Test-Path $BuildDir)) {
    Write-Host "Cleaning build directory..." -ForegroundColor Blue
    Remove-Item -Recurse -Force $BuildDir
}

# 创建构建目录
if (-not (Test-Path $BuildDir)) {
    New-Item -ItemType Directory -Path $BuildDir | Out-Null
}

# CMake 配置参数
$CmakeArgs = @(
    "-G", $Generator,
    "-DCMAKE_BUILD_TYPE=$BuildType",
    "-DCMAKE_INSTALL_PREFIX=$InstallDir",
    "-DBUILD_TESTS=$($Tests ? 'ON' : 'OFF')",
    "-DENABLE_CUDA=$($EnableCuda ? 'ON' : 'OFF')"
)

# vcpkg 集成
if ($UseVcpkg) {
    $VcpkgRoot = $env:VCPKG_ROOT
    if ($VcpkgRoot -and (Test-Path $VcpkgRoot)) {
        $VcpkgToolchain = Join-Path $VcpkgRoot "scripts/buildsystems/vcpkg.cmake"
        $CmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=$VcpkgToolchain"
        Write-Host "Using vcpkg: $VcpkgRoot" -ForegroundColor Blue
    } else {
        Write-Warning "VCPKG_ROOT not set or invalid. Skipping vcpkg integration."
    }
}

# 配置
Write-Host "Configuring..." -ForegroundColor Blue
Set-Location $BuildDir
& cmake $RootDir @CmakeArgs
if ($LASTEXITCODE -ne 0) {
    throw "CMake configuration failed"
}

# 构建
Write-Host "Building..." -ForegroundColor Blue
& cmake --build . --config $BuildType --parallel $Jobs
if ($LASTEXITCODE -ne 0) {
    throw "Build failed"
}

# 测试
if ($Tests) {
    Write-Host "Running tests..." -ForegroundColor Blue
    & ctest --config $BuildType --parallel $Jobs --output-on-failure
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Some tests failed"
    }
}

# 安装
Write-Host "Installing..." -ForegroundColor Blue
& cmake --build . --config $BuildType --target install
if ($LASTEXITCODE -ne 0) {
    throw "Installation failed"
}

Write-Host "Build completed successfully!" -ForegroundColor Green
Write-Host "Install directory: $InstallDir" -ForegroundColor Yellow

# 返回原目录
Set-Location $RootDir
```

#### Linux 构建脚本
```bash
#!/bin/bash
# scripts/build/build_linux.sh
# Linux 自动化构建脚本

set -euo pipefail

# 默认参数
BUILD_TYPE="Release"
CLEAN=false
TESTS=true
USE_CONAN=false
ENABLE_CUDA=true
JOBS=$(nproc)

# 参数解析
while [[ $# -gt 0 ]]; do
    case $1 in
        --build-type)
            BUILD_TYPE="$2"
            shift 2
            ;;
        --clean)
            CLEAN=true
            shift
            ;;
        --no-tests)
            TESTS=false
            shift
            ;;
        --use-conan)
            USE_CONAN=true
            shift
            ;;
        --no-cuda)
            ENABLE_CUDA=false
            shift
            ;;
        --jobs)
            JOBS="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# 获取脚本目录
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
ROOT_DIR=$(dirname "$(dirname "$SCRIPT_DIR")")

echo "=== Radar MVP System - Linux Build Script ==="
echo "Build Type: $BUILD_TYPE"
echo "Root Directory: $ROOT_DIR"

# 检查必需工具
command -v cmake >/dev/null 2>&1 || { echo "CMake not found"; exit 1; }
command -v ninja >/dev/null 2>&1 || { echo "Ninja not found"; exit 1; }

if [[ "$ENABLE_CUDA" == "true" ]] && ! command -v nvcc >/dev/null 2>&1; then
    echo "Warning: NVCC not found. CUDA support will be disabled."
    ENABLE_CUDA=false
fi

# 构建目录
BUILD_DIR="$ROOT_DIR/build"
INSTALL_DIR="$ROOT_DIR/install"

# 清理构建
if [[ "$CLEAN" == "true" ]] && [[ -d "$BUILD_DIR" ]]; then
    echo "Cleaning build directory..."
    rm -rf "$BUILD_DIR"
fi

# 创建构建目录
mkdir -p "$BUILD_DIR"

# CMake 配置参数
CMAKE_ARGS=(
    -G Ninja
    -DCMAKE_BUILD_TYPE="$BUILD_TYPE"
    -DCMAKE_INSTALL_PREFIX="$INSTALL_DIR"
    -DBUILD_TESTS=$([ "$TESTS" == "true" ] && echo "ON" || echo "OFF")
    -DENABLE_CUDA=$([ "$ENABLE_CUDA" == "true" ] && echo "ON" || echo "OFF")
)

# Conan 集成
if [[ "$USE_CONAN" == "true" ]] && command -v conan >/dev/null 2>&1; then
    echo "Setting up Conan..."
    cd "$ROOT_DIR"
    conan install . --build=missing -pr:b=default
    CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="conan_toolchain.cmake")
fi

# 配置
echo "Configuring..."
cd "$BUILD_DIR"
cmake "${CMAKE_ARGS[@]}" "$ROOT_DIR"

# 构建
echo "Building..."
cmake --build . --parallel "$JOBS"

# 测试
if [[ "$TESTS" == "true" ]]; then
    echo "Running tests..."
    ctest --parallel "$JOBS" --output-on-failure || echo "Some tests failed"
fi

# 安装
echo "Installing..."
cmake --build . --target install

echo "Build completed successfully!"
echo "Install directory: $INSTALL_DIR"
```

### 🔄 CI/CD 集成配置

#### GitHub Actions 工作流
```yaml
# .github/workflows/build.yml
name: Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  BUILD_TYPE: Release

jobs:
  build-linux:
    runs-on: ubuntu-22.04

    strategy:
      matrix:
        compiler: [gcc-11, clang-14]
        cuda: [enabled, disabled]
        exclude:
          - compiler: clang-14
            cuda: enabled

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          ninja-build \
          libboost-all-dev \
          libyaml-cpp-dev \
          libspdlog-dev \
          libglfw3-dev \
          libglew-dev \
          libeigen3-dev

    - name: Install CUDA
      if: matrix.cuda == 'enabled'
      uses: Jimver/cuda-toolkit@v0.2.11
      with:
        cuda: '12.2'

    - name: Setup compiler
      run: |
        if [[ "${{ matrix.compiler }}" == "gcc-11" ]]; then
          echo "CC=gcc-11" >> $GITHUB_ENV
          echo "CXX=g++-11" >> $GITHUB_ENV
        elif [[ "${{ matrix.compiler }}" == "clang-14" ]]; then
          echo "CC=clang-14" >> $GITHUB_ENV
          echo "CXX=clang++-14" >> $GITHUB_ENV
        fi

    - name: Configure CMake
      run: |
        cmake -B build \
          -G Ninja \
          -DCMAKE_BUILD_TYPE=$BUILD_TYPE \
          -DBUILD_TESTS=ON \
          -DENABLE_CUDA=${{ matrix.cuda == 'enabled' && 'ON' || 'OFF' }}

    - name: Build
      run: cmake --build build --parallel $(nproc)

    - name: Test
      working-directory: build
      run: ctest --parallel $(nproc) --output-on-failure

  build-windows:
    runs-on: windows-2022

    steps:
    - uses: actions/checkout@v4

    - name: Install vcpkg
      run: |
        git clone https://github.com/Microsoft/vcpkg.git
        .\vcpkg\bootstrap-vcpkg.bat
        echo "VCPKG_ROOT=$PWD\vcpkg" >> $env:GITHUB_ENV

    - name: Install CUDA
      uses: Jimver/cuda-toolkit@v0.2.11
      with:
        cuda: '12.2'

    - name: Install dependencies
      run: |
        .\vcpkg\vcpkg install boost yaml-cpp spdlog glfw3 glew eigen3 --triplet x64-windows

    - name: Configure CMake
      run: |
        cmake -B build `
          -G "Visual Studio 17 2022" -A x64 `
          -DCMAKE_BUILD_TYPE=$env:BUILD_TYPE `
          -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" `
          -DBUILD_TESTS=ON `
          -DENABLE_CUDA=ON

    - name: Build
      run: cmake --build build --config $env:BUILD_TYPE --parallel

    - name: Test
      working-directory: build
      run: ctest --config $env:BUILD_TYPE --parallel --output-on-failure
```

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要                         |
| :--- | :--------- | :----- | :------------------------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建构建系统配置文档和自动化脚本 |
