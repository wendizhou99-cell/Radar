# 上下文管理策略

- **标题**: AI协作开发上下文管理策略
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 上下文信息层级

### 🏗️ 项目级上下文 (优先级: 最高)

#### 核心项目信息
```markdown
项目基础信息：
- 项目名称：Radar MVP System
- 技术栈：C++17、CUDA、CMake
- 开发阶段：MVP开发阶段
- 目标平台：Linux/Windows，GPU加速
- 实时性要求：软实时系统，毫秒级延迟要求

架构特征：
- 模块化设计，接口驱动开发
- GPU/CPU混合计算架构
- 异步数据处理流水线
- 配置文件驱动的参数管理
```

#### 项目约束和原则
```markdown
开发约束：
- 小团队开发（<10人）
- 代码不能网络传播（本地开发）
- 注重代码质量和可维护性
- 遵循现有的编码规范

性能约束：
- 处理延迟<10ms（典型要求）
- GPU内存使用需要控制
- 支持实时数据流处理
- 需要考虑多线程安全
```

### 🧩 模块级上下文 (优先级: 高)

#### 核心模块信息
```markdown
DataReceiver模块：
- 职责：从雷达前端接收原始数据
- 接口：IDataReceiver
- 数据格式：RawDataPacket
- 特征：多线程安全，支持高频数据接收

DataProcessor模块：
- 职责：对原始数据进行信号处理
- 接口：IDataProcessor
- 处理算法：脉冲压缩、波束形成、多普勒处理
- 特征：GPU加速，批处理优化

SystemScheduler模块：
- 职责：任务调度和资源管理
- 接口：ITaskScheduler
- 功能：任务队列、优先级管理、资源分配
- 特征：支持动态负载均衡

DisplayController模块：
- 职责：处理结果的显示和输出
- 接口：IDisplayController
- 输出：可视化数据、报告生成
- 特征：实时显示，多种输出格式

ProtocolParser模块：
- 职责：解析通信协议和数据格式
- 接口：IProtocolParser
- 功能：数据包解析、格式转换、校验
- 特征：支持多种雷达协议格式
```

#### 模块依赖关系
```markdown
数据流向：
DataReceiver → ProtocolParser → DataProcessor → DisplayController
              ↗               ↘
         SystemScheduler ←→ 所有模块（资源管理）

接口依赖：
- DataProcessor 依赖 ProtocolParser 的解析结果
- SystemScheduler 管理所有模块的任务调度
- DisplayController 接收 DataProcessor 的处理结果
- 所有模块都使用公共的数据类型定义
```

### ⚙️ 组件级上下文 (优先级: 中)

#### 关键组件信息
```markdown
GPU处理组件：
- CUDA核函数实现
- 内存管理（Host/Device）
- 流水线优化和并发
- 错误检查和性能监控

配置管理组件：
- YAML配置文件解析
- 运行时参数动态加载
- 配置校验和错误处理
- 配置变更通知机制

日志系统组件：
- 多级别日志（DEBUG/INFO/WARN/ERROR）
- 线程安全的日志记录
- 性能日志和统计信息
- 日志文件管理和轮转

错误处理组件：
- 统一的错误码定义
- 错误信息格式化和本地化
- 错误上报和恢复机制
- 调试信息收集和输出
```

---

## 关键信息提取

### 📋 技术决策信息

#### 必须保持的技术选择
```markdown
已确定的技术选择：
1. 编程语言：C++17（不可变更）
2. GPU计算：CUDA（项目核心要求）
3. 构建系统：CMake（项目标准）
4. 配置格式：YAML（团队约定）
5. 测试框架：GoogleTest（技术栈标准）

技术约束：
1. 实时性要求：软实时，目标延迟<10ms
2. 内存限制：GPU内存需要精确管理
3. 并发模型：异步处理，线程安全
4. 接口设计：基于虚基类的多态接口
5. 错误处理：错误码 + 异常的混合机制
```

#### 性能基准信息
```markdown
性能目标：
- 数据处理延迟：<10ms（目标）、<20ms（可接受）
- 系统吞吐量：>1000包/秒（目标）、>500包/秒（最低）
- GPU内存使用：<2GB（限制）、<1GB（目标）
- CPU使用率：<80%（多核环境）
- 内存使用：<4GB（系统总内存）

测试基准：
- 测试数据：标准雷达信号仿真数据
- 测试环境：RTX 3060/4060 GPU，16GB RAM
- 测试条件：连续运行1小时，无内存泄漏
- 验收标准：99%的数据包满足延迟要求
```

### 🔧 接口和数据结构信息

#### 核心数据类型
```markdown
RawDataPacket：
- 时间戳：uint64_t (微秒精度)
- 序列号：uint32_t (用于数据包排序)
- I/Q数据：std::vector<float> (原始采样数据)
- 元信息：频率、采样率、增益等参数

ProcessedData：
- 原始包ID：uint32_t (追溯性)
- 处理时间戳：uint64_t (性能监控)
- 幅度数据：std::vector<float> (信号幅度)
- 相位数据：std::vector<float> (信号相位)
- 处理元信息：算法参数、质量指标

ErrorInfo：
- 错误码：枚举类型 (标准化错误分类)
- 错误消息：std::string (详细描述)
- 上下文信息：错误发生的模块、函数、行号
- 恢复建议：可能的恢复操作描述
```

#### 接口设计模式
```markdown
标准接口模式：
1. 纯虚基类定义接口（I前缀）
2. 具体实现类继承接口
3. 智能指针管理对象生命周期
4. 工厂模式创建接口实例

错误处理模式：
1. 关键操作返回状态码
2. 详细错误信息通过输出参数传递
3. 异常用于不可恢复的严重错误
4. 日志记录所有错误和警告

资源管理模式：
1. RAII原则管理所有资源
2. 智能指针自动管理内存
3. GPU内存使用专门的管理类
4. 配置和临时数据及时释放
```

---

## 上下文传递机制

### 🔄 会话内上下文传递

#### 关键信息维护
```markdown
在同一会话中，AI必须始终记住：

当前开发任务：
- 正在开发的模块名称和功能
- 已确认的技术选择和性能要求
- 已提供的依赖文件和接口定义
- 当前的开发阶段和下一步计划

技术约束：
- 项目特定的编码规范和约定
- 性能要求和资源限制
- 模块间的依赖关系和接口约定
- 测试要求和验收标准

已做决策：
- 澄清过程中确认的技术细节
- 用户审批通过的设计方案
- 实现过程中的关键技术选择
- 遇到问题时的解决方案
```

#### 上下文更新机制
```markdown
上下文更新时机：
1. 用户提供新的需求或变更
2. AI澄清过程中获得新信息
3. 技术方案审批后的确认
4. 实现过程中的关键决策

更新方法：
1. 明确记录新信息和变更点
2. 检查与已有信息的一致性
3. 解决可能的冲突和矛盾
4. 确认更新后的完整上下文
```

### 📤 跨会话上下文传递

#### 上下文信息导出
```markdown
会话结束时，AI应总结关键信息：

技术方案摘要：
- 模块名称和核心功能描述
- 确定的技术选择（CPU/GPU、同步/异步等）
- 性能要求和资源限制
- 接口设计和数据格式

实现状态：
- 已完成的文件和组件
- 正在进行的工作内容
- 待解决的问题和依赖
- 下一步的开发计划

关键决策记录：
- 重要的技术选择和理由
- 性能权衡和优化策略
- 遇到的问题和解决方案
- 用户的特殊要求和偏好
```

#### 上下文信息导入
```markdown
新会话开始时，用户应提供：

项目背景：
"这是Radar MVP项目的[模块名]开发，请参考私人文档"

当前状态：
"当前已完成[具体进度]，需要继续[具体任务]"

技术上下文：
"技术选择：[已确定的技术方案]"
"性能要求：[已确认的性能指标]"
"依赖关系：[相关模块和接口]"

特殊要求：
"请注意[特殊约束或要求]"
"继续遵循[特定的编码风格或模式]"
```

### 🔗 上下文引用机制

#### 文档引用
```markdown
标准引用格式：
- 编码规范引用：参考 docs/03_技术规范/代码编写规范.md
- 开发流程引用：参考 docs_private/03_开发指南/模块开发流程.md
- 测试要求引用：参考 docs_private/05_测试策略/单元测试规范.md
- 项目约定引用：参考 docs_private/08_项目特定配置/

引用目的：
1. 确保遵循项目标准和规范
2. 保持技术选择的一致性
3. 避免重复澄清已明确的信息
4. 提供技术决策的依据和追溯
```

#### 代码引用
```markdown
文件引用格式：
- 接口定义：include/interfaces/IDataProcessor.h
- 数据类型：include/common/DataTypes.h
- 配置样例：configs/modules/data_processor.yaml
- 测试参考：tests/unit_tests/data_processor/

引用用途：
1. 保持接口设计的一致性
2. 确保数据格式的兼容性
3. 遵循现有的代码模式和风格
4. 基于现有实现进行扩展和优化
```

---

## 信息更新策略

### 🔄 动态更新机制

#### 需求变更处理
```markdown
需求变更识别：
1. 用户明确提出变更需求
2. 技术实现中发现需求不合理
3. 性能测试结果与预期不符
4. 集成过程中发现接口冲突

变更影响分析：
1. 评估对已完成工作的影响
2. 识别需要重新设计的部分
3. 分析对其他模块的连锁影响
4. 估算变更的工作量和风险

变更执行策略：
1. 优先保护已稳定的核心接口
2. 最小化对其他模块的影响
3. 保持向后兼容性（如可能）
4. 更新相关的文档和测试
```

#### 技术方案调整
```markdown
调整触发条件：
1. 性能测试未达到预期目标
2. 实现复杂度超出预期
3. 发现更优的技术方案
4. 外部环境或依赖的变化

调整决策流程：
1. 分析当前方案的问题和限制
2. 评估备选方案的优缺点
3. 与用户确认调整的必要性
4. 制定详细的调整计划

调整实施原则：
1. 渐进式调整，避免大幅重构
2. 保持关键接口的稳定性
3. 充分测试调整后的效果
4. 及时更新相关文档
```

### 📊 版本化管理

#### 上下文版本控制
```markdown
版本标识：
- 主版本：重大技术方案变更
- 次版本：功能需求调整或扩展
- 修订版本：细节优化和问题修复

版本内容：
v1.0 - 初始技术方案和接口设计
v1.1 - 性能要求调整和优化策略
v1.2 - 错误处理机制完善
v2.0 - 架构重构或重大技术变更

版本管理：
1. 每次重大变更创建新版本
2. 保留关键版本的完整上下文
3. 记录版本间的变更原因和影响
4. 支持必要时的版本回退
```

#### 一致性维护
```markdown
一致性检查要点：
1. 技术选择的内部一致性
2. 性能要求的可实现性
3. 接口设计的完整性和兼容性
4. 实现方案与设计的一致性

一致性维护机制：
1. 变更前的影响分析
2. 变更后的一致性验证
3. 冲突问题的及时发现和解决
4. 定期的全面一致性检查

问题解决流程：
1. 识别一致性问题和冲突
2. 分析问题的根本原因
3. 制定解决方案和调整计划
4. 实施解决方案并验证效果
```

---

## 上下文验证方法

### ✅ 理解确认机制

#### 关键信息确认
```markdown
AI理解确认模板：
"基于当前上下文，我理解的情况是：

【项目背景】
- 项目：Radar MVP系统开发
- 当前任务：[具体模块/组件]开发
- 开发阶段：[MVP/优化/测试]

【技术方案】
- 核心技术：[CPU/GPU/混合]处理
- 处理模式：[同步/异步/流水线]
- 性能目标：延迟<[X]ms，吞吐量>[Y]包/秒

【接口设计】
- 输入：[数据类型和格式]
- 输出：[数据类型和格式]
- 错误处理：[机制和策略]

【开发约束】
- 编码规范：遵循项目标准
- 资源限制：GPU内存<[X]GB
- 集成要求：与[相关模块]协作

请确认我的理解是否正确？"
```

#### 分歧识别和解决
```markdown
分歧识别标准：
1. 用户反馈与AI理解不一致
2. 技术方案内部存在矛盾
3. 新需求与已有约束冲突
4. 实现细节与设计目标不符

解决流程：
1. 明确指出分歧的具体内容
2. 分析分歧产生的原因
3. 提供可选的解决方案
4. 与用户协商确定最终方案
5. 更新上下文信息

分歧解决原则：
1. 优先保证核心功能需求
2. 尊重用户的明确意见
3. 基于技术可行性进行权衡
4. 保持整体方案的一致性
```

### 🔍 完整性检查

#### 上下文完整性自查
```markdown
AI自查清单：

技术方案完整性 ☐
- [ ] 核心算法和技术选择已明确
- [ ] 性能要求已量化确定
- [ ] 资源约束已明确定义
- [ ] 实现复杂度在可控范围

接口设计完整性 ☐
- [ ] 输入输出接口已完整定义
- [ ] 错误处理机制已设计
- [ ] 生命周期管理已考虑
- [ ] 并发安全性已确认

集成方案完整性 ☐
- [ ] 依赖模块和接口已识别
- [ ] 配置管理方案已明确
- [ ] 测试策略已规划
- [ ] 部署和维护已考虑

项目约束完整性 ☐
- [ ] 编码规范要求已确认
- [ ] 性能和资源限制已明确
- [ ] 开发流程要求已了解
- [ ] 质量标准已确定
```

#### 缺失信息补充
```markdown
发现信息缺失时的处理：

主动识别缺失：
1. 对照项目标准检查必需信息
2. 分析技术方案的关键要素
3. 验证接口设计的完整性
4. 检查性能要求的覆盖度

补充信息策略：
1. 优先补充关键技术决策信息
2. 参考项目文档获取标准信息
3. 基于经验推断合理默认值
4. 向用户询问无法确定的信息

信息补充确认：
1. 明确说明补充的信息内容
2. 解释补充信息的来源和依据
3. 确认补充信息的合理性
4. 请求用户验证和确认
```

---

## 实践指南

### 📋 AI使用指南

#### 上下文建立最佳实践
```markdown
新会话开始时：
1. 主动询问项目和任务的基本信息
2. 确认需要参考的私人文档范围
3. 了解当前的开发阶段和进度
4. 明确用户的期望和关键约束

会话进行中：
1. 持续更新和维护关键信息
2. 在关键决策点进行理解确认
3. 发现信息冲突时主动澄清
4. 保持技术方案的内部一致性

会话结束时：
1. 总结关键的技术决策和方案
2. 明确当前的进度和下一步计划
3. 记录重要的问题和解决方案
4. 提供必要的上下文传递信息
```

#### 上下文维护技巧
```markdown
信息组织技巧：
1. 按优先级组织上下文信息
2. 保持信息的结构化和条理性
3. 及时更新过时或变更的信息
4. 建立信息间的关联和依赖关系

记忆优化策略：
1. 重点记忆项目级和模块级信息
2. 关键技术决策和性能要求
3. 用户的特殊偏好和约束条件
4. 重要的问题和解决方案

信息验证习惯：
1. 定期确认关键信息的准确性
2. 发现矛盾时主动询问澄清
3. 重要决策前进行完整性检查
4. 实现过程中验证与设计的一致性
```

### 👤 用户配合指南

#### 高效提供上下文
```markdown
项目信息提供：
"这是Radar MVP项目，请参考私人文档。当前开发[具体模块]，技术要求[具体要求]。"

进度状态说明：
"前期已完成[具体内容]，当前需要[具体任务]，依赖[具体文件/模块]。"

特殊要求明确：
"请特别注意[关键约束]，遵循[特定规范]，优先考虑[性能/可维护性/等]。"

变更通知及时：
"需求有变更：[具体变更内容]，请调整[相关部分]，保持[不变的要求]。"
```

#### 上下文校正技巧
```markdown
发现理解偏差时：
"AI的理解有偏差，实际情况是[正确信息]，不是[错误理解]。"

补充遗漏信息时：
"补充关键信息：[具体信息]，这会影响[相关设计]。"

确认关键决策时：
"确认技术方案：[具体方案]，性能要求：[具体指标]，请基于此继续。"

提供反馈时：
"这个方案的[具体部分]很好，但[另一部分]需要调整为[具体要求]。"
```

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要           |
| :--- | :--------- | :----- | :----------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建上下文管理策略 |
