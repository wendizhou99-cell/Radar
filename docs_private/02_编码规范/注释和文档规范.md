# æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ

- **æ ‡é¢˜**: AIåä½œå¼€å‘æ³¨é‡Šå’Œæ–‡æ¡£ç¼–å†™æ ‡å‡†
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## Doxygenæ³¨é‡Šæ ‡å‡†

### ğŸ“ æ–‡ä»¶å¤´æ³¨é‡Šæ¨¡æ¿

#### æ¥å£å¤´æ–‡ä»¶æ³¨é‡Š
```cpp
/**
 * @file IDataProcessor.h
 * @brief æ•°æ®å¤„ç†æ¨¡å—çš„ç»Ÿä¸€æ¥å£å®šä¹‰
 *
 * æœ¬æ–‡ä»¶å®šä¹‰äº†é›·è¾¾æ•°æ®å¤„ç†ç³»ç»Ÿä¸­æ•°æ®å¤„ç†æ¨¡å—çš„æŠ½è±¡æ¥å£ã€‚
 * æ‰€æœ‰å…·ä½“çš„æ•°æ®å¤„ç†å™¨ï¼ˆCPUå¤„ç†å™¨ã€GPUå¤„ç†å™¨ç­‰ï¼‰éƒ½åº”ç»§æ‰¿æ­¤æ¥å£ã€‚
 *
 * @author Kelin
 * @version 1.0
 * @date 2025-09-10
 * @since 1.0
 *
 * @see DataProcessor
 * @see GPUProcessor
 * @see CPUProcessor
 */

#pragma once

#include "common/Types.h"
#include "common/ErrorCodes.h"
```

#### å®ç°æ–‡ä»¶æ³¨é‡Š
```cpp
/**
 * @file DataProcessor.cpp
 * @brief IDataProcessor æ¥å£çš„å…·ä½“å®ç°
 *
 * å®ç°äº†åŸºäº GPU åŠ é€Ÿçš„é›·è¾¾æ•°æ®å¤„ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š
 * - è„‰å†²å‹ç¼©ç®—æ³•
 * - å¤šæ™®å‹’å¤„ç†ç®—æ³•
 * - æ³¢æŸå½¢æˆç®—æ³•
 *
 * @author Kelin
 * @version 1.0
 * @date 2025-09-10
 *
 * @todo ä¼˜åŒ–å†…å­˜åˆ†é…ç­–ç•¥
 * @todo æ·»åŠ è‡ªé€‚åº”å‚æ•°è°ƒæ•´åŠŸèƒ½
 */

#include "processor/DataProcessor.h"
```

### ğŸ—ï¸ ç±»å’Œç»“æ„ä½“æ³¨é‡Š

#### æ¥å£ç±»æ³¨é‡Š
```cpp
/**
 * @brief æ•°æ®å¤„ç†æ¨¡å—çš„æŠ½è±¡æ¥å£
 *
 * è¯¥æ¥å£å®šä¹‰äº†é›·è¾¾æ•°æ®å¤„ç†çš„æ ‡å‡†æ“ä½œï¼ŒåŒ…æ‹¬åˆå§‹åŒ–ã€æ•°æ®å¤„ç†ã€
 * çŠ¶æ€æŸ¥è¯¢ç­‰åŠŸèƒ½ã€‚å®ç°ç±»éœ€è¦æä¾›å…·ä½“çš„å¤„ç†ç®—æ³•ã€‚
 *
 * @details
 * å¤„ç†æµç¨‹ï¼š
 * 1. è°ƒç”¨ initialize() åˆå§‹åŒ–å¤„ç†å™¨
 * 2. å¾ªç¯è°ƒç”¨ process() å¤„ç†æ•°æ®
 * 3. æ ¹æ®éœ€è¦è°ƒç”¨ getStatistics() è·å–ç»Ÿè®¡ä¿¡æ¯
 * 4. è°ƒç”¨ cleanup() æ¸…ç†èµ„æº
 *
 * @note è¯¥æ¥å£çš„å®ç°å¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„
 * @warning åœ¨è°ƒç”¨ process() å‰å¿…é¡»å…ˆè°ƒç”¨ initialize()
 *
 * @since 1.0
 * @see DataProcessor
 * @see ProcessingConfig
 */
class IDataProcessor {
public:
    virtual ~IDataProcessor() = default;

    // æ¥å£æ–¹æ³•...
};
```

#### æ•°æ®ç»“æ„æ³¨é‡Š
```cpp
/**
 * @brief é›·è¾¾åŸå§‹æ•°æ®åŒ…ç»“æ„
 *
 * åŒ…å«ä»é›·è¾¾å‰ç«¯æ¥æ”¶åˆ°çš„åŸå§‹I/Qæ•°æ®ä»¥åŠç›¸å…³çš„å…ƒä¿¡æ¯ã€‚
 * è¯¥ç»“æ„ä½“è®¾è®¡ä¸ºå†…å­˜å¯¹é½ï¼Œä»¥ä¼˜åŒ–GPUå¤„ç†æ€§èƒ½ã€‚
 *
 * @details
 * æ•°æ®å¸ƒå±€ï¼š
 * - timestamp: æ•°æ®é‡‡é›†æ—¶é—´æˆ³ï¼ˆå¾®ç§’ç²¾åº¦ï¼‰
 * - sequenceId: æ•°æ®åŒ…åºåˆ—å·ï¼ˆç”¨äºä¸¢åŒ…æ£€æµ‹ï¼‰
 * - iData: Iè·¯ï¼ˆåŒç›¸ï¼‰é‡‡æ ·æ•°æ®
 * - qData: Qè·¯ï¼ˆæ­£äº¤ï¼‰é‡‡æ ·æ•°æ®
 * - metadata: é‡‡é›†å‚æ•°å’ŒçŠ¶æ€ä¿¡æ¯
 *
 * @note I/Qæ•°æ®é•¿åº¦å¿…é¡»ç›¸ç­‰
 * @warning ç›´æ¥ä¿®æ”¹æ•°æ®å†…å®¹å¯èƒ½å½±å“å¤„ç†ç»“æœ
 */
struct alignas(16) RawDataPacket {
    uint64_t timestamp;           ///< æ•°æ®é‡‡é›†æ—¶é—´æˆ³ï¼ˆå¾®ç§’ï¼‰
    uint32_t sequenceId;          ///< æ•°æ®åŒ…åºåˆ—å·
    uint32_t reserved;            ///< ä¿ç•™å­—æ®µï¼Œç”¨äºå¯¹é½

    std::vector<float> iData;     ///< Iè·¯é‡‡æ ·æ•°æ®
    std::vector<float> qData;     ///< Qè·¯é‡‡æ ·æ•°æ®

    AcquisitionMetadata metadata; ///< é‡‡é›†å…ƒä¿¡æ¯

    /**
     * @brief æ£€æŸ¥æ•°æ®åŒ…çš„æœ‰æ•ˆæ€§
     * @return æ•°æ®åŒ…æ˜¯å¦æœ‰æ•ˆ
     * @retval true æ•°æ®åŒ…æ ¼å¼æ­£ç¡®ï¼Œå¯ä»¥å¤„ç†
     * @retval false æ•°æ®åŒ…å­˜åœ¨é”™è¯¯ï¼Œéœ€è¦ä¸¢å¼ƒ
     */
    bool isValid() const;
};
```

### ğŸ”§ æ–¹æ³•æ³¨é‡Šè§„èŒƒ

#### å®Œæ•´æ–¹æ³•æ³¨é‡Šæ¨¡æ¿
```cpp
/**
 * @brief å¤„ç†å•ä¸ªé›·è¾¾æ•°æ®åŒ…
 *
 * å¯¹è¾“å…¥çš„åŸå§‹é›·è¾¾æ•°æ®æ‰§è¡Œå®Œæ•´çš„ä¿¡å·å¤„ç†æµç¨‹ï¼ŒåŒ…æ‹¬è„‰å†²å‹ç¼©ã€
 * å¤šæ™®å‹’å¤„ç†å’Œæ³¢æŸå½¢æˆç­‰ç®—æ³•ã€‚
 *
 * @param[in] input å¾…å¤„ç†çš„åŸå§‹æ•°æ®åŒ…
 *                  - å¿…é¡»æ˜¯æœ‰æ•ˆçš„ RawDataPacket ç»“æ„
 *                  - I/Qæ•°æ®é•¿åº¦å¿…é¡»ç›¸ç­‰ä¸”å¤§äº0
 * @param[out] output å¤„ç†ç»“æœçš„è¾“å‡ºå¯¹è±¡
 *                    - å‡½æ•°æˆåŠŸæ—¶åŒ…å«å¤„ç†åçš„æ•°æ®
 *                    - å‡½æ•°å¤±è´¥æ—¶å†…å®¹æœªå®šä¹‰
 * @param[in] options å¯é€‰çš„å¤„ç†å‚æ•°
 *                    - é»˜è®¤å€¼ä½¿ç”¨æ ‡å‡†å¤„ç†é…ç½®
 *                    - nullptr è¡¨ç¤ºä½¿ç”¨é»˜è®¤é…ç½®
 *
 * @return å¤„ç†çŠ¶æ€ç 
 * @retval SUCCESS å¤„ç†æˆåŠŸå®Œæˆ
 * @retval INVALID_INPUT è¾“å…¥æ•°æ®æ ¼å¼é”™è¯¯
 * @retval PROCESSING_ERROR å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯
 * @retval OUT_OF_MEMORY å†…å­˜ä¸è¶³
 *
 * @pre initialize() å¿…é¡»å·²æˆåŠŸè°ƒç”¨
 * @pre input.isValid() å¿…é¡»è¿”å› true
 * @post æˆåŠŸæ—¶ output åŒ…å«æœ‰æ•ˆçš„å¤„ç†ç»“æœ
 *
 * @note è¯¥æ–¹æ³•æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¯ä»¥å¹¶å‘è°ƒç”¨
 * @warning å¤§æ•°æ®é‡å¤„ç†å¯èƒ½è€—æ—¶è¾ƒé•¿ï¼ˆ>100msï¼‰
 * @warning GPU å†…å­˜ä½¿ç”¨é‡å¯èƒ½è¾¾åˆ°æ•°GB
 *
 * @exception std::bad_alloc å†…å­˜åˆ†é…å¤±è´¥æ—¶æŠ›å‡º
 * @exception cuda_error CUDA æ“ä½œå¤±è´¥æ—¶æŠ›å‡º
 *
 * @see initialize()
 * @see ProcessingOptions
 * @see ProcessingResult
 *
 * @since 1.0
 * @deprecated ä½¿ç”¨ processBatch() è·å¾—æ›´å¥½çš„æ€§èƒ½
 */
virtual ProcessingStatus process(
    const RawDataPacket& input,
    ProcessedData& output,
    const ProcessingOptions* options = nullptr
) = 0;
```

#### ç®€åŒ–æ–¹æ³•æ³¨é‡Š
```cpp
/**
 * @brief è·å–å¤„ç†å™¨çš„å½“å‰çŠ¶æ€
 * @return å½“å‰å¤„ç†å™¨çŠ¶æ€
 * @note è¯¥æ–¹æ³•æ˜¯çº¿ç¨‹å®‰å…¨çš„
 */
virtual ProcessorState getState() const = 0;

/**
 * @brief æ£€æŸ¥å¤„ç†å™¨æ˜¯å¦å·²åˆå§‹åŒ–
 * @return true å¦‚æœå·²åˆå§‹åŒ–ï¼Œfalse å¦åˆ™
 */
virtual bool isInitialized() const = 0;

/**
 * @brief é‡ç½®å¤„ç†å™¨åˆ°åˆå§‹çŠ¶æ€
 * @warning è°ƒç”¨æ­¤æ–¹æ³•ä¼šä¸¢å¤±æ‰€æœ‰ç¼“å­˜çš„æ•°æ®
 */
virtual void reset() = 0;
```

### ğŸ“Š å‚æ•°å’Œè¿”å›å€¼æ³¨é‡Š

#### å‚æ•°æ–¹å‘æ ‡è®°
```cpp
/**
 * @brief æ‰¹é‡å¤„ç†å¤šä¸ªæ•°æ®åŒ…
 *
 * @param[in] inputs è¾“å…¥æ•°æ®åŒ…æ•°ç»„
 * @param[out] outputs è¾“å‡ºç»“æœæ•°ç»„ï¼Œå¤§å°å¿…é¡»ä¸ inputs ç›¸åŒ
 * @param[in,out] stats ç»Ÿè®¡ä¿¡æ¯å¯¹è±¡ï¼Œè¾“å…¥å½“å‰ç»Ÿè®¡ï¼Œè¾“å‡ºæ›´æ–°åçš„ç»Ÿè®¡
 * @param[in] count æ•°æ®åŒ…æ•°é‡
 *
 * @return æˆåŠŸå¤„ç†çš„æ•°æ®åŒ…æ•°é‡
 */
size_t processBatch(
    const RawDataPacket inputs[],
    ProcessedData outputs[],
    ProcessingStats& stats,
    size_t count
);
```

#### å¤æ‚è¿”å›å€¼è¯´æ˜
```cpp
/**
 * @brief å¼‚æ­¥å¯åŠ¨æ•°æ®å¤„ç†ä»»åŠ¡
 *
 * @param input è¾“å…¥æ•°æ®åŒ…
 * @param callback å¤„ç†å®Œæˆå›è°ƒå‡½æ•°
 *
 * @return å¼‚æ­¥ä»»åŠ¡çš„ future å¯¹è±¡
 * @retval valid_future ä»»åŠ¡æˆåŠŸæäº¤
 * @retval empty_future ä»»åŠ¡æäº¤å¤±è´¥
 *
 * @note é€šè¿‡è¿”å›çš„ future å¯ä»¥ï¼š
 *       - æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆï¼šfuture.wait_for(0s)
 *       - è·å–å¤„ç†ç»“æœï¼šfuture.get()
 *       - å–æ¶ˆæœªå¼€å§‹çš„ä»»åŠ¡ï¼šfuture.cancel()
 */
std::future<ProcessingResult> processAsync(
    const RawDataPacket& input,
    std::function<void(const ProcessingResult&)> callback
);
```

---

## å†…è”æ³¨é‡ŠåŸåˆ™

### ğŸ’¡ ä½•æ—¶å†™æ³¨é‡Š

#### å¿…é¡»å†™æ³¨é‡Šçš„æƒ…å†µ
```cpp
class DataProcessor {
private:
    // GPU å†…å­˜ç®¡ç†
    float* d_inputBuffer_;    ///< è®¾å¤‡ç«¯è¾“å…¥æ•°æ®ç¼“å†²åŒº
    float* d_outputBuffer_;   ///< è®¾å¤‡ç«¯è¾“å‡ºæ•°æ®ç¼“å†²åŒº
    size_t bufferSize_;       ///< ç¼“å†²åŒºå¤§å°ï¼ˆå­—èŠ‚æ•°ï¼‰

    // æ€§èƒ½ç»Ÿè®¡
    mutable std::mutex statsMutex_;  ///< ä¿æŠ¤ç»Ÿè®¡æ•°æ®çš„äº’æ–¥é”
    uint64_t totalProcessed_;        ///< å·²å¤„ç†çš„æ•°æ®åŒ…æ€»æ•°
    double avgProcessingTime_;       ///< å¹³å‡å¤„ç†æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰

public:
    bool initialize(const Config& config) {
        // æ£€æŸ¥ GPU å¯ç”¨æ€§
        int deviceCount;
        cudaGetDeviceCount(&deviceCount);
        if (deviceCount == 0) {
            LOG_ERROR("No CUDA capable devices found");
            return false;
        }

        // åˆ†é… GPU å†…å­˜ - é¢„åˆ†é…è¶³å¤Ÿå¤§çš„ç¼“å†²åŒºä»¥é¿å…é¢‘ç¹åˆ†é…
        size_t maxDataSize = config.maxPacketSize * config.maxBatchSize;
        if (cudaMalloc(&d_inputBuffer_, maxDataSize) != cudaSuccess) {
            LOG_ERROR("Failed to allocate GPU input buffer");
            return false;
        }

        return true;
    }
};
```

#### ä¸éœ€è¦å†™æ³¨é‡Šçš„æƒ…å†µ
```cpp
// âŒ è¿‡åº¦æ³¨é‡Šï¼šä»£ç æœ¬èº«å·²ç»å¾ˆæ¸…æ™°
int count = 0;  // åˆå§‹åŒ–è®¡æ•°å™¨ä¸º0

// âŒ é‡å¤ä»£ç å†…å®¹çš„æ³¨é‡Š
data.clear();  // æ¸…ç©ºæ•°æ®

// âœ… å¥½çš„åšæ³•ï¼šä»£ç è‡ªæ³¨é‡Š
void processValidPackets(const std::vector<RawDataPacket>& packets) {
    for (const auto& packet : packets) {
        if (packet.isValid()) {
            processPacket(packet);
        }
    }
}
```

### ğŸ“‹ æ³¨é‡Šå†…å®¹æŒ‡å—

#### è§£é‡Š"ä¸ºä»€ä¹ˆ"è€Œä¸æ˜¯"åšä»€ä¹ˆ"
```cpp
// âŒ è§£é‡Šåšä»€ä¹ˆ
i++;  // i åŠ  1

// âœ… è§£é‡Šä¸ºä»€ä¹ˆ
i++;  // è·³è¿‡æ•°æ®åŒ…å¤´ï¼Œç›´æ¥å¤„ç†æœ‰æ•ˆè½½è·

// âŒ é‡å¤ä»£ç é€»è¾‘
if (buffer == nullptr) {
    return false;  // å¦‚æœç¼“å†²åŒºä¸ºç©ºï¼Œè¿”å› false
}

// âœ… è§£é‡Šä¸šåŠ¡é€»è¾‘
if (buffer == nullptr) {
    return false;  // æœªåˆå§‹åŒ–çš„å¤„ç†å™¨ä¸èƒ½æ‰§è¡Œå¤„ç†æ“ä½œ
}
```

#### è§£é‡Šå¤æ‚ç®—æ³•çš„æ€è·¯
```cpp
void computeFFT(const float* input, cuComplex* output, int N) {
    // ä½¿ç”¨ Cooley-Tukey ç®—æ³•å®ç° FFT
    // è¯¥ç®—æ³•å°† N ç‚¹ DFT åˆ†è§£ä¸ºä¸¤ä¸ª N/2 ç‚¹ DFTï¼Œé€’å½’è®¡ç®—
    // æ—¶é—´å¤æ‚åº¦ä» O(NÂ²) é™ä½åˆ° O(N log N)

    if (N <= 1) return;

    // åˆ†ç¦»å¶æ•°å’Œå¥‡æ•°ç´¢å¼•çš„å…ƒç´ 
    // è¿™æ˜¯åˆ†æ²»ç­–ç•¥çš„å…³é”®æ­¥éª¤
    separateEvenOdd(input, N);

    // é€’å½’è®¡ç®—ä¸¤ä¸ªå­é—®é¢˜
    computeFFT(evenElements, output, N/2);
    computeFFT(oddElements, output + N/2, N/2);

    // åˆå¹¶ç»“æœï¼Œåº”ç”¨æ—‹è½¬å› å­
    // æ—‹è½¬å› å­ W_N^k = e^(-2Ï€ik/N) ç¡®ä¿æ­£ç¡®çš„é¢‘åŸŸæ˜ å°„
    combineResults(output, N);
}
```

### âš ï¸ ç‰¹æ®Šæ ‡è®°æ³¨é‡Š

#### TODO æ³¨é‡Šè§„èŒƒ
```cpp
// TODO(ä½œè€…å): ç®€çŸ­æè¿°éœ€è¦åšçš„äº‹æƒ…
// TODO(å¼ ä¸‰): ä¼˜åŒ– GPU å†…å­˜åˆ†é…ç­–ç•¥ä»¥å‡å°‘ç¢ç‰‡
void allocateMemory() {
    // å½“å‰å®ç°ï¼šç®€å•åˆ†é…
    cudaMalloc(&buffer, size);

    // TODO(æå››): æ·»åŠ å†…å­˜æ± ç®¡ç†ï¼Œé¢„æœŸæ€§èƒ½æå‡ 20%
    // ç›¸å…³ issue: #123
    // è®¡åˆ’å®Œæˆæ—¶é—´: 2025-10-01
}

// TODO(å›¢é˜Ÿ): å®ç°è‡ªé€‚åº”æ‰¹å¤§å°è°ƒæ•´
// æ ¹æ® GPU åˆ©ç”¨ç‡åŠ¨æ€è°ƒæ•´å¤„ç†æ‰¹å¤§å°
// é¢„æœŸæ”¶ç›Š: æå‡ååé‡ 15-30%
class BatchProcessor {
    // å®ç°...
};
```

#### FIXME æ³¨é‡Šè§„èŒƒ
```cpp
// FIXME(ç´§æ€¥): å†…å­˜æ³„æ¼é—®é¢˜
// åœ¨å¤„ç†å¤§é‡æ•°æ®æ—¶ä¼šå‘ç”Ÿå†…å­˜æ³„æ¼
// å½±å“ï¼šé•¿æ—¶é—´è¿è¡Œåç³»ç»Ÿå†…å­˜è€—å°½
// é‡ç°ï¼šè¿ç»­å¤„ç† >10000 ä¸ªæ•°æ®åŒ…
void processData() {
    float* tempBuffer = new float[size];
    // ... å¤„ç†é€»è¾‘
    // FIXME: è¿™é‡Œç¼ºå°‘ delete[] tempBuffer
}

// FIXME(æ€§èƒ½): åŒæ­¥ç­‰å¾…å¯¼è‡´ GPU åˆ©ç”¨ç‡ä½
// å½“å‰å®ç°åœ¨æ¯æ¬¡å¤„ç†åéƒ½åŒæ­¥ç­‰å¾…ï¼Œå¯¼è‡´ GPU ç©ºé—²
// å½±å“ï¼šGPU åˆ©ç”¨ç‡ä»…è¾¾åˆ° 30-40%
// è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ CUDA æµå®ç°å¼‚æ­¥å¤„ç†
void processKernel() {
    launchKernel<<<...>>>();
    cudaDeviceSynchronize();  // FIXME: ç§»é™¤åŒæ­¥ç­‰å¾…
}
```

#### WARNING å’Œ NOTE æ³¨é‡Š
```cpp
// WARNING: æ­¤å‡½æ•°ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
// å¹¶å‘è°ƒç”¨å¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰å’Œæœªå®šä¹‰è¡Œä¸º
// å¦‚éœ€å¹¶å‘ä½¿ç”¨ï¼Œè¯·åœ¨å¤–éƒ¨æ·»åŠ äº’æ–¥é”ä¿æŠ¤
void updateGlobalConfig(const Config& config) {
    globalConfig = config;  // éåŸå­æ“ä½œ
}

// NOTE: GPU å†…å­˜åˆ†é…å¤±è´¥æ—¶ä¼šè‡ªåŠ¨é™çº§åˆ° CPU å¤„ç†
// è¿™ç§é™çº§æ˜¯é€æ˜çš„ï¼Œä½†æ€§èƒ½ä¼šæ˜¾è‘—ä¸‹é™ï¼ˆçº¦ 10xï¼‰
bool initializeProcessor() {
    if (cudaMalloc(&d_buffer, size) != cudaSuccess) {
        // é™çº§åˆ° CPU å¤„ç†
        h_buffer = new float[size];
        useGPU = false;
    }
}
```

---

## ç®—æ³•æ³¨é‡Šç­–ç•¥

### ğŸ§® å¤æ‚ç®—æ³•æ³¨é‡Š

#### æ•°å­¦å…¬å¼å’Œç®—æ³•åŸç†
```cpp
/**
 * @brief å®ç°è„‰å†²å‹ç¼©ç®—æ³•
 *
 * è„‰å†²å‹ç¼©é€šè¿‡åŒ¹é…æ»¤æ³¢å™¨æé«˜è·ç¦»åˆ†è¾¨ç‡ï¼š
 *
 * æ•°å­¦åŸç†ï¼š
 * y(t) = âˆ« x(Ï„) * h(t-Ï„) dÏ„
 * å…¶ä¸­ï¼š
 * - x(t): æ¥æ”¶ä¿¡å·
 * - h(t): åŒ¹é…æ»¤æ³¢å™¨å†²æ¿€å“åº”
 * - y(t): å‹ç¼©åçš„è¾“å‡ºä¿¡å·
 *
 * é¢‘åŸŸå®ç°ï¼š
 * Y(f) = X(f) * H*(f)
 * å…¶ä¸­ H*(f) æ˜¯æ»¤æ³¢å™¨é¢‘ç‡å“åº”çš„å…±è½­
 *
 * @param input æ—¶åŸŸè¾“å…¥ä¿¡å·
 * @param filter åŒ¹é…æ»¤æ³¢å™¨ç³»æ•°
 * @param output å‹ç¼©åçš„è¾“å‡ºä¿¡å·
 */
void pulseCompression(
    const cuComplex* input,
    const cuComplex* filter,
    cuComplex* output,
    int N
) {
    // 1. å¯¹è¾“å…¥ä¿¡å·è¿›è¡Œ FFT
    // å°†æ—¶åŸŸä¿¡å·è½¬æ¢åˆ°é¢‘åŸŸè¿›è¡Œå¿«é€Ÿå·ç§¯
    cufftExecC2C(fftPlan, input, d_inputFreq, CUFFT_FORWARD);

    // 2. é¢‘åŸŸç›¸ä¹˜å®ç°å·ç§¯
    // output_freq[k] = input_freq[k] * conj(filter_freq[k])
    complexMultiplyConjugate<<<gridSize, blockSize>>>(
        d_inputFreq, d_filterFreq, d_outputFreq, N);

    // 3. é€† FFT å›åˆ°æ—¶åŸŸ
    // å¾—åˆ°è„‰å†²å‹ç¼©çš„æœ€ç»ˆç»“æœ
    cufftExecC2C(fftPlan, d_outputFreq, output, CUFFT_INVERSE);
}
```

#### ç®—æ³•æ­¥éª¤åˆ†è§£
```cpp
/**
 * @brief å¤šæ™®å‹’å¤„ç†ç®—æ³•å®ç°
 *
 * ç®—æ³•æµç¨‹ï¼š
 * Step 1: è·ç¦»-æ—¶é—´çŸ©é˜µæ„å»º
 * Step 2: æ²¿æ…¢æ—¶é—´ç»´åº¦çš„ FFT
 * Step 3: å¤šæ™®å‹’æ»¤æ³¢
 * Step 4: éç›¸å¹²ç§¯ç´¯
 * Step 5: æ’è™šè­¦æ£€æµ‹ (CFAR)
 */
void dopplerProcessing(const RadarData& input, DopplerResult& output) {
    // Step 1: æ„å»ºè·ç¦»-æ—¶é—´æ•°æ®çŸ©é˜µ (Range-Time Matrix)
    // å°†è¿ç»­çš„è„‰å†²æ•°æ®é‡æ’ä¸ºäºŒç»´çŸ©é˜µ
    // è¡Œï¼šè·ç¦»å•å…ƒï¼Œåˆ—ï¼šè„‰å†²æ—¶é—´
    arrangeRangeTimeMatrix(input.pulses, rangeTimeMatrix);

    // Step 2: æ…¢æ—¶é—´ç»´åº¦ FFT (Slow-Time FFT)
    // æ²¿æ¯ä¸ªè·ç¦»å•å…ƒçš„æ—¶é—´è½´è¿›è¡Œ FFTï¼Œæå–å¤šæ™®å‹’ä¿¡æ¯
    // è¿™ä¸€æ­¥å°†é€Ÿåº¦ä¿¡æ¯è½¬æ¢ä¸ºé¢‘åŸŸè¡¨ç¤º
    for (int rangeIndex = 0; rangeIndex < numRangeBins; ++rangeIndex) {
        fft1D(&rangeTimeMatrix[rangeIndex][0], dopplerMatrix[rangeIndex], numPulses);
    }

    // Step 3: å¤šæ™®å‹’æ»¤æ³¢
    // åº”ç”¨çª—å‡½æ•°å‡å°‘æ—ç“£ï¼Œæé«˜æ£€æµ‹æ€§èƒ½
    applyHammingWindow(dopplerMatrix);

    // Step 4: éç›¸å¹²ç§¯ç´¯
    // è®¡ç®—å¹…åº¦çš„å¹³æ–¹ï¼Œå®ç°èƒ½é‡ç§¯ç´¯
    computePowerSpectrum(dopplerMatrix, powerMatrix);

    // Step 5: æ’è™šè­¦æ£€æµ‹ (CFAR)
    // è‡ªé€‚åº”é˜ˆå€¼æ£€æµ‹ï¼Œä¿æŒæ’å®šçš„è™šè­¦æ¦‚ç‡
    cfarDetection(powerMatrix, output.detections);
}
```

### âš¡ CUDA Kernel æ³¨é‡Š

#### Kernel å‡½æ•°è¯¦ç»†æ³¨é‡Š
```cuda
/**
 * @brief å¹¶è¡Œè„‰å†²å‹ç¼© CUDA æ ¸å‡½æ•°
 *
 * çº¿ç¨‹ç»„ç»‡ï¼š
 * - æ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªè·ç¦»å•å…ƒ
 * - ä½¿ç”¨å…±äº«å†…å­˜ç¼“å­˜é¢‘åŸŸæ•°æ®
 * - åˆ©ç”¨ warp å†…å¹¶è¡ŒåŠ é€Ÿ FFT è®¡ç®—
 *
 * å†…å­˜è®¿é—®æ¨¡å¼ï¼š
 * - å…¨å±€å†…å­˜ï¼šåˆå¹¶è®¿é—®è¾“å…¥æ•°æ®
 * - å…±äº«å†…å­˜ï¼šç¼“å­˜ FFT ä¸­é—´ç»“æœ
 * - å¸¸é‡å†…å­˜ï¼šå­˜å‚¨æ»¤æ³¢å™¨ç³»æ•°
 *
 * æ€§èƒ½ç‰¹å¾ï¼š
 * - è®¡ç®—å¼ºåº¦ï¼šé«˜ï¼ˆå¤§é‡å¤æ•°ä¹˜æ³•ï¼‰
 * - å†…å­˜å¸¦å®½ï¼šä¸­ç­‰ï¼ˆæ•°æ®é‡ç”¨åº¦è¾ƒé«˜ï¼‰
 * - åŒæ­¥éœ€æ±‚ï¼šå—å†…åŒæ­¥ï¼ˆå…±äº«å†…å­˜ï¼‰
 *
 * @param input [in] æ—¶åŸŸè¾“å…¥ä¿¡å· (N ä¸ªå¤æ•°)
 * @param output [out] å‹ç¼©åè¾“å‡ºä¿¡å· (N ä¸ªå¤æ•°)
 * @param N [in] ä¿¡å·é•¿åº¦ï¼Œå¿…é¡»æ˜¯ 2 çš„å¹‚
 */
__global__ void pulseCompressionKernel(
    const cuComplex* input,
    cuComplex* output,
    int N
) {
    // è®¡ç®—å…¨å±€çº¿ç¨‹ç´¢å¼•
    const int tid = blockIdx.x * blockDim.x + threadIdx.x;
    const int localTid = threadIdx.x;

    // å…±äº«å†…å­˜ï¼šç¼“å­˜ä¸€ä¸ªå—çš„æ•°æ®è¿›è¡Œ FFT
    __shared__ cuComplex s_data[BLOCK_SIZE];
    __shared__ cuComplex s_temp[BLOCK_SIZE];

    // è¾¹ç•Œæ£€æŸ¥ï¼šç¡®ä¿ä¸ä¼šè¶Šç•Œè®¿é—®
    if (tid >= N) return;

    // 1. ä»å…¨å±€å†…å­˜åŠ è½½æ•°æ®åˆ°å…±äº«å†…å­˜
    // ä½¿ç”¨åˆå¹¶è®¿é—®æ¨¡å¼æé«˜å†…å­˜å¸¦å®½åˆ©ç”¨ç‡
    s_data[localTid] = input[tid];
    __syncthreads();

    // 2. å—å†… FFT è®¡ç®—
    // ä½¿ç”¨ Cooley-Tukey ç®—æ³•çš„å¹¶è¡Œå®ç°
    blockFFT(s_data, s_temp, BLOCK_SIZE);
    __syncthreads();

    // 3. ä¸åŒ¹é…æ»¤æ³¢å™¨é¢‘åŸŸå“åº”ç›¸ä¹˜
    // æ»¤æ³¢å™¨ç³»æ•°å­˜å‚¨åœ¨å¸¸é‡å†…å­˜ä¸­ï¼Œè®¿é—®å»¶è¿Ÿä½
    cuComplex filterCoeff = c_matchedFilter[localTid];
    s_data[localTid] = cuCmul(s_data[localTid], cuConj(filterCoeff));
    __syncthreads();

    // 4. é€† FFT å›åˆ°æ—¶åŸŸ
    blockIFFT(s_data, s_temp, BLOCK_SIZE);
    __syncthreads();

    // 5. å†™å›å…¨å±€å†…å­˜
    output[tid] = s_data[localTid];
}
```

#### æ€§èƒ½å…³é”®ä»£ç æ³¨é‡Š
```cuda
/**
 * @brief é«˜æ€§èƒ½å¤æ•°çŸ©é˜µä¹˜æ³•æ ¸å‡½æ•°
 *
 * ä¼˜åŒ–æŠ€æœ¯ï¼š
 * 1. ä½¿ç”¨å…±äº«å†…å­˜åˆ†å— (Tiling) å‡å°‘å…¨å±€å†…å­˜è®¿é—®
 * 2. å¾ªç¯å±•å¼€ (Loop Unrolling) å‡å°‘åˆ†æ”¯å¼€é”€
 * 3. å¯„å­˜å™¨é‡ç”¨å‡å°‘å†…å­˜è®¿é—®
 * 4. å†…å­˜åˆå¹¶è®¿é—®æé«˜å¸¦å®½åˆ©ç”¨ç‡
 *
 * æ€§èƒ½æŒ‡æ ‡ï¼š
 * - ç†è®ºå³°å€¼ï¼š~80% GPU è®¡ç®—èƒ½åŠ›
 * - å†…å­˜æ•ˆç‡ï¼š~90% å†…å­˜å¸¦å®½
 * - å¯„å­˜å™¨ä½¿ç”¨ï¼š32 ä¸ª/çº¿ç¨‹ï¼ˆæ¥è¿‘ä¸Šé™ï¼‰
 */
__global__ void optimizedComplexMatMul(
    const cuComplex* A,
    const cuComplex* B,
    cuComplex* C,
    int M, int N, int K
) {
    // åˆ†å—å¤§å°ï¼šç»è¿‡æ€§èƒ½è°ƒä¼˜ç¡®å®šçš„æœ€ä¼˜å€¼
    const int TILE_SIZE = 16;

    // å…±äº«å†…å­˜åˆ†å—ï¼šå‡å°‘å…¨å±€å†…å­˜è®¿é—®æ¬¡æ•°
    __shared__ cuComplex s_A[TILE_SIZE][TILE_SIZE];
    __shared__ cuComplex s_B[TILE_SIZE][TILE_SIZE];

    // çº¿ç¨‹å’Œå—ç´¢å¼•è®¡ç®—
    int row = blockIdx.y * TILE_SIZE + threadIdx.y;
    int col = blockIdx.x * TILE_SIZE + threadIdx.x;

    cuComplex sum = make_cuComplex(0.0f, 0.0f);

    // åˆ†å—è®¡ç®—ï¼šæ¯æ¬¡å¤„ç† TILE_SIZE x TILE_SIZE çš„å­çŸ©é˜µ
    for (int tile = 0; tile < (K + TILE_SIZE - 1) / TILE_SIZE; ++tile) {
        // åä½œåŠ è½½ï¼šæ•´ä¸ªå—çš„çº¿ç¨‹ååŒåŠ è½½æ•°æ®åˆ°å…±äº«å†…å­˜
        // è¿™æ ·å¯ä»¥å®ç°å†…å­˜åˆå¹¶è®¿é—®ï¼Œæé«˜å¸¦å®½åˆ©ç”¨ç‡
        int aRow = row;
        int aCol = tile * TILE_SIZE + threadIdx.x;
        int bRow = tile * TILE_SIZE + threadIdx.y;
        int bCol = col;

        // è¾¹ç•Œæ£€æŸ¥å’Œæ•°æ®åŠ è½½
        s_A[threadIdx.y][threadIdx.x] =
            (aRow < M && aCol < K) ? A[aRow * K + aCol] : make_cuComplex(0.0f, 0.0f);
        s_B[threadIdx.y][threadIdx.x] =
            (bRow < K && bCol < N) ? B[bRow * N + bCol] : make_cuComplex(0.0f, 0.0f);

        __syncthreads();

        // è®¡ç®—éƒ¨åˆ†ä¹˜ç§¯ï¼šåˆ©ç”¨å…±äº«å†…å­˜çš„ä½å»¶è¿Ÿç‰¹æ€§
        #pragma unroll  // ç¼–è¯‘å™¨æç¤ºï¼šå±•å¼€å¾ªç¯ä»¥å‡å°‘åˆ†æ”¯å¼€é”€
        for (int k = 0; k < TILE_SIZE; ++k) {
            sum = cuCadd(sum, cuCmul(s_A[threadIdx.y][k], s_B[k][threadIdx.x]));
        }

        __syncthreads();
    }

    // å†™å›ç»“æœï¼šç¡®ä¿è¾¹ç•Œæ£€æŸ¥
    if (row < M && col < N) {
        C[row * N + col] = sum;
    }
}
```

---

## ä¸´æ—¶æ³¨é‡Šç®¡ç†

### ğŸ·ï¸ ä¸´æ—¶æ ‡è®°è§„èŒƒ

#### å¼€å‘é˜¶æ®µæ ‡è®°
```cpp
// DRAFT: åˆæ­¥å®ç°ï¼Œéœ€è¦è¿›ä¸€æ­¥å®Œå–„
class DataProcessor {
    // DRAFT: ç®€åŒ–çš„åˆå§‹åŒ–æµç¨‹ï¼Œç¼ºå°‘é”™è¯¯å¤„ç†
    bool initialize() {
        return allocateMemory();
    }
};

// PROTOTYPE: åŸå‹å®ç°ï¼Œä»…ç”¨äºæ¦‚å¿µéªŒè¯
void experimentalAlgorithm() {
    // PROTOTYPE: åŸºäºè®ºæ–‡çš„åˆæ­¥å®ç°
    // å‚è€ƒï¼šIEEE Signal Processing Magazine, 2024
    // æ€§èƒ½æœªä¼˜åŒ–ï¼Œä»…éªŒè¯ç®—æ³•æ­£ç¡®æ€§
}

// STUB: æ¡©å‡½æ•°ï¼Œç­‰å¾…å…·ä½“å®ç°
bool validateConfiguration(const Config& config) {
    // STUB: ä¸´æ—¶è¿”å› trueï¼Œå®é™…éªŒè¯é€»è¾‘å¾…å®ç°
    return true;
}
```

#### é—®é¢˜è¿½è¸ªæ ‡è®°
```cpp
// BUG: å·²çŸ¥é—®é¢˜ï¼Œç­‰å¾…ä¿®å¤
void processData() {
    // BUG: åœ¨æŸäº›è¾¹ç•Œæ¡ä»¶ä¸‹ä¼šå‘ç”Ÿè¶Šç•Œè®¿é—®
    // é‡ç°æ¡ä»¶ï¼šæ•°æ®å¤§å°ä¸ºå¥‡æ•°ä¸”å¤§äº 10000
    // ä¸´æ—¶è§£å†³ï¼šæ·»åŠ é¢å¤–çš„è¾¹ç•Œæ£€æŸ¥
    if (dataSize % 2 == 1 && dataSize > 10000) {
        // ä¸´æ—¶å¤„ç†é€»è¾‘
    }
}

// HACK: ä¸´æ—¶è§£å†³æ–¹æ¡ˆï¼Œéœ€è¦æ›´å¥½çš„å®ç°
void workaroundMemoryIssue() {
    // HACK: CUDA é©±åŠ¨ç‰ˆæœ¬ xxx çš„å†…å­˜åˆ†é…é—®é¢˜
    // ä¸´æ—¶æ–¹æ¡ˆï¼šåˆ†å¤šæ¬¡å°å—åˆ†é…è€Œä¸æ˜¯ä¸€æ¬¡å¤§å—åˆ†é…
    // æ­£ç¡®æ–¹æ¡ˆï¼šå‡çº§é©±åŠ¨æˆ–ä½¿ç”¨å†…å­˜æ± 
    for (int i = 0; i < largeSize; i += smallChunk) {
        cudaMalloc(&buffers[i], smallChunk);
    }
}
```

#### æ€§èƒ½å’Œä¼˜åŒ–æ ‡è®°
```cpp
// PERF: æ€§èƒ½ä¼˜åŒ–ç‚¹
void computeIntensiveFunction() {
    // PERF: è¿™ä¸ªå¾ªç¯æ˜¯æ€§èƒ½ç“¶é¢ˆï¼ˆå ç”¨ 60% CPU æ—¶é—´ï¼‰
    // ä¼˜åŒ–æ–¹æ¡ˆï¼š
    // 1. å‘é‡åŒ–ï¼ˆSIMDï¼‰
    // 2. å¤šçº¿ç¨‹å¹¶è¡Œ
    // 3. GPU åŠ é€Ÿ
    for (int i = 0; i < largeN; ++i) {
        result[i] = expensiveComputation(data[i]);
    }
}

// OPTIMIZE: å¾…ä¼˜åŒ–çš„ä»£ç 
void suboptimalImplementation() {
    // OPTIMIZE: å½“å‰å®ç° O(NÂ²) å¤æ‚åº¦
    // å¯ä»¥ä¼˜åŒ–ä¸º O(N log N) ä½¿ç”¨å¿«é€Ÿç®—æ³•
    // é¢„æœŸæ€§èƒ½æå‡ï¼š10x å¯¹äºå¤§æ•°æ®é›†
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            // è®¡ç®—é€»è¾‘
        }
    }
}
```

### ğŸ“… ä¸´æ—¶æ³¨é‡Šç”Ÿå‘½å‘¨æœŸ

#### æ³¨é‡Šè·Ÿè¸ªæ¨¡æ¿
```cpp
// TODO(å¼ ä¸‰, 2025-09-15): å®ç°è‡ªé€‚åº”æ»¤æ³¢ç®—æ³•
// ä¼˜å…ˆçº§ï¼šé«˜
// é¢„è®¡å·¥æ—¶ï¼š3å¤©
// ä¾èµ–ï¼šç­‰å¾…æ»¤æ³¢å™¨ç³»æ•°è®¡ç®—å®Œæˆ
// ç›¸å…³ issue: #456
void adaptiveFiltering() {
    // å½“å‰å ä½å®ç°
}

// FIXME(æå››, 2025-09-10): ä¿®å¤å†…å­˜æ³„æ¼
// å‘ç°æ—¶é—´ï¼š2025-09-08
// å½±å“ï¼šé•¿æ—¶é—´è¿è¡Œåå†…å­˜è€—å°½
// ä¿®å¤deadlineï¼š2025-09-20
// ç´§æ€¥ç¨‹åº¦ï¼šé«˜
void leakyFunction() {
    // æœ‰é—®é¢˜çš„å®ç°
}

// REVIEW(å›¢é˜Ÿ, 2025-09-12): ä»£ç å®¡æŸ¥å¾…å®š
// å®¡æŸ¥è¦ç‚¹ï¼šç®—æ³•æ­£ç¡®æ€§ã€æ€§èƒ½è¡¨ç°
// å®¡æŸ¥è€…ï¼šç‹äº”ã€èµµå…­
// é¢„è®¡å®¡æŸ¥æ—¶é—´ï¼š2å°æ—¶
class NewAlgorithm {
    // å¾…å®¡æŸ¥çš„å®ç°
};
```

#### å®šæœŸæ¸…ç†ç­–ç•¥
```markdown
æ¸…ç†å‘¨æœŸï¼š
- æ¯å‘¨ï¼šæ£€æŸ¥ TODO å’Œ FIXME çš„è¿›å±•
- æ¯æœˆï¼šæ¸…ç†å·²å®Œæˆçš„ DRAFT å’Œ PROTOTYPE æ ‡è®°
- æ¯å­£åº¦ï¼šè¯„ä¼°é•¿æœŸ OPTIMIZE æ ‡è®°çš„ä¼˜å…ˆçº§

æ¸…ç†è§„åˆ™ï¼š
1. å·²è§£å†³çš„é—®é¢˜ç«‹å³ç§»é™¤æ ‡è®°
2. è¿‡æœŸçš„ TODO é‡æ–°è¯„ä¼°ä¼˜å…ˆçº§
3. é•¿æœŸæœªå¤„ç†çš„ HACK åˆ¶å®šæ­£å¼è§£å†³æ–¹æ¡ˆ
4. DRAFT ä»£ç è½¬ä¸ºæ­£å¼å®ç°æˆ–ç§»é™¤
```

---

## è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ

### ğŸ”§ Doxygen é…ç½®

#### é¡¹ç›® Doxyfile é…ç½®
```doxyfile
# Doxyfile - é¡¹ç›®æ ¹ç›®å½•

# åŸºæœ¬é…ç½®
PROJECT_NAME           = "Radar MVP System"
PROJECT_VERSION        = "1.0"
PROJECT_BRIEF          = "GPUåŠ é€Ÿçš„ç›¸æ§é˜µé›·è¾¾æ•°æ®å¤„ç†ç³»ç»Ÿ"

# è¾“å…¥é…ç½®
INPUT                  = include/ src/ docs/
FILE_PATTERNS          = *.h *.hpp *.cpp *.cu *.md
RECURSIVE              = YES
EXCLUDE_PATTERNS       = */third_party/* */build/* */temp/*

# è¾“å‡ºé…ç½®
OUTPUT_DIRECTORY       = docs/api/
GENERATE_HTML          = YES
GENERATE_LATEX         = NO
HTML_OUTPUT            = html
HTML_THEME             = modern

# ä»£ç æå–
EXTRACT_ALL            = NO
EXTRACT_PRIVATE        = NO
EXTRACT_STATIC         = YES
EXTRACT_LOCAL_CLASSES  = YES

# å›¾è¡¨ç”Ÿæˆ
HAVE_DOT               = YES
DOT_GRAPH_MAX_NODES    = 100
UML_LOOK               = YES
TEMPLATE_RELATIONS     = YES
INCLUDE_GRAPH          = YES
COLLABORATION_GRAPH    = YES

# æºç æµè§ˆ
SOURCE_BROWSER         = YES
INLINE_SOURCES         = NO
VERBATIM_HEADERS       = YES

# è­¦å‘Šå’Œé”™è¯¯
QUIET                  = NO
WARNINGS               = YES
WARN_IF_UNDOCUMENTED   = YES
WARN_NO_PARAMDOC       = YES
```

#### è‡ªåŠ¨åŒ–æ„å»ºé›†æˆ
```cmake
# CMakeLists.txt - æ–‡æ¡£ç”Ÿæˆç›®æ ‡

find_package(Doxygen REQUIRED)

if(DOXYGEN_FOUND)
    # é…ç½® Doxygen è¾“å…¥æ–‡ä»¶
    set(DOXYGEN_INPUT_DIR ${CMAKE_SOURCE_DIR}/include ${CMAKE_SOURCE_DIR}/src)
    set(DOXYGEN_OUTPUT_DIR ${CMAKE_BINARY_DIR}/docs)

    # ç”Ÿæˆ Doxyfile
    configure_file(
        ${CMAKE_SOURCE_DIR}/docs/Doxyfile.in
        ${CMAKE_BINARY_DIR}/Doxyfile
        @ONLY
    )

    # æ·»åŠ æ–‡æ¡£ç”Ÿæˆç›®æ ‡
    add_custom_target(docs
        COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_BINARY_DIR}/Doxyfile
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Generating API documentation with Doxygen"
        VERBATIM
    )

    # æ¸…ç†æ–‡æ¡£ç›®æ ‡
    add_custom_target(clean-docs
        COMMAND ${CMAKE_COMMAND} -E remove_directory ${DOXYGEN_OUTPUT_DIR}
        COMMENT "Cleaning generated documentation"
    )
endif()
```

### ğŸ“Š æ–‡æ¡£è´¨é‡æ£€æŸ¥

#### æ³¨é‡Šè¦†ç›–ç‡æ£€æŸ¥
```bash
#!/bin/bash
# scripts/check_doc_coverage.sh

echo "æ£€æŸ¥æ–‡æ¡£è¦†ç›–ç‡..."

# ç»Ÿè®¡å…¬å…±æ¥å£æ•°é‡
public_interfaces=$(grep -r "class.*{" include/ | grep -v "private:" | wc -l)
public_methods=$(grep -r "virtual.*=" include/ | wc -l)

# ç»Ÿè®¡æœ‰æ–‡æ¡£çš„æ¥å£æ•°é‡
documented_interfaces=$(grep -r "/\*\*" include/ -A 5 | grep "class" | wc -l)
documented_methods=$(grep -r "/\*\*" include/ -A 5 | grep "virtual.*=" | wc -l)

# è®¡ç®—è¦†ç›–ç‡
interface_coverage=$((documented_interfaces * 100 / public_interfaces))
method_coverage=$((documented_methods * 100 / public_methods))

echo "æ¥å£æ–‡æ¡£è¦†ç›–ç‡: $interface_coverage%"
echo "æ–¹æ³•æ–‡æ¡£è¦†ç›–ç‡: $method_coverage%"

# æ£€æŸ¥è¦†ç›–ç‡è¦æ±‚
if [ $interface_coverage -lt 90 ] || [ $method_coverage -lt 85 ]; then
    echo "è­¦å‘Šï¼šæ–‡æ¡£è¦†ç›–ç‡ä¸è¶³ï¼"
    echo "è¦æ±‚ï¼šæ¥å£è¦†ç›–ç‡ â‰¥ 90%ï¼Œæ–¹æ³•è¦†ç›–ç‡ â‰¥ 85%"
    exit 1
fi

echo "æ–‡æ¡£è¦†ç›–ç‡æ£€æŸ¥é€šè¿‡"
```

#### æ³¨é‡Šè´¨é‡éªŒè¯
```python
#!/usr/bin/env python3
# scripts/validate_comments.py

import re
import sys
from pathlib import Path

def check_doxygen_format(file_path):
    """æ£€æŸ¥ Doxygen æ³¨é‡Šæ ¼å¼çš„æ­£ç¡®æ€§"""
    issues = []

    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # æ£€æŸ¥æ–‡ä»¶å¤´æ³¨é‡Š
    if not re.search(r'/\*\*\s*\n\s*\*\s*@file', content):
        issues.append("ç¼ºå°‘æ–‡ä»¶å¤´æ³¨é‡Š")

    # æ£€æŸ¥ç±»æ³¨é‡Š
    class_matches = re.findall(r'class\s+(\w+)', content)
    for class_name in class_matches:
        if not re.search(rf'/\*\*.*?@brief.*?class\s+{class_name}', content, re.DOTALL):
            issues.append(f"ç±» {class_name} ç¼ºå°‘ @brief æ³¨é‡Š")

    # æ£€æŸ¥å…¬å…±æ–¹æ³•æ³¨é‡Š
    method_matches = re.findall(r'virtual\s+\w+.*?(\w+)\s*\([^)]*\)\s*[=;]', content)
    for method_name in method_matches:
        if not re.search(rf'/\*\*.*?@brief.*?{method_name}', content, re.DOTALL):
            issues.append(f"æ–¹æ³• {method_name} ç¼ºå°‘ @brief æ³¨é‡Š")

    return issues

def main():
    """ä¸»å‡½æ•°ï¼šæ£€æŸ¥æ‰€æœ‰å¤´æ–‡ä»¶çš„æ³¨é‡Šè´¨é‡"""
    include_dir = Path("include")
    total_issues = 0

    for header_file in include_dir.rglob("*.h"):
        issues = check_doxygen_format(header_file)
        if issues:
            print(f"\n{header_file}:")
            for issue in issues:
                print(f"  - {issue}")
            total_issues += len(issues)

    if total_issues > 0:
        print(f"\nå‘ç° {total_issues} ä¸ªæ³¨é‡Šé—®é¢˜")
        sys.exit(1)
    else:
        print("æ‰€æœ‰æ³¨é‡Šæ ¼å¼æ£€æŸ¥é€šè¿‡")

if __name__ == "__main__":
    main()
```

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦           |
| :--- | :--------- | :----- | :----------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºæ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ |
