# 命名约定

- **标题**: AI协作开发命名标准规范
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 基础命名原则

### 📋 核心原则

#### 1. 可读性优先
```cpp
// ❌ 缩写和简写
int calc_fft_res;
void proc_dat();

// ✅ 完整而清晰的命名
int fftCalculationResult;
void processRawData();

// ❌ 过于冗长
void calculateFastFourierTransformResultForRadarSignalProcessing();

// ✅ 简洁而明确
void calculateRadarFFT();
```

#### 2. 一致性原则
```cpp
// ✅ 统一的动词选择
void getData();      // 获取数据
void setConfig();    // 设置配置
void getResult();    // 获取结果
void setParameter(); // 设置参数

// ❌ 混乱的动词使用
void getData();
void obtainResult();
void fetchConfig();
void acquireStatus();
```

#### 3. 业务语义清晰
```cpp
// ✅ 反映业务含义
class RadarDataProcessor;
class PulseCompressionFilter;
enum class ProcessingState;

// ❌ 技术实现导向
class GPUManager;
class MemoryAllocator;
class ThreadPool;
```

### 🎯 命名长度指导

#### 作用域与长度关系
```cpp
// 局部变量：简短明确
void processData() {
    int count = 0;           // 短作用域，简短命名
    auto result = calculate(); // 使用 auto 时需要明确的函数名

    for (size_t i = 0; i < data.size(); ++i) {
        // 循环变量使用传统的 i, j, k
    }
}

// 成员变量：中等长度，带下划线后缀
class DataProcessor {
private:
    int packetCount_;        // 明确的成员变量标识
    bool isInitialized_;     // 状态变量
    std::vector<float> buffer_;  // 数据容器
};

// 全局/命名空间：完整描述
namespace radar::signal_processing {
    const double DefaultSamplingFrequency = 1e9;  // 全局常量
    extern RadarConfiguration GlobalRadarConfig;  // 全局变量
}
```

---

## 文件和目录命名

### 📁 目录结构命名

#### 功能模块目录
```
src/
├── application/           # 应用层代码
├── modules/              # 功能模块
│   ├── data_receiver/    # 数据接收模块（下划线分隔）
│   ├── gpu_processor/    # GPU处理模块
│   ├── display_control/  # 显示控制模块
│   └── protocol_parser/  # 协议解析模块
├── common/               # 公共组件
└── interfaces/           # 接口定义
```

#### 配置和数据目录
```
configs/
├── system_config.yaml    # 系统配置（下划线分隔）
├── deployment/           # 部署配置
├── modules/              # 模块配置
└── testing/              # 测试配置

data/
├── sample/               # 示例数据
├── schemas/              # 数据模式定义
└── templates/            # 数据模板
```

### 📄 文件命名规范

#### 头文件命名
```cpp
// 接口文件：I + 接口名 + .h
IDataReceiver.h           // 数据接收接口
IDataProcessor.h          // 数据处理接口
IDisplayController.h      // 显示控制接口

// 实现类文件：类名 + .h
DataReceiver.h            // 数据接收实现
GPUProcessor.h            // GPU处理器实现
RadarApplication.h        // 雷达应用主类

// 类型定义文件：类型用途 + Types.h
CommonTypes.h             // 通用类型定义
PacketTypes.h             // 数据包类型定义
ErrorCodes.h              // 错误码定义

// 配置和常量文件
Constants.h               // 系统常量
Config.h                  // 配置类定义
```

#### 源文件命名
```cpp
// 对应头文件的实现
DataReceiver.cpp          // DataReceiver.h 的实现
GPUProcessor.cpp          // GPUProcessor.h 的实现

// CUDA 核函数文件
ProcessingKernels.cu      // GPU 处理核函数
FFTKernels.cu             // FFT 相关核函数

// 主程序和测试文件
main.cpp                  // 程序入口
test_DataReceiver.cpp     // 单元测试文件
```

#### 配置文件命名
```yaml
# 系统配置文件：功能_config.yaml
system_config.yaml        # 系统配置
logging_config.yaml       # 日志配置
deployment_config.yaml    # 部署配置

# 模块配置文件：模块名.yaml
data_receiver.yaml         # 数据接收模块配置
gpu_processor.yaml         # GPU处理模块配置
display_control.yaml       # 显示控制模块配置
```

---

## 类和结构体命名

### 🏗️ 类命名规范

#### 接口类命名
```cpp
// 接口类：I + 业务功能名
class IDataReceiver {       // 数据接收接口
public:
    virtual ~IDataReceiver() = default;
    virtual bool initialize() = 0;
    virtual ReceiveStatus receive(DataPacket& packet) = 0;
    virtual void cleanup() = 0;
};

class IDataProcessor {      // 数据处理接口
public:
    virtual ~IDataProcessor() = default;
    virtual ProcessingResult process(const RawData& input) = 0;
    virtual ProcessorState getState() const = 0;
};

class IDisplayController {  // 显示控制接口
public:
    virtual ~IDisplayController() = default;
    virtual void updateDisplay(const ProcessedData& data) = 0;
    virtual DisplayStatus getDisplayStatus() const = 0;
};
```

#### 实现类命名
```cpp
// 具体实现类：明确的实现特征
class EthernetDataReceiver : public IDataReceiver {
    // 以太网数据接收器实现
};

class SerialPortDataReceiver : public IDataReceiver {
    // 串口数据接收器实现
};

class CUDAGPUProcessor : public IDataProcessor {
    // CUDA GPU 数据处理器实现
};

class CPUProcessor : public IDataProcessor {
    // CPU 数据处理器实现
};

class OpenGLDisplayController : public IDisplayController {
    // OpenGL 显示控制器实现
};
```

#### 工具和管理类命名
```cpp
// 管理类：功能 + Manager
class MemoryManager {        // 内存管理器
    void allocateBuffer(size_t size);
    void releaseBuffer(void* buffer);
};

class ConfigurationManager { // 配置管理器
    bool loadConfig(const std::string& filePath);
    void saveConfig(const std::string& filePath);
};

class ThreadManager {        // 线程管理器
    void createWorkerThread();
    void terminateAllThreads();
};

// 工具类：功能 + Utility/Helper
class DataValidationUtility {
    static bool validatePacket(const DataPacket& packet);
    static bool verifyChecksum(const uint8_t* data, size_t length);
};

class MathHelper {
    static double calculateSNR(const std::vector<float>& signal);
    static std::vector<float> applyWindow(const std::vector<float>& data);
};
```

### 📊 结构体和枚举命名

#### 数据结构命名
```cpp
// 数据包和消息结构
struct RadarDataPacket {     // 雷达数据包
    uint64_t timestamp;
    uint32_t sequenceNumber;
    std::vector<std::complex<float>> samples;
    PacketMetadata metadata;
};

struct ProcessingResult {    // 处理结果
    bool success;
    ProcessingStatistics stats;
    std::vector<DetectedTarget> targets;
    ErrorCode errorCode;
};

struct SystemConfiguration { // 系统配置
    double samplingFrequency;
    size_t bufferSize;
    ProcessingMode mode;
    std::string logLevel;
};

// 元数据和描述结构
struct PacketMetadata {      // 数据包元数据
    ChannelInfo channelInfo;
    TimingInfo timingInfo;
    QualityMetrics quality;
};

struct PerformanceMetrics {  // 性能指标
    double processingLatency;
    double throughput;
    size_t memoryUsage;
    double cpuUtilization;
};
```

#### 枚举类命名
```cpp
// 状态枚举：功能 + State/Status
enum class ProcessorState {
    Uninitialized,           // 未初始化
    Initializing,            // 初始化中
    Ready,                   // 就绪
    Processing,              // 处理中
    Error,                   // 错误状态
    Shutdown                 // 关闭状态
};

enum class ReceiveStatus {
    Success,                 // 接收成功
    Timeout,                 // 超时
    BufferFull,              // 缓冲区满
    NetworkError,            // 网络错误
    InvalidPacket            // 无效数据包
};

// 模式和类型枚举
enum class ProcessingMode {
    HighThroughput,          // 高吞吐量模式
    LowLatency,              // 低延迟模式
    PowerSaving,             // 节能模式
    HighPrecision            // 高精度模式
};

enum class DataFormat {
    ComplexFloat32,          // 32位复数浮点
    ComplexInt16,            // 16位复数整数
    RealFloat32,             // 32位实数浮点
    RealInt16                // 16位实数整数
};

// 错误码枚举
enum class ErrorCode {
    None = 0,                // 无错误

    // 初始化错误 (1000-1999)
    InitializationFailed = 1000,
    ConfigurationError = 1001,
    DeviceNotFound = 1002,

    // 运行时错误 (2000-2999)
    ProcessingTimeout = 2000,
    MemoryAllocationFailed = 2001,
    InvalidInputData = 2002,

    // 系统错误 (3000-3999)
    SystemOverload = 3000,
    HardwareFailure = 3001,
    NetworkDisconnected = 3002
};
```

---

## 变量和函数命名

### 🔢 变量命名规范

#### 基本变量命名
```cpp
// 局部变量：camelCase
void processRadarData() {
    int packetCount = 0;           // 数据包计数
    bool isProcessing = false;     // 状态标志
    double samplingRate = 1e9;     // 采样率
    size_t bufferSize = 1024;      // 缓冲区大小

    // 容器变量：复数形式表示集合
    std::vector<DataPacket> packets;     // 数据包集合
    std::map<int, ProcessorState> states; // 状态映射
    std::queue<ProcessingTask> tasks;    // 任务队列
}

// 成员变量：camelCase + 下划线后缀
class DataProcessor {
private:
    // 基本数据成员
    bool isInitialized_;               // 初始化状态
    int processedCount_;               // 已处理计数
    double totalProcessingTime_;       // 总处理时间

    // 容器成员
    std::vector<float> inputBuffer_;   // 输入缓冲区
    std::queue<DataPacket> packetQueue_; // 数据包队列

    // 资源管理成员
    std::unique_ptr<GPUMemory> gpuMemory_;    // GPU内存管理器
    std::shared_ptr<Configuration> config_;   // 共享配置对象

    // 同步对象
    std::mutex bufferMutex_;           // 缓冲区保护锁
    std::condition_variable readyCondition_; // 就绪条件变量
    std::atomic<bool> shouldStop_;     // 原子停止标志
};
```

#### 特殊变量命名
```cpp
// 常量：PascalCase 或 SCREAMING_SNAKE_CASE
class RadarConstants {
public:
    // 编译时常量：SCREAMING_SNAKE_CASE
    static constexpr double SPEED_OF_LIGHT = 2.998e8;  // 光速常量
    static constexpr int MAX_PACKET_SIZE = 8192;       // 最大数据包大小
    static constexpr size_t DEFAULT_BUFFER_SIZE = 1024; // 默认缓冲区大小

    // 运行时常量：PascalCase
    static const std::string DefaultConfigPath;        // 默认配置路径
    static const std::chrono::milliseconds DefaultTimeout; // 默认超时时间
};

// 全局变量：g_ 前缀（尽量避免使用）
namespace globals {
    extern std::shared_ptr<Logger> g_logger;          // 全局日志器
    extern std::atomic<bool> g_shutdownRequested;     // 全局关闭请求
}

// 线程局部变量：tl_ 前缀
thread_local std::unique_ptr<PerformanceProfiler> tl_profiler; // 线程性能分析器
thread_local int tl_errorCount = 0;                           // 线程错误计数
```

#### 指针和引用命名
```cpp
// 智能指针：明确生命周期语义
std::unique_ptr<DataProcessor> processor;        // 独占处理器
std::shared_ptr<Configuration> sharedConfig;     // 共享配置
std::weak_ptr<DisplayController> displayRef;     // 弱引用显示控制器

// 原始指针：明确用途
void processGPUData() {
    float* d_inputData = nullptr;    // d_ 前缀表示设备端（GPU）指针
    float* h_outputData = nullptr;   // h_ 前缀表示主机端（CPU）指针

    const float* readOnlyData = getData(); // const 指针表明只读意图
}

// 引用参数：明确输入/输出语义
void configureProcessor(
    const ProcessorConfig& inputConfig,    // 输入配置（const引用）
    ProcessorState& outputState,           // 输出状态（非const引用）
    std::string& errorMessage             // 错误信息输出
);
```

### 🔧 函数命名规范

#### 基本函数命名
```cpp
// 动作函数：动词开头
class DataProcessor {
public:
    // 初始化和清理
    bool initialize(const Configuration& config);  // 初始化
    void cleanup();                                // 清理资源
    void reset();                                  // 重置状态

    // 数据处理
    ProcessingResult process(const RawData& input); // 处理数据
    void startProcessing();                        // 开始处理
    void stopProcessing();                         // 停止处理
    void pauseProcessing();                        // 暂停处理
    void resumeProcessing();                       // 恢复处理

    // 配置管理
    void setConfiguration(const Configuration& config); // 设置配置
    void updateParameter(const std::string& name, const std::string& value); // 更新参数
    void applySettings();                          // 应用设置

    // 数据访问
    Configuration getConfiguration() const;        // 获取配置
    ProcessorState getCurrentState() const;        // 获取当前状态
    PerformanceMetrics getMetrics() const;         // 获取性能指标
};
```

#### 查询和判断函数
```cpp
class SystemManager {
public:
    // 状态查询：is/has/can 开头
    bool isInitialized() const;        // 是否已初始化
    bool isProcessing() const;         // 是否正在处理
    bool isReady() const;              // 是否就绪

    bool hasData() const;              // 是否有数据
    bool hasError() const;             // 是否有错误
    bool hasPendingTasks() const;      // 是否有待处理任务

    bool canProcess() const;           // 是否可以处理
    bool canAcceptInput() const;       // 是否可以接受输入
    bool canShutdown() const;          // 是否可以关闭

    // 验证和检查：validate/verify/check 开头
    bool validateConfiguration(const Configuration& config); // 验证配置
    bool verifyDataIntegrity(const DataPacket& packet);     // 验证数据完整性
    bool checkSystemHealth();                               // 检查系统健康

    // 查找和搜索：find/search/locate 开头
    std::optional<DataPacket> findPacketById(uint32_t id);  // 根据ID查找数据包
    std::vector<ErrorRecord> searchErrors(const TimeRange& range); // 搜索错误记录
    ProcessorInfo locateProcessor(const std::string& name); // 定位处理器
};
```

#### 工厂和创建函数
```cpp
// 工厂函数：create/make/build 开头
class ProcessorFactory {
public:
    // 创建函数：返回智能指针
    static std::unique_ptr<IDataProcessor> createGPUProcessor(
        const GPUConfig& config);

    static std::shared_ptr<IDataReceiver> createEthernetReceiver(
        const NetworkConfig& config);

    static std::unique_ptr<IDisplayController> createOpenGLController(
        const DisplayConfig& config);

    // 构建函数：复杂对象构建
    static ProcessingPipeline buildStandardPipeline(
        const PipelineConfig& config);

    static SystemConfiguration buildDefaultConfiguration();

    // 制造函数：批量创建
    static std::vector<std::unique_ptr<IDataProcessor>> makeProcessorPool(
        size_t poolSize, const ProcessorConfig& config);
};

// 建造者模式：Builder 后缀
class ConfigurationBuilder {
public:
    ConfigurationBuilder& setSamplingRate(double rate);
    ConfigurationBuilder& setBufferSize(size_t size);
    ConfigurationBuilder& setProcessingMode(ProcessingMode mode);
    ConfigurationBuilder& enableLogging(bool enable);

    Configuration build() const;  // 构建最终对象
};
```

#### 回调和事件处理函数
```cpp
// 回调函数：on 开头 + 事件名
class EventHandler {
public:
    // 数据事件
    virtual void onDataReceived(const DataPacket& packet) = 0;
    virtual void onDataProcessed(const ProcessingResult& result) = 0;
    virtual void onDataLost(uint32_t sequenceNumber) = 0;

    // 状态事件
    virtual void onStateChanged(ProcessorState oldState, ProcessorState newState) = 0;
    virtual void onErrorOccurred(const ErrorInfo& error) = 0;
    virtual void onWarningGenerated(const WarningInfo& warning) = 0;

    // 系统事件
    virtual void onSystemStartup() = 0;
    virtual void onSystemShutdown() = 0;
    virtual void onConfigurationChanged(const Configuration& newConfig) = 0;
};

// 处理函数：handle 开头
class MessageHandler {
public:
    void handleIncomingMessage(const Message& message);
    void handleNetworkError(const NetworkError& error);
    void handleTimeoutEvent(const TimeoutEvent& event);
    void handleUserInput(const UserInput& input);
};
```

---

## 常量和宏命名

### 📏 常量命名规范

#### 编译时常量
```cpp
// 全局常量：SCREAMING_SNAKE_CASE
namespace radar {
    // 物理常量
    constexpr double SPEED_OF_LIGHT = 2.99792458e8;      // 光速 (m/s)
    constexpr double PLANCK_CONSTANT = 6.62607015e-34;   // 普朗克常量

    // 系统限制
    constexpr size_t MAX_BUFFER_SIZE = 1024 * 1024;      // 最大缓冲区大小
    constexpr int MAX_CONCURRENT_THREADS = 16;           // 最大并发线程数
    constexpr uint32_t MAX_PACKET_SEQUENCE = 0xFFFFFFFF; // 最大包序列号

    // 默认值
    constexpr double DEFAULT_SAMPLING_RATE = 1e9;        // 默认采样率
    constexpr size_t DEFAULT_FFT_SIZE = 1024;            // 默认FFT大小
    constexpr int DEFAULT_THREAD_COUNT = 4;              // 默认线程数

    // 超时和延迟
    constexpr std::chrono::milliseconds DEFAULT_TIMEOUT{1000};     // 默认超时
    constexpr std::chrono::microseconds MAX_PROCESSING_DELAY{100}; // 最大处理延迟
}
```

#### 类作用域常量
```cpp
class DataProcessor {
public:
    // 公共常量：可被外部访问
    static constexpr int VERSION_MAJOR = 1;              // 主版本号
    static constexpr int VERSION_MINOR = 0;              // 次版本号
    static constexpr size_t MINIMUM_BUFFER_SIZE = 512;   // 最小缓冲区大小

private:
    // 私有常量：内部实现细节
    static constexpr int INTERNAL_QUEUE_SIZE = 100;      // 内部队列大小
    static constexpr double PI = 3.14159265358979323846; // 圆周率
    static constexpr float EPSILON = 1e-6f;              // 浮点比较精度
};

// 枚举常量：明确的业务语义
enum class ProcessingPriority : int {
    Low = 1,
    Normal = 5,
    High = 10,
    Critical = 20
};

enum class MemoryAlignment : size_t {
    Byte = 1,
    Word = 4,
    DoubleWord = 8,
    CacheLine = 64,
    Page = 4096
};
```

#### 运行时常量
```cpp
// 全局运行时常量
namespace config {
    // 配置文件路径
    const std::string CONFIG_FILE_PATH = "configs/system_config.yaml";
    const std::string LOG_FILE_PATH = "logs/system.log";
    const std::string DATA_DIRECTORY = "data/";

    // 系统信息（运行时确定）
    const size_t SYSTEM_PAGE_SIZE = getSystemPageSize();
    const int CPU_CORE_COUNT = std::thread::hardware_concurrency();
    const std::string SYSTEM_HOSTNAME = getHostname();
}

// 类内运行时常量
class SystemInfo {
public:
    // 静态初始化的运行时常量
    static const std::chrono::system_clock::time_point StartupTime;
    static const std::string ApplicationVersion;
    static const std::string BuildTimestamp;

private:
    static const size_t AvailableMemory;     // 可用内存大小
    static const std::string ConfigDirectory; // 配置目录路径
};
```

### 🎛️ 宏定义规范

#### 条件编译宏
```cpp
// 特性开关：ENABLE_ 前缀
#define ENABLE_GPU_PROCESSING 1       // 启用GPU处理
#define ENABLE_PERFORMANCE_PROFILING 0 // 启用性能分析
#define ENABLE_DEBUG_LOGGING 1        // 启用调试日志

// 平台检测：检查预定义宏
#ifdef _WIN32
    #define PLATFORM_WINDOWS 1
#elif defined(__linux__)
    #define PLATFORM_LINUX 1
#elif defined(__APPLE__)
    #define PLATFORM_MACOS 1
#endif

// 编译器特性检测
#if defined(__CUDA_ARCH__)
    #define CUDA_DEVICE_CODE 1
#endif

#if __cplusplus >= 201703L
    #define HAS_CPP17_FEATURES 1
#endif
```

#### 功能宏定义
```cpp
// 调试和日志宏
#ifdef ENABLE_DEBUG_LOGGING
    #define DEBUG_LOG(msg) \
        do { \
            std::cout << "[DEBUG] " << __FILE__ << ":" << __LINE__ \
                      << " " << msg << std::endl; \
        } while(0)
#else
    #define DEBUG_LOG(msg) do {} while(0)  // 释放版本中为空
#endif

// 错误处理宏
#define CHECK_CUDA_ERROR(call) \
    do { \
        cudaError_t error = call; \
        if (error != cudaSuccess) { \
            std::cerr << "CUDA error at " << __FILE__ << ":" << __LINE__ \
                      << " - " << cudaGetErrorString(error) << std::endl; \
            std::abort(); \
        } \
    } while(0)

// 性能测量宏
#ifdef ENABLE_PERFORMANCE_PROFILING
    #define PROFILE_SCOPE(name) \
        PerformanceTimer timer(name)

    #define PROFILE_FUNCTION() \
        PROFILE_SCOPE(__FUNCTION__)
#else
    #define PROFILE_SCOPE(name) do {} while(0)
    #define PROFILE_FUNCTION() do {} while(0)
#endif

// 内存对齐宏
#define ALIGN_SIZE(size, alignment) \
    (((size) + (alignment) - 1) & ~((alignment) - 1))

#define CACHE_ALIGNED __attribute__((aligned(64)))  // 缓存行对齐
#define GPU_ALIGNED __attribute__((aligned(256)))   // GPU内存对齐
```

#### 工具宏定义
```cpp
// 数组大小宏
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

// 安全删除宏
#define SAFE_DELETE(ptr) \
    do { \
        delete (ptr); \
        (ptr) = nullptr; \
    } while(0)

#define SAFE_DELETE_ARRAY(ptr) \
    do { \
        delete[] (ptr); \
        (ptr) = nullptr; \
    } while(0)

// 范围检查宏
#define IN_RANGE(value, min, max) \
    ((value) >= (min) && (value) <= (max))

// 位操作宏
#define SET_BIT(value, bit)    ((value) |= (1U << (bit)))
#define CLEAR_BIT(value, bit)  ((value) &= ~(1U << (bit)))
#define TEST_BIT(value, bit)   (((value) & (1U << (bit))) != 0)

// 字节序转换宏（小端到大端）
#define SWAP_BYTES_16(x) \
    ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))

#define SWAP_BYTES_32(x) \
    ((((x) & 0xFF000000) >> 24) | (((x) & 0x00FF0000) >> 8) | \
     (((x) & 0x0000FF00) << 8)  | (((x) & 0x000000FF) << 24))
```

---

## CUDA 特定命名

### 🚀 CUDA 函数命名

#### Kernel 函数命名
```cuda
// 核函数：功能描述 + Kernel 后缀
__global__ void fftProcessingKernel(
    const cuComplex* input,
    cuComplex* output,
    int N
);

__global__ void pulseCompressionKernel(
    const float* inputData,
    const float* filterCoeffs,
    float* compressedOutput,
    int dataLength,
    int filterLength
);

__global__ void dopplerProcessingKernel(
    const cuComplex* rangeTimeMatrix,
    cuComplex* dopplerMatrix,
    int numRangeBins,
    int numPulses
);

__global__ void cfarDetectionKernel(
    const float* powerSpectrum,
    float* detectionResults,
    float thresholdFactor,
    int windowSize,
    int numCells
);

// 简单计算核函数：计算类型 + Kernel
__global__ void complexMultiplyKernel(
    const cuComplex* a,
    const cuComplex* b,
    cuComplex* result,
    int N
);

__global__ void magnitudeSquaredKernel(
    const cuComplex* input,
    float* output,
    int N
);
```

#### Device 函数命名
```cuda
// 设备函数：__device__ 前缀，功能描述
__device__ float computeWindowFunction(int index, int windowSize, WindowType type);

__device__ cuComplex complexExponential(float angle);

__device__ void warpReduceSum(volatile float* sharedData, int tid);

__device__ float fastAtan2(float y, float x);

// 内联设备函数：性能关键的小函数
__device__ __forceinline__ float fastSqrt(float x) {
    return __fsqrt_rn(x);  // 最近偶数舍入的快速平方根
}

__device__ __forceinline__ cuComplex cuCmplxConj(cuComplex z) {
    return make_cuComplex(cuCrealf(z), -cuCimagf(z));
}
```

#### Host 函数命名
```cpp
// CUDA 主机端包装函数：launch 前缀
void launchFFTProcessing(
    const cuComplex* d_input,
    cuComplex* d_output,
    int N,
    cudaStream_t stream = 0
);

void launchPulseCompression(
    const float* d_inputData,
    const float* d_filterCoeffs,
    float* d_output,
    int dataLength,
    int filterLength,
    cudaStream_t stream = 0
);

// CUDA 内存管理函数：GPU 前缀
class GPUMemoryManager {
public:
    cudaError_t allocateGPUBuffer(void** ptr, size_t size);
    cudaError_t freeGPUBuffer(void* ptr);
    cudaError_t copyHostToGPU(void* dst, const void* src, size_t size);
    cudaError_t copyGPUToHost(void* dst, const void* src, size_t size);
    cudaError_t copyGPUToGPU(void* dst, const void* src, size_t size);
};
```

### 💾 CUDA 变量命名

#### 设备端变量
```cuda
// 设备端指针：d_ 前缀
float* d_inputBuffer;        // 设备端输入缓冲区
cuComplex* d_fftResult;      // 设备端FFT结果
float* d_powerSpectrum;      // 设备端功率谱

// 设备端数组
__device__ float d_coefficients[MAX_FILTER_LENGTH];  // 设备端系数数组
__device__ cuComplex d_twiddleFactors[MAX_FFT_SIZE]; // 设备端旋转因子

// 常量内存：c_ 前缀
__constant__ float c_windowFunction[MAX_WINDOW_SIZE]; // 常量内存窗函数
__constant__ ProcessingParams c_processingParams;    // 常量内存处理参数
__constant__ float c_filterBank[FILTER_BANK_SIZE];   // 常量内存滤波器组
```

#### 主机端变量
```cpp
// 主机端指针：h_ 前缀
float* h_inputData;          // 主机端输入数据
cuComplex* h_outputResult;   // 主机端输出结果
float* h_referenceData;      // 主机端参考数据

// 固定内存：pinned_ 前缀
float* pinned_inputBuffer;   // 页锁定输入缓冲区
float* pinned_outputBuffer;  // 页锁定输出缓冲区

// CUDA 流和事件
cudaStream_t computeStream;  // 计算流
cudaStream_t copyStream;     // 拷贝流
cudaEvent_t startEvent;      // 开始事件
cudaEvent_t stopEvent;       // 结束事件
```

#### 共享内存和纹理
```cuda
// 核函数内共享内存：s_ 前缀
__global__ void advancedProcessingKernel(...) {
    __shared__ float s_inputData[BLOCK_SIZE];      // 共享内存输入数据
    __shared__ cuComplex s_fftTemp[FFT_SIZE];      // 共享内存FFT临时存储
    __shared__ float s_reductionBuffer[WARP_SIZE]; // 共享内存归约缓冲区

    // 本地变量保持 camelCase
    int threadId = threadIdx.x;
    int blockId = blockIdx.x;
    float localSum = 0.0f;
}

// 纹理内存：tex_ 前缀
texture<float, 2, cudaReadModeElementType> tex_inputTexture;
texture<cuComplex, 1, cudaReadModeElementType> tex_filterTexture;

// 表面内存：surf_ 前缀
surface<void, 2> surf_outputSurface;
surface<float, 1> surf_resultSurface;
```

### ⚙️ CUDA 配置命名

#### 核函数启动配置
```cpp
// 网格和块配置：明确的语义命名
struct KernelLaunchConfig {
    dim3 gridDimensions;     // 网格维度
    dim3 blockDimensions;    // 块维度
    size_t sharedMemorySize; // 共享内存大小
    cudaStream_t stream;     // 执行流
};

// 计算网格配置函数
KernelLaunchConfig calculateFFTLaunchConfig(int N);
KernelLaunchConfig calculateMatrixLaunchConfig(int rows, int cols);

// 启动配置常量
namespace cuda_config {
    constexpr int WARP_SIZE = 32;
    constexpr int MAX_THREADS_PER_BLOCK = 1024;
    constexpr int MAX_BLOCKS_PER_GRID = 65535;

    // 常用配置
    constexpr dim3 DEFAULT_BLOCK_SIZE(256);
    constexpr dim3 MATRIX_BLOCK_SIZE(16, 16);
    constexpr dim3 FFT_BLOCK_SIZE(512);
}

// 性能调优参数
struct PerformanceTuningParams {
    int optimalBlockSize;        // 最优块大小
    int optimalGridSize;         // 最优网格大小
    size_t maxSharedMemoryUsage; // 最大共享内存使用
    int maxRegistersPerThread;   // 每线程最大寄存器数
};
```

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要                   |
| :--- | :--------- | :----- | :------------------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建AI协作开发命名标准规范 |
