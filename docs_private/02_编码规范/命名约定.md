# å‘½åçº¦å®š

- **æ ‡é¢˜**: AIåä½œå¼€å‘å‘½åæ ‡å‡†è§„èŒƒ
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## åŸºç¡€å‘½ååŸåˆ™

### ğŸ“‹ æ ¸å¿ƒåŸåˆ™

#### 1. å¯è¯»æ€§ä¼˜å…ˆ
```cpp
// âŒ ç¼©å†™å’Œç®€å†™
int calc_fft_res;
void proc_dat();

// âœ… å®Œæ•´è€Œæ¸…æ™°çš„å‘½å
int fftCalculationResult;
void processRawData();

// âŒ è¿‡äºå†—é•¿
void calculateFastFourierTransformResultForRadarSignalProcessing();

// âœ… ç®€æ´è€Œæ˜ç¡®
void calculateRadarFFT();
```

#### 2. ä¸€è‡´æ€§åŸåˆ™
```cpp
// âœ… ç»Ÿä¸€çš„åŠ¨è¯é€‰æ‹©
void getData();      // è·å–æ•°æ®
void setConfig();    // è®¾ç½®é…ç½®
void getResult();    // è·å–ç»“æœ
void setParameter(); // è®¾ç½®å‚æ•°

// âŒ æ··ä¹±çš„åŠ¨è¯ä½¿ç”¨
void getData();
void obtainResult();
void fetchConfig();
void acquireStatus();
```

#### 3. ä¸šåŠ¡è¯­ä¹‰æ¸…æ™°
```cpp
// âœ… åæ˜ ä¸šåŠ¡å«ä¹‰
class RadarDataProcessor;
class PulseCompressionFilter;
enum class ProcessingState;

// âŒ æŠ€æœ¯å®ç°å¯¼å‘
class GPUManager;
class MemoryAllocator;
class ThreadPool;
```

### ğŸ¯ å‘½åé•¿åº¦æŒ‡å¯¼

#### ä½œç”¨åŸŸä¸é•¿åº¦å…³ç³»
```cpp
// å±€éƒ¨å˜é‡ï¼šç®€çŸ­æ˜ç¡®
void processData() {
    int count = 0;           // çŸ­ä½œç”¨åŸŸï¼Œç®€çŸ­å‘½å
    auto result = calculate(); // ä½¿ç”¨ auto æ—¶éœ€è¦æ˜ç¡®çš„å‡½æ•°å

    for (size_t i = 0; i < data.size(); ++i) {
        // å¾ªç¯å˜é‡ä½¿ç”¨ä¼ ç»Ÿçš„ i, j, k
    }
}

// æˆå‘˜å˜é‡ï¼šä¸­ç­‰é•¿åº¦ï¼Œå¸¦ä¸‹åˆ’çº¿åç¼€
class DataProcessor {
private:
    int packetCount_;        // æ˜ç¡®çš„æˆå‘˜å˜é‡æ ‡è¯†
    bool isInitialized_;     // çŠ¶æ€å˜é‡
    std::vector<float> buffer_;  // æ•°æ®å®¹å™¨
};

// å…¨å±€/å‘½åç©ºé—´ï¼šå®Œæ•´æè¿°
namespace radar::signal_processing {
    const double DefaultSamplingFrequency = 1e9;  // å…¨å±€å¸¸é‡
    extern RadarConfiguration GlobalRadarConfig;  // å…¨å±€å˜é‡
}
```

---

## æ–‡ä»¶å’Œç›®å½•å‘½å

### ğŸ“ ç›®å½•ç»“æ„å‘½å

#### åŠŸèƒ½æ¨¡å—ç›®å½•
```
src/
â”œâ”€â”€ application/           # åº”ç”¨å±‚ä»£ç 
â”œâ”€â”€ modules/              # åŠŸèƒ½æ¨¡å—
â”‚   â”œâ”€â”€ data_receiver/    # æ•°æ®æ¥æ”¶æ¨¡å—ï¼ˆä¸‹åˆ’çº¿åˆ†éš”ï¼‰
â”‚   â”œâ”€â”€ gpu_processor/    # GPUå¤„ç†æ¨¡å—
â”‚   â”œâ”€â”€ display_control/  # æ˜¾ç¤ºæ§åˆ¶æ¨¡å—
â”‚   â””â”€â”€ protocol_parser/  # åè®®è§£ææ¨¡å—
â”œâ”€â”€ common/               # å…¬å…±ç»„ä»¶
â””â”€â”€ interfaces/           # æ¥å£å®šä¹‰
```

#### é…ç½®å’Œæ•°æ®ç›®å½•
```
configs/
â”œâ”€â”€ system_config.yaml    # ç³»ç»Ÿé…ç½®ï¼ˆä¸‹åˆ’çº¿åˆ†éš”ï¼‰
â”œâ”€â”€ deployment/           # éƒ¨ç½²é…ç½®
â”œâ”€â”€ modules/              # æ¨¡å—é…ç½®
â””â”€â”€ testing/              # æµ‹è¯•é…ç½®

data/
â”œâ”€â”€ sample/               # ç¤ºä¾‹æ•°æ®
â”œâ”€â”€ schemas/              # æ•°æ®æ¨¡å¼å®šä¹‰
â””â”€â”€ templates/            # æ•°æ®æ¨¡æ¿
```

### ğŸ“„ æ–‡ä»¶å‘½åè§„èŒƒ

#### å¤´æ–‡ä»¶å‘½å
```cpp
// æ¥å£æ–‡ä»¶ï¼šI + æ¥å£å + .h
IDataReceiver.h           // æ•°æ®æ¥æ”¶æ¥å£
IDataProcessor.h          // æ•°æ®å¤„ç†æ¥å£
IDisplayController.h      // æ˜¾ç¤ºæ§åˆ¶æ¥å£

// å®ç°ç±»æ–‡ä»¶ï¼šç±»å + .h
DataReceiver.h            // æ•°æ®æ¥æ”¶å®ç°
GPUProcessor.h            // GPUå¤„ç†å™¨å®ç°
RadarApplication.h        // é›·è¾¾åº”ç”¨ä¸»ç±»

// ç±»å‹å®šä¹‰æ–‡ä»¶ï¼šç±»å‹ç”¨é€” + Types.h
CommonTypes.h             // é€šç”¨ç±»å‹å®šä¹‰
PacketTypes.h             // æ•°æ®åŒ…ç±»å‹å®šä¹‰
ErrorCodes.h              // é”™è¯¯ç å®šä¹‰

// é…ç½®å’Œå¸¸é‡æ–‡ä»¶
Constants.h               // ç³»ç»Ÿå¸¸é‡
Config.h                  // é…ç½®ç±»å®šä¹‰
```

#### æºæ–‡ä»¶å‘½å
```cpp
// å¯¹åº”å¤´æ–‡ä»¶çš„å®ç°
DataReceiver.cpp          // DataReceiver.h çš„å®ç°
GPUProcessor.cpp          // GPUProcessor.h çš„å®ç°

// CUDA æ ¸å‡½æ•°æ–‡ä»¶
ProcessingKernels.cu      // GPU å¤„ç†æ ¸å‡½æ•°
FFTKernels.cu             // FFT ç›¸å…³æ ¸å‡½æ•°

// ä¸»ç¨‹åºå’Œæµ‹è¯•æ–‡ä»¶
main.cpp                  // ç¨‹åºå…¥å£
test_DataReceiver.cpp     // å•å…ƒæµ‹è¯•æ–‡ä»¶
```

#### é…ç½®æ–‡ä»¶å‘½å
```yaml
# ç³»ç»Ÿé…ç½®æ–‡ä»¶ï¼šåŠŸèƒ½_config.yaml
system_config.yaml        # ç³»ç»Ÿé…ç½®
logging_config.yaml       # æ—¥å¿—é…ç½®
deployment_config.yaml    # éƒ¨ç½²é…ç½®

# æ¨¡å—é…ç½®æ–‡ä»¶ï¼šæ¨¡å—å.yaml
data_receiver.yaml         # æ•°æ®æ¥æ”¶æ¨¡å—é…ç½®
gpu_processor.yaml         # GPUå¤„ç†æ¨¡å—é…ç½®
display_control.yaml       # æ˜¾ç¤ºæ§åˆ¶æ¨¡å—é…ç½®
```

---

## ç±»å’Œç»“æ„ä½“å‘½å

### ğŸ—ï¸ ç±»å‘½åè§„èŒƒ

#### æ¥å£ç±»å‘½å
```cpp
// æ¥å£ç±»ï¼šI + ä¸šåŠ¡åŠŸèƒ½å
class IDataReceiver {       // æ•°æ®æ¥æ”¶æ¥å£
public:
    virtual ~IDataReceiver() = default;
    virtual bool initialize() = 0;
    virtual ReceiveStatus receive(DataPacket& packet) = 0;
    virtual void cleanup() = 0;
};

class IDataProcessor {      // æ•°æ®å¤„ç†æ¥å£
public:
    virtual ~IDataProcessor() = default;
    virtual ProcessingResult process(const RawData& input) = 0;
    virtual ProcessorState getState() const = 0;
};

class IDisplayController {  // æ˜¾ç¤ºæ§åˆ¶æ¥å£
public:
    virtual ~IDisplayController() = default;
    virtual void updateDisplay(const ProcessedData& data) = 0;
    virtual DisplayStatus getDisplayStatus() const = 0;
};
```

#### å®ç°ç±»å‘½å
```cpp
// å…·ä½“å®ç°ç±»ï¼šæ˜ç¡®çš„å®ç°ç‰¹å¾
class EthernetDataReceiver : public IDataReceiver {
    // ä»¥å¤ªç½‘æ•°æ®æ¥æ”¶å™¨å®ç°
};

class SerialPortDataReceiver : public IDataReceiver {
    // ä¸²å£æ•°æ®æ¥æ”¶å™¨å®ç°
};

class CUDAGPUProcessor : public IDataProcessor {
    // CUDA GPU æ•°æ®å¤„ç†å™¨å®ç°
};

class CPUProcessor : public IDataProcessor {
    // CPU æ•°æ®å¤„ç†å™¨å®ç°
};

class OpenGLDisplayController : public IDisplayController {
    // OpenGL æ˜¾ç¤ºæ§åˆ¶å™¨å®ç°
};
```

#### å·¥å…·å’Œç®¡ç†ç±»å‘½å
```cpp
// ç®¡ç†ç±»ï¼šåŠŸèƒ½ + Manager
class MemoryManager {        // å†…å­˜ç®¡ç†å™¨
    void allocateBuffer(size_t size);
    void releaseBuffer(void* buffer);
};

class ConfigurationManager { // é…ç½®ç®¡ç†å™¨
    bool loadConfig(const std::string& filePath);
    void saveConfig(const std::string& filePath);
};

class ThreadManager {        // çº¿ç¨‹ç®¡ç†å™¨
    void createWorkerThread();
    void terminateAllThreads();
};

// å·¥å…·ç±»ï¼šåŠŸèƒ½ + Utility/Helper
class DataValidationUtility {
    static bool validatePacket(const DataPacket& packet);
    static bool verifyChecksum(const uint8_t* data, size_t length);
};

class MathHelper {
    static double calculateSNR(const std::vector<float>& signal);
    static std::vector<float> applyWindow(const std::vector<float>& data);
};
```

### ğŸ“Š ç»“æ„ä½“å’Œæšä¸¾å‘½å

#### æ•°æ®ç»“æ„å‘½å
```cpp
// æ•°æ®åŒ…å’Œæ¶ˆæ¯ç»“æ„
struct RadarDataPacket {     // é›·è¾¾æ•°æ®åŒ…
    uint64_t timestamp;
    uint32_t sequenceNumber;
    std::vector<std::complex<float>> samples;
    PacketMetadata metadata;
};

struct ProcessingResult {    // å¤„ç†ç»“æœ
    bool success;
    ProcessingStatistics stats;
    std::vector<DetectedTarget> targets;
    ErrorCode errorCode;
};

struct SystemConfiguration { // ç³»ç»Ÿé…ç½®
    double samplingFrequency;
    size_t bufferSize;
    ProcessingMode mode;
    std::string logLevel;
};

// å…ƒæ•°æ®å’Œæè¿°ç»“æ„
struct PacketMetadata {      // æ•°æ®åŒ…å…ƒæ•°æ®
    ChannelInfo channelInfo;
    TimingInfo timingInfo;
    QualityMetrics quality;
};

struct PerformanceMetrics {  // æ€§èƒ½æŒ‡æ ‡
    double processingLatency;
    double throughput;
    size_t memoryUsage;
    double cpuUtilization;
};
```

#### æšä¸¾ç±»å‘½å
```cpp
// çŠ¶æ€æšä¸¾ï¼šåŠŸèƒ½ + State/Status
enum class ProcessorState {
    Uninitialized,           // æœªåˆå§‹åŒ–
    Initializing,            // åˆå§‹åŒ–ä¸­
    Ready,                   // å°±ç»ª
    Processing,              // å¤„ç†ä¸­
    Error,                   // é”™è¯¯çŠ¶æ€
    Shutdown                 // å…³é—­çŠ¶æ€
};

enum class ReceiveStatus {
    Success,                 // æ¥æ”¶æˆåŠŸ
    Timeout,                 // è¶…æ—¶
    BufferFull,              // ç¼“å†²åŒºæ»¡
    NetworkError,            // ç½‘ç»œé”™è¯¯
    InvalidPacket            // æ— æ•ˆæ•°æ®åŒ…
};

// æ¨¡å¼å’Œç±»å‹æšä¸¾
enum class ProcessingMode {
    HighThroughput,          // é«˜ååé‡æ¨¡å¼
    LowLatency,              // ä½å»¶è¿Ÿæ¨¡å¼
    PowerSaving,             // èŠ‚èƒ½æ¨¡å¼
    HighPrecision            // é«˜ç²¾åº¦æ¨¡å¼
};

enum class DataFormat {
    ComplexFloat32,          // 32ä½å¤æ•°æµ®ç‚¹
    ComplexInt16,            // 16ä½å¤æ•°æ•´æ•°
    RealFloat32,             // 32ä½å®æ•°æµ®ç‚¹
    RealInt16                // 16ä½å®æ•°æ•´æ•°
};

// é”™è¯¯ç æšä¸¾
enum class ErrorCode {
    None = 0,                // æ— é”™è¯¯

    // åˆå§‹åŒ–é”™è¯¯ (1000-1999)
    InitializationFailed = 1000,
    ConfigurationError = 1001,
    DeviceNotFound = 1002,

    // è¿è¡Œæ—¶é”™è¯¯ (2000-2999)
    ProcessingTimeout = 2000,
    MemoryAllocationFailed = 2001,
    InvalidInputData = 2002,

    // ç³»ç»Ÿé”™è¯¯ (3000-3999)
    SystemOverload = 3000,
    HardwareFailure = 3001,
    NetworkDisconnected = 3002
};
```

---

## å˜é‡å’Œå‡½æ•°å‘½å

### ğŸ”¢ å˜é‡å‘½åè§„èŒƒ

#### åŸºæœ¬å˜é‡å‘½å
```cpp
// å±€éƒ¨å˜é‡ï¼šcamelCase
void processRadarData() {
    int packetCount = 0;           // æ•°æ®åŒ…è®¡æ•°
    bool isProcessing = false;     // çŠ¶æ€æ ‡å¿—
    double samplingRate = 1e9;     // é‡‡æ ·ç‡
    size_t bufferSize = 1024;      // ç¼“å†²åŒºå¤§å°

    // å®¹å™¨å˜é‡ï¼šå¤æ•°å½¢å¼è¡¨ç¤ºé›†åˆ
    std::vector<DataPacket> packets;     // æ•°æ®åŒ…é›†åˆ
    std::map<int, ProcessorState> states; // çŠ¶æ€æ˜ å°„
    std::queue<ProcessingTask> tasks;    // ä»»åŠ¡é˜Ÿåˆ—
}

// æˆå‘˜å˜é‡ï¼šcamelCase + ä¸‹åˆ’çº¿åç¼€
class DataProcessor {
private:
    // åŸºæœ¬æ•°æ®æˆå‘˜
    bool isInitialized_;               // åˆå§‹åŒ–çŠ¶æ€
    int processedCount_;               // å·²å¤„ç†è®¡æ•°
    double totalProcessingTime_;       // æ€»å¤„ç†æ—¶é—´

    // å®¹å™¨æˆå‘˜
    std::vector<float> inputBuffer_;   // è¾“å…¥ç¼“å†²åŒº
    std::queue<DataPacket> packetQueue_; // æ•°æ®åŒ…é˜Ÿåˆ—

    // èµ„æºç®¡ç†æˆå‘˜
    std::unique_ptr<GPUMemory> gpuMemory_;    // GPUå†…å­˜ç®¡ç†å™¨
    std::shared_ptr<Configuration> config_;   // å…±äº«é…ç½®å¯¹è±¡

    // åŒæ­¥å¯¹è±¡
    std::mutex bufferMutex_;           // ç¼“å†²åŒºä¿æŠ¤é”
    std::condition_variable readyCondition_; // å°±ç»ªæ¡ä»¶å˜é‡
    std::atomic<bool> shouldStop_;     // åŸå­åœæ­¢æ ‡å¿—
};
```

#### ç‰¹æ®Šå˜é‡å‘½å
```cpp
// å¸¸é‡ï¼šPascalCase æˆ– SCREAMING_SNAKE_CASE
class RadarConstants {
public:
    // ç¼–è¯‘æ—¶å¸¸é‡ï¼šSCREAMING_SNAKE_CASE
    static constexpr double SPEED_OF_LIGHT = 2.998e8;  // å…‰é€Ÿå¸¸é‡
    static constexpr int MAX_PACKET_SIZE = 8192;       // æœ€å¤§æ•°æ®åŒ…å¤§å°
    static constexpr size_t DEFAULT_BUFFER_SIZE = 1024; // é»˜è®¤ç¼“å†²åŒºå¤§å°

    // è¿è¡Œæ—¶å¸¸é‡ï¼šPascalCase
    static const std::string DefaultConfigPath;        // é»˜è®¤é…ç½®è·¯å¾„
    static const std::chrono::milliseconds DefaultTimeout; // é»˜è®¤è¶…æ—¶æ—¶é—´
};

// å…¨å±€å˜é‡ï¼šg_ å‰ç¼€ï¼ˆå°½é‡é¿å…ä½¿ç”¨ï¼‰
namespace globals {
    extern std::shared_ptr<Logger> g_logger;          // å…¨å±€æ—¥å¿—å™¨
    extern std::atomic<bool> g_shutdownRequested;     // å…¨å±€å…³é—­è¯·æ±‚
}

// çº¿ç¨‹å±€éƒ¨å˜é‡ï¼štl_ å‰ç¼€
thread_local std::unique_ptr<PerformanceProfiler> tl_profiler; // çº¿ç¨‹æ€§èƒ½åˆ†æå™¨
thread_local int tl_errorCount = 0;                           // çº¿ç¨‹é”™è¯¯è®¡æ•°
```

#### æŒ‡é’ˆå’Œå¼•ç”¨å‘½å
```cpp
// æ™ºèƒ½æŒ‡é’ˆï¼šæ˜ç¡®ç”Ÿå‘½å‘¨æœŸè¯­ä¹‰
std::unique_ptr<DataProcessor> processor;        // ç‹¬å å¤„ç†å™¨
std::shared_ptr<Configuration> sharedConfig;     // å…±äº«é…ç½®
std::weak_ptr<DisplayController> displayRef;     // å¼±å¼•ç”¨æ˜¾ç¤ºæ§åˆ¶å™¨

// åŸå§‹æŒ‡é’ˆï¼šæ˜ç¡®ç”¨é€”
void processGPUData() {
    float* d_inputData = nullptr;    // d_ å‰ç¼€è¡¨ç¤ºè®¾å¤‡ç«¯ï¼ˆGPUï¼‰æŒ‡é’ˆ
    float* h_outputData = nullptr;   // h_ å‰ç¼€è¡¨ç¤ºä¸»æœºç«¯ï¼ˆCPUï¼‰æŒ‡é’ˆ

    const float* readOnlyData = getData(); // const æŒ‡é’ˆè¡¨æ˜åªè¯»æ„å›¾
}

// å¼•ç”¨å‚æ•°ï¼šæ˜ç¡®è¾“å…¥/è¾“å‡ºè¯­ä¹‰
void configureProcessor(
    const ProcessorConfig& inputConfig,    // è¾“å…¥é…ç½®ï¼ˆconstå¼•ç”¨ï¼‰
    ProcessorState& outputState,           // è¾“å‡ºçŠ¶æ€ï¼ˆéconstå¼•ç”¨ï¼‰
    std::string& errorMessage             // é”™è¯¯ä¿¡æ¯è¾“å‡º
);
```

### ğŸ”§ å‡½æ•°å‘½åè§„èŒƒ

#### åŸºæœ¬å‡½æ•°å‘½å
```cpp
// åŠ¨ä½œå‡½æ•°ï¼šåŠ¨è¯å¼€å¤´
class DataProcessor {
public:
    // åˆå§‹åŒ–å’Œæ¸…ç†
    bool initialize(const Configuration& config);  // åˆå§‹åŒ–
    void cleanup();                                // æ¸…ç†èµ„æº
    void reset();                                  // é‡ç½®çŠ¶æ€

    // æ•°æ®å¤„ç†
    ProcessingResult process(const RawData& input); // å¤„ç†æ•°æ®
    void startProcessing();                        // å¼€å§‹å¤„ç†
    void stopProcessing();                         // åœæ­¢å¤„ç†
    void pauseProcessing();                        // æš‚åœå¤„ç†
    void resumeProcessing();                       // æ¢å¤å¤„ç†

    // é…ç½®ç®¡ç†
    void setConfiguration(const Configuration& config); // è®¾ç½®é…ç½®
    void updateParameter(const std::string& name, const std::string& value); // æ›´æ–°å‚æ•°
    void applySettings();                          // åº”ç”¨è®¾ç½®

    // æ•°æ®è®¿é—®
    Configuration getConfiguration() const;        // è·å–é…ç½®
    ProcessorState getCurrentState() const;        // è·å–å½“å‰çŠ¶æ€
    PerformanceMetrics getMetrics() const;         // è·å–æ€§èƒ½æŒ‡æ ‡
};
```

#### æŸ¥è¯¢å’Œåˆ¤æ–­å‡½æ•°
```cpp
class SystemManager {
public:
    // çŠ¶æ€æŸ¥è¯¢ï¼šis/has/can å¼€å¤´
    bool isInitialized() const;        // æ˜¯å¦å·²åˆå§‹åŒ–
    bool isProcessing() const;         // æ˜¯å¦æ­£åœ¨å¤„ç†
    bool isReady() const;              // æ˜¯å¦å°±ç»ª

    bool hasData() const;              // æ˜¯å¦æœ‰æ•°æ®
    bool hasError() const;             // æ˜¯å¦æœ‰é”™è¯¯
    bool hasPendingTasks() const;      // æ˜¯å¦æœ‰å¾…å¤„ç†ä»»åŠ¡

    bool canProcess() const;           // æ˜¯å¦å¯ä»¥å¤„ç†
    bool canAcceptInput() const;       // æ˜¯å¦å¯ä»¥æ¥å—è¾“å…¥
    bool canShutdown() const;          // æ˜¯å¦å¯ä»¥å…³é—­

    // éªŒè¯å’Œæ£€æŸ¥ï¼švalidate/verify/check å¼€å¤´
    bool validateConfiguration(const Configuration& config); // éªŒè¯é…ç½®
    bool verifyDataIntegrity(const DataPacket& packet);     // éªŒè¯æ•°æ®å®Œæ•´æ€§
    bool checkSystemHealth();                               // æ£€æŸ¥ç³»ç»Ÿå¥åº·

    // æŸ¥æ‰¾å’Œæœç´¢ï¼šfind/search/locate å¼€å¤´
    std::optional<DataPacket> findPacketById(uint32_t id);  // æ ¹æ®IDæŸ¥æ‰¾æ•°æ®åŒ…
    std::vector<ErrorRecord> searchErrors(const TimeRange& range); // æœç´¢é”™è¯¯è®°å½•
    ProcessorInfo locateProcessor(const std::string& name); // å®šä½å¤„ç†å™¨
};
```

#### å·¥å‚å’Œåˆ›å»ºå‡½æ•°
```cpp
// å·¥å‚å‡½æ•°ï¼šcreate/make/build å¼€å¤´
class ProcessorFactory {
public:
    // åˆ›å»ºå‡½æ•°ï¼šè¿”å›æ™ºèƒ½æŒ‡é’ˆ
    static std::unique_ptr<IDataProcessor> createGPUProcessor(
        const GPUConfig& config);

    static std::shared_ptr<IDataReceiver> createEthernetReceiver(
        const NetworkConfig& config);

    static std::unique_ptr<IDisplayController> createOpenGLController(
        const DisplayConfig& config);

    // æ„å»ºå‡½æ•°ï¼šå¤æ‚å¯¹è±¡æ„å»º
    static ProcessingPipeline buildStandardPipeline(
        const PipelineConfig& config);

    static SystemConfiguration buildDefaultConfiguration();

    // åˆ¶é€ å‡½æ•°ï¼šæ‰¹é‡åˆ›å»º
    static std::vector<std::unique_ptr<IDataProcessor>> makeProcessorPool(
        size_t poolSize, const ProcessorConfig& config);
};

// å»ºé€ è€…æ¨¡å¼ï¼šBuilder åç¼€
class ConfigurationBuilder {
public:
    ConfigurationBuilder& setSamplingRate(double rate);
    ConfigurationBuilder& setBufferSize(size_t size);
    ConfigurationBuilder& setProcessingMode(ProcessingMode mode);
    ConfigurationBuilder& enableLogging(bool enable);

    Configuration build() const;  // æ„å»ºæœ€ç»ˆå¯¹è±¡
};
```

#### å›è°ƒå’Œäº‹ä»¶å¤„ç†å‡½æ•°
```cpp
// å›è°ƒå‡½æ•°ï¼šon å¼€å¤´ + äº‹ä»¶å
class EventHandler {
public:
    // æ•°æ®äº‹ä»¶
    virtual void onDataReceived(const DataPacket& packet) = 0;
    virtual void onDataProcessed(const ProcessingResult& result) = 0;
    virtual void onDataLost(uint32_t sequenceNumber) = 0;

    // çŠ¶æ€äº‹ä»¶
    virtual void onStateChanged(ProcessorState oldState, ProcessorState newState) = 0;
    virtual void onErrorOccurred(const ErrorInfo& error) = 0;
    virtual void onWarningGenerated(const WarningInfo& warning) = 0;

    // ç³»ç»Ÿäº‹ä»¶
    virtual void onSystemStartup() = 0;
    virtual void onSystemShutdown() = 0;
    virtual void onConfigurationChanged(const Configuration& newConfig) = 0;
};

// å¤„ç†å‡½æ•°ï¼šhandle å¼€å¤´
class MessageHandler {
public:
    void handleIncomingMessage(const Message& message);
    void handleNetworkError(const NetworkError& error);
    void handleTimeoutEvent(const TimeoutEvent& event);
    void handleUserInput(const UserInput& input);
};
```

---

## å¸¸é‡å’Œå®å‘½å

### ğŸ“ å¸¸é‡å‘½åè§„èŒƒ

#### ç¼–è¯‘æ—¶å¸¸é‡
```cpp
// å…¨å±€å¸¸é‡ï¼šSCREAMING_SNAKE_CASE
namespace radar {
    // ç‰©ç†å¸¸é‡
    constexpr double SPEED_OF_LIGHT = 2.99792458e8;      // å…‰é€Ÿ (m/s)
    constexpr double PLANCK_CONSTANT = 6.62607015e-34;   // æ™®æœ—å…‹å¸¸é‡

    // ç³»ç»Ÿé™åˆ¶
    constexpr size_t MAX_BUFFER_SIZE = 1024 * 1024;      // æœ€å¤§ç¼“å†²åŒºå¤§å°
    constexpr int MAX_CONCURRENT_THREADS = 16;           // æœ€å¤§å¹¶å‘çº¿ç¨‹æ•°
    constexpr uint32_t MAX_PACKET_SEQUENCE = 0xFFFFFFFF; // æœ€å¤§åŒ…åºåˆ—å·

    // é»˜è®¤å€¼
    constexpr double DEFAULT_SAMPLING_RATE = 1e9;        // é»˜è®¤é‡‡æ ·ç‡
    constexpr size_t DEFAULT_FFT_SIZE = 1024;            // é»˜è®¤FFTå¤§å°
    constexpr int DEFAULT_THREAD_COUNT = 4;              // é»˜è®¤çº¿ç¨‹æ•°

    // è¶…æ—¶å’Œå»¶è¿Ÿ
    constexpr std::chrono::milliseconds DEFAULT_TIMEOUT{1000};     // é»˜è®¤è¶…æ—¶
    constexpr std::chrono::microseconds MAX_PROCESSING_DELAY{100}; // æœ€å¤§å¤„ç†å»¶è¿Ÿ
}
```

#### ç±»ä½œç”¨åŸŸå¸¸é‡
```cpp
class DataProcessor {
public:
    // å…¬å…±å¸¸é‡ï¼šå¯è¢«å¤–éƒ¨è®¿é—®
    static constexpr int VERSION_MAJOR = 1;              // ä¸»ç‰ˆæœ¬å·
    static constexpr int VERSION_MINOR = 0;              // æ¬¡ç‰ˆæœ¬å·
    static constexpr size_t MINIMUM_BUFFER_SIZE = 512;   // æœ€å°ç¼“å†²åŒºå¤§å°

private:
    // ç§æœ‰å¸¸é‡ï¼šå†…éƒ¨å®ç°ç»†èŠ‚
    static constexpr int INTERNAL_QUEUE_SIZE = 100;      // å†…éƒ¨é˜Ÿåˆ—å¤§å°
    static constexpr double PI = 3.14159265358979323846; // åœ†å‘¨ç‡
    static constexpr float EPSILON = 1e-6f;              // æµ®ç‚¹æ¯”è¾ƒç²¾åº¦
};

// æšä¸¾å¸¸é‡ï¼šæ˜ç¡®çš„ä¸šåŠ¡è¯­ä¹‰
enum class ProcessingPriority : int {
    Low = 1,
    Normal = 5,
    High = 10,
    Critical = 20
};

enum class MemoryAlignment : size_t {
    Byte = 1,
    Word = 4,
    DoubleWord = 8,
    CacheLine = 64,
    Page = 4096
};
```

#### è¿è¡Œæ—¶å¸¸é‡
```cpp
// å…¨å±€è¿è¡Œæ—¶å¸¸é‡
namespace config {
    // é…ç½®æ–‡ä»¶è·¯å¾„
    const std::string CONFIG_FILE_PATH = "configs/system_config.yaml";
    const std::string LOG_FILE_PATH = "logs/system.log";
    const std::string DATA_DIRECTORY = "data/";

    // ç³»ç»Ÿä¿¡æ¯ï¼ˆè¿è¡Œæ—¶ç¡®å®šï¼‰
    const size_t SYSTEM_PAGE_SIZE = getSystemPageSize();
    const int CPU_CORE_COUNT = std::thread::hardware_concurrency();
    const std::string SYSTEM_HOSTNAME = getHostname();
}

// ç±»å†…è¿è¡Œæ—¶å¸¸é‡
class SystemInfo {
public:
    // é™æ€åˆå§‹åŒ–çš„è¿è¡Œæ—¶å¸¸é‡
    static const std::chrono::system_clock::time_point StartupTime;
    static const std::string ApplicationVersion;
    static const std::string BuildTimestamp;

private:
    static const size_t AvailableMemory;     // å¯ç”¨å†…å­˜å¤§å°
    static const std::string ConfigDirectory; // é…ç½®ç›®å½•è·¯å¾„
};
```

### ğŸ›ï¸ å®å®šä¹‰è§„èŒƒ

#### æ¡ä»¶ç¼–è¯‘å®
```cpp
// ç‰¹æ€§å¼€å…³ï¼šENABLE_ å‰ç¼€
#define ENABLE_GPU_PROCESSING 1       // å¯ç”¨GPUå¤„ç†
#define ENABLE_PERFORMANCE_PROFILING 0 // å¯ç”¨æ€§èƒ½åˆ†æ
#define ENABLE_DEBUG_LOGGING 1        // å¯ç”¨è°ƒè¯•æ—¥å¿—

// å¹³å°æ£€æµ‹ï¼šæ£€æŸ¥é¢„å®šä¹‰å®
#ifdef _WIN32
    #define PLATFORM_WINDOWS 1
#elif defined(__linux__)
    #define PLATFORM_LINUX 1
#elif defined(__APPLE__)
    #define PLATFORM_MACOS 1
#endif

// ç¼–è¯‘å™¨ç‰¹æ€§æ£€æµ‹
#if defined(__CUDA_ARCH__)
    #define CUDA_DEVICE_CODE 1
#endif

#if __cplusplus >= 201703L
    #define HAS_CPP17_FEATURES 1
#endif
```

#### åŠŸèƒ½å®å®šä¹‰
```cpp
// è°ƒè¯•å’Œæ—¥å¿—å®
#ifdef ENABLE_DEBUG_LOGGING
    #define DEBUG_LOG(msg) \
        do { \
            std::cout << "[DEBUG] " << __FILE__ << ":" << __LINE__ \
                      << " " << msg << std::endl; \
        } while(0)
#else
    #define DEBUG_LOG(msg) do {} while(0)  // é‡Šæ”¾ç‰ˆæœ¬ä¸­ä¸ºç©º
#endif

// é”™è¯¯å¤„ç†å®
#define CHECK_CUDA_ERROR(call) \
    do { \
        cudaError_t error = call; \
        if (error != cudaSuccess) { \
            std::cerr << "CUDA error at " << __FILE__ << ":" << __LINE__ \
                      << " - " << cudaGetErrorString(error) << std::endl; \
            std::abort(); \
        } \
    } while(0)

// æ€§èƒ½æµ‹é‡å®
#ifdef ENABLE_PERFORMANCE_PROFILING
    #define PROFILE_SCOPE(name) \
        PerformanceTimer timer(name)

    #define PROFILE_FUNCTION() \
        PROFILE_SCOPE(__FUNCTION__)
#else
    #define PROFILE_SCOPE(name) do {} while(0)
    #define PROFILE_FUNCTION() do {} while(0)
#endif

// å†…å­˜å¯¹é½å®
#define ALIGN_SIZE(size, alignment) \
    (((size) + (alignment) - 1) & ~((alignment) - 1))

#define CACHE_ALIGNED __attribute__((aligned(64)))  // ç¼“å­˜è¡Œå¯¹é½
#define GPU_ALIGNED __attribute__((aligned(256)))   // GPUå†…å­˜å¯¹é½
```

#### å·¥å…·å®å®šä¹‰
```cpp
// æ•°ç»„å¤§å°å®
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

// å®‰å…¨åˆ é™¤å®
#define SAFE_DELETE(ptr) \
    do { \
        delete (ptr); \
        (ptr) = nullptr; \
    } while(0)

#define SAFE_DELETE_ARRAY(ptr) \
    do { \
        delete[] (ptr); \
        (ptr) = nullptr; \
    } while(0)

// èŒƒå›´æ£€æŸ¥å®
#define IN_RANGE(value, min, max) \
    ((value) >= (min) && (value) <= (max))

// ä½æ“ä½œå®
#define SET_BIT(value, bit)    ((value) |= (1U << (bit)))
#define CLEAR_BIT(value, bit)  ((value) &= ~(1U << (bit)))
#define TEST_BIT(value, bit)   (((value) & (1U << (bit))) != 0)

// å­—èŠ‚åºè½¬æ¢å®ï¼ˆå°ç«¯åˆ°å¤§ç«¯ï¼‰
#define SWAP_BYTES_16(x) \
    ((((x) & 0xFF00) >> 8) | (((x) & 0x00FF) << 8))

#define SWAP_BYTES_32(x) \
    ((((x) & 0xFF000000) >> 24) | (((x) & 0x00FF0000) >> 8) | \
     (((x) & 0x0000FF00) << 8)  | (((x) & 0x000000FF) << 24))
```

---

## CUDA ç‰¹å®šå‘½å

### ğŸš€ CUDA å‡½æ•°å‘½å

#### Kernel å‡½æ•°å‘½å
```cuda
// æ ¸å‡½æ•°ï¼šåŠŸèƒ½æè¿° + Kernel åç¼€
__global__ void fftProcessingKernel(
    const cuComplex* input,
    cuComplex* output,
    int N
);

__global__ void pulseCompressionKernel(
    const float* inputData,
    const float* filterCoeffs,
    float* compressedOutput,
    int dataLength,
    int filterLength
);

__global__ void dopplerProcessingKernel(
    const cuComplex* rangeTimeMatrix,
    cuComplex* dopplerMatrix,
    int numRangeBins,
    int numPulses
);

__global__ void cfarDetectionKernel(
    const float* powerSpectrum,
    float* detectionResults,
    float thresholdFactor,
    int windowSize,
    int numCells
);

// ç®€å•è®¡ç®—æ ¸å‡½æ•°ï¼šè®¡ç®—ç±»å‹ + Kernel
__global__ void complexMultiplyKernel(
    const cuComplex* a,
    const cuComplex* b,
    cuComplex* result,
    int N
);

__global__ void magnitudeSquaredKernel(
    const cuComplex* input,
    float* output,
    int N
);
```

#### Device å‡½æ•°å‘½å
```cuda
// è®¾å¤‡å‡½æ•°ï¼š__device__ å‰ç¼€ï¼ŒåŠŸèƒ½æè¿°
__device__ float computeWindowFunction(int index, int windowSize, WindowType type);

__device__ cuComplex complexExponential(float angle);

__device__ void warpReduceSum(volatile float* sharedData, int tid);

__device__ float fastAtan2(float y, float x);

// å†…è”è®¾å¤‡å‡½æ•°ï¼šæ€§èƒ½å…³é”®çš„å°å‡½æ•°
__device__ __forceinline__ float fastSqrt(float x) {
    return __fsqrt_rn(x);  // æœ€è¿‘å¶æ•°èˆå…¥çš„å¿«é€Ÿå¹³æ–¹æ ¹
}

__device__ __forceinline__ cuComplex cuCmplxConj(cuComplex z) {
    return make_cuComplex(cuCrealf(z), -cuCimagf(z));
}
```

#### Host å‡½æ•°å‘½å
```cpp
// CUDA ä¸»æœºç«¯åŒ…è£…å‡½æ•°ï¼šlaunch å‰ç¼€
void launchFFTProcessing(
    const cuComplex* d_input,
    cuComplex* d_output,
    int N,
    cudaStream_t stream = 0
);

void launchPulseCompression(
    const float* d_inputData,
    const float* d_filterCoeffs,
    float* d_output,
    int dataLength,
    int filterLength,
    cudaStream_t stream = 0
);

// CUDA å†…å­˜ç®¡ç†å‡½æ•°ï¼šGPU å‰ç¼€
class GPUMemoryManager {
public:
    cudaError_t allocateGPUBuffer(void** ptr, size_t size);
    cudaError_t freeGPUBuffer(void* ptr);
    cudaError_t copyHostToGPU(void* dst, const void* src, size_t size);
    cudaError_t copyGPUToHost(void* dst, const void* src, size_t size);
    cudaError_t copyGPUToGPU(void* dst, const void* src, size_t size);
};
```

### ğŸ’¾ CUDA å˜é‡å‘½å

#### è®¾å¤‡ç«¯å˜é‡
```cuda
// è®¾å¤‡ç«¯æŒ‡é’ˆï¼šd_ å‰ç¼€
float* d_inputBuffer;        // è®¾å¤‡ç«¯è¾“å…¥ç¼“å†²åŒº
cuComplex* d_fftResult;      // è®¾å¤‡ç«¯FFTç»“æœ
float* d_powerSpectrum;      // è®¾å¤‡ç«¯åŠŸç‡è°±

// è®¾å¤‡ç«¯æ•°ç»„
__device__ float d_coefficients[MAX_FILTER_LENGTH];  // è®¾å¤‡ç«¯ç³»æ•°æ•°ç»„
__device__ cuComplex d_twiddleFactors[MAX_FFT_SIZE]; // è®¾å¤‡ç«¯æ—‹è½¬å› å­

// å¸¸é‡å†…å­˜ï¼šc_ å‰ç¼€
__constant__ float c_windowFunction[MAX_WINDOW_SIZE]; // å¸¸é‡å†…å­˜çª—å‡½æ•°
__constant__ ProcessingParams c_processingParams;    // å¸¸é‡å†…å­˜å¤„ç†å‚æ•°
__constant__ float c_filterBank[FILTER_BANK_SIZE];   // å¸¸é‡å†…å­˜æ»¤æ³¢å™¨ç»„
```

#### ä¸»æœºç«¯å˜é‡
```cpp
// ä¸»æœºç«¯æŒ‡é’ˆï¼šh_ å‰ç¼€
float* h_inputData;          // ä¸»æœºç«¯è¾“å…¥æ•°æ®
cuComplex* h_outputResult;   // ä¸»æœºç«¯è¾“å‡ºç»“æœ
float* h_referenceData;      // ä¸»æœºç«¯å‚è€ƒæ•°æ®

// å›ºå®šå†…å­˜ï¼špinned_ å‰ç¼€
float* pinned_inputBuffer;   // é¡µé”å®šè¾“å…¥ç¼“å†²åŒº
float* pinned_outputBuffer;  // é¡µé”å®šè¾“å‡ºç¼“å†²åŒº

// CUDA æµå’Œäº‹ä»¶
cudaStream_t computeStream;  // è®¡ç®—æµ
cudaStream_t copyStream;     // æ‹·è´æµ
cudaEvent_t startEvent;      // å¼€å§‹äº‹ä»¶
cudaEvent_t stopEvent;       // ç»“æŸäº‹ä»¶
```

#### å…±äº«å†…å­˜å’Œçº¹ç†
```cuda
// æ ¸å‡½æ•°å†…å…±äº«å†…å­˜ï¼šs_ å‰ç¼€
__global__ void advancedProcessingKernel(...) {
    __shared__ float s_inputData[BLOCK_SIZE];      // å…±äº«å†…å­˜è¾“å…¥æ•°æ®
    __shared__ cuComplex s_fftTemp[FFT_SIZE];      // å…±äº«å†…å­˜FFTä¸´æ—¶å­˜å‚¨
    __shared__ float s_reductionBuffer[WARP_SIZE]; // å…±äº«å†…å­˜å½’çº¦ç¼“å†²åŒº

    // æœ¬åœ°å˜é‡ä¿æŒ camelCase
    int threadId = threadIdx.x;
    int blockId = blockIdx.x;
    float localSum = 0.0f;
}

// çº¹ç†å†…å­˜ï¼štex_ å‰ç¼€
texture<float, 2, cudaReadModeElementType> tex_inputTexture;
texture<cuComplex, 1, cudaReadModeElementType> tex_filterTexture;

// è¡¨é¢å†…å­˜ï¼šsurf_ å‰ç¼€
surface<void, 2> surf_outputSurface;
surface<float, 1> surf_resultSurface;
```

### âš™ï¸ CUDA é…ç½®å‘½å

#### æ ¸å‡½æ•°å¯åŠ¨é…ç½®
```cpp
// ç½‘æ ¼å’Œå—é…ç½®ï¼šæ˜ç¡®çš„è¯­ä¹‰å‘½å
struct KernelLaunchConfig {
    dim3 gridDimensions;     // ç½‘æ ¼ç»´åº¦
    dim3 blockDimensions;    // å—ç»´åº¦
    size_t sharedMemorySize; // å…±äº«å†…å­˜å¤§å°
    cudaStream_t stream;     // æ‰§è¡Œæµ
};

// è®¡ç®—ç½‘æ ¼é…ç½®å‡½æ•°
KernelLaunchConfig calculateFFTLaunchConfig(int N);
KernelLaunchConfig calculateMatrixLaunchConfig(int rows, int cols);

// å¯åŠ¨é…ç½®å¸¸é‡
namespace cuda_config {
    constexpr int WARP_SIZE = 32;
    constexpr int MAX_THREADS_PER_BLOCK = 1024;
    constexpr int MAX_BLOCKS_PER_GRID = 65535;

    // å¸¸ç”¨é…ç½®
    constexpr dim3 DEFAULT_BLOCK_SIZE(256);
    constexpr dim3 MATRIX_BLOCK_SIZE(16, 16);
    constexpr dim3 FFT_BLOCK_SIZE(512);
}

// æ€§èƒ½è°ƒä¼˜å‚æ•°
struct PerformanceTuningParams {
    int optimalBlockSize;        // æœ€ä¼˜å—å¤§å°
    int optimalGridSize;         // æœ€ä¼˜ç½‘æ ¼å¤§å°
    size_t maxSharedMemoryUsage; // æœ€å¤§å…±äº«å†…å­˜ä½¿ç”¨
    int maxRegistersPerThread;   // æ¯çº¿ç¨‹æœ€å¤§å¯„å­˜å™¨æ•°
};
```

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦                   |
| :--- | :--------- | :----- | :------------------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºAIåä½œå¼€å‘å‘½åæ ‡å‡†è§„èŒƒ |
