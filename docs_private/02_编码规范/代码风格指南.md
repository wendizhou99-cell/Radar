# ä»£ç é£æ ¼æŒ‡å—

- **æ ‡é¢˜**: AIåä½œå¼€å‘ä»£ç é£æ ¼æŒ‡å—
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## é¡¹ç›®è§„èŒƒåŸºç¡€

### ğŸ“‹ ç»§æ‰¿ç°æœ‰è§„èŒƒ
æœ¬æŒ‡å—åŸºäº [`docs/03_æŠ€æœ¯è§„èŒƒ/ä»£ç ç¼–å†™è§„èŒƒ.md`](../../docs/03_æŠ€æœ¯è§„èŒƒ/ä»£ç ç¼–å†™è§„èŒƒ.md) è¿›è¡Œæ‰©å±•å’Œç»†åŒ–ï¼Œä¿æŒä¸é¡¹ç›®æ•´ä½“è§„èŒƒçš„ä¸€è‡´æ€§ã€‚

**æ ¸å¿ƒç»§æ‰¿è¦ç‚¹**:
```markdown
åŸºç¡€è¦æ±‚ï¼ˆå¼ºåˆ¶ï¼‰ï¼š
- æ¥å£ç±»ä½¿ç”¨ I å‰ç¼€ + PascalCase
- å…¬å…±æ–¹æ³•ä½¿ç”¨ camelCase
- æ–‡ä»¶å¤´æ³¨é‡Šä½¿ç”¨ Doxygen æ ¼å¼
- æ‰€æœ‰å¤´æ–‡ä»¶ä½¿ç”¨ #pragma once

æ‰©å±•ç»†åŒ–ï¼ˆæœ¬æŒ‡å—ï¼‰ï¼š
- C++17 ç°ä»£åŒ–ç‰¹æ€§çš„å…·ä½“ä½¿ç”¨æ–¹æ³•
- CUDA ä»£ç çš„ç‰¹æ®Šæ ¼å¼åŒ–è¦æ±‚
- æ–‡ä»¶ç»„ç»‡çš„è¯¦ç»†ç»“æ„è§„èŒƒ
- è‡ªåŠ¨åŒ–å·¥å…·çš„é…ç½®å’Œé›†æˆ
```

### ğŸ¯ é€‚ç”¨èŒƒå›´
```markdown
é€‚ç”¨ä»£ç ç±»å‹ï¼š
- æ¥å£å¤´æ–‡ä»¶ (include/interfaces/*.h)
- å®ç°æºæ–‡ä»¶ (src/*/*.cpp)
- CUDA æ ¸å‡½æ•° (src/*/*.cu)
- å•å…ƒæµ‹è¯•ä»£ç  (tests/*/*.cpp)
- é…ç½®å’Œæ„å»ºè„šæœ¬

ä¼˜å…ˆçº§è¯´æ˜ï¼š
1. å…¬å…±æ¥å£ä»£ç ï¼šä¸¥æ ¼éµå¾ªæ‰€æœ‰è§„èŒƒ
2. æ¨¡å—å†…éƒ¨å®ç°ï¼šéµå¾ªæ ¸å¿ƒè§„èŒƒï¼Œå…è®¸é€‚åº¦çµæ´»
3. æµ‹è¯•ä»£ç ï¼šéµå¾ªåŸºæœ¬è§„èŒƒï¼Œæ³¨é‡å¯è¯»æ€§
4. ä¸´æ—¶å’Œå®éªŒä»£ç ï¼šéµå¾ªåŸºæœ¬æ ¼å¼ï¼Œåšå¥½æ ‡è®°
```

---

## C++17ç°ä»£åŒ–é£æ ¼

### ğŸš€ ç°ä»£åŒ–ç‰¹æ€§ä½¿ç”¨

#### auto å…³é”®å­—ä½¿ç”¨è§„èŒƒ
```cpp
// âœ… æ¨èï¼šç±»å‹æ˜æ˜¾æˆ–å¤æ‚çš„æƒ…å†µ
auto data = std::make_unique<ProcessedData>();
auto result = processRawData(inputPacket);
auto iter = dataMap.find(key);

// âœ… æ¨èï¼šæ¨¡æ¿ç±»å‹æ¨å¯¼
template<typename T>
auto createProcessor(const Config& config) -> std::unique_ptr<T> {
    return std::make_unique<T>(config);
}

// âŒ é¿å…ï¼šåŸºæœ¬ç±»å‹ä¸æ˜ç¡®
auto count = 10;        // ä¸å¦‚ int count = 10;
auto rate = 3.14f;      // ä¸å¦‚ float rate = 3.14f;

// âœ… å¯æ¥å—ï¼šæ˜ç¡®çš„åŸºæœ¬ç±»å‹
auto count = static_cast<size_t>(10);
auto rate = 3.14f;  // ç±»å‹åç¼€æ˜ç¡®
```

#### æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨è§„èŒƒ
```cpp
// âœ… èµ„æºç®¡ç†ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
class DataProcessor {
private:
    std::unique_ptr<GPUBuffer> deviceBuffer_;
    std::shared_ptr<Config> config_;

public:
    // âœ… å·¥å‚æ–¹æ³•è¿”å›æ™ºèƒ½æŒ‡é’ˆ
    static std::unique_ptr<DataProcessor> create(const Config& config) {
        return std::make_unique<DataProcessor>(config);
    }

    // âœ… æ¥å£å‚æ•°ä½¿ç”¨åŸå§‹æŒ‡é’ˆæˆ–å¼•ç”¨
    bool process(const RawDataPacket& input, ProcessedData* output) {
        // å®ç°å¤„ç†é€»è¾‘
    }
};

// âŒ é¿å…ï¼šä¸å¿…è¦çš„ shared_ptr
std::shared_ptr<int> counter;  // åº”è¯¥ç”¨ int æˆ– std::unique_ptr<int>

// âœ… æ­£ç¡®ï¼šæ˜ç¡®çš„æ‰€æœ‰æƒè¯­ä¹‰
std::unique_ptr<DataBuffer> createBuffer(size_t size);
std::shared_ptr<Config> getSharedConfig();
```

#### ç»“æ„åŒ–ç»‘å®š
```cpp
// âœ… æ¨èï¼šå‡½æ•°è¿”å›å¤šä¸ªå€¼æ—¶
auto [success, result, errorMsg] = processData(input);
if (success) {
    handleResult(result);
} else {
    logError(errorMsg);
}

// âœ… æ¨èï¼šéå† map å®¹å™¨
for (const auto& [key, value] : configMap) {
    applyConfig(key, value);
}

// âœ… æ¨èï¼šè§£æ„å¤æ‚å¯¹è±¡
auto [timestamp, data, metadata] = packet.extractInfo();
```

### ğŸ“¦ ç°ä»£åŒ–å®¹å™¨å’Œç®—æ³•

#### å®¹å™¨é€‰æ‹©æŒ‡å—
```cpp
// âœ… æ€§èƒ½å…³é”®åœºæ™¯
std::vector<float> signalData;           // è¿ç»­å†…å­˜ï¼Œç¼“å­˜å‹å¥½
std::array<int, 4> coordinates;          // å›ºå®šå¤§å°ï¼Œæ ˆåˆ†é…
std::unordered_map<std::string, int> lookup;  // å¿«é€ŸæŸ¥æ‰¾

// âœ… ç‰¹æ®Šéœ€æ±‚åœºæ™¯
std::deque<Task> taskQueue;              // åŒç«¯æ’å…¥åˆ é™¤
std::priority_queue<Event> eventQueue;   // ä¼˜å…ˆçº§æ’åº
std::set<int> uniqueIds;                 // è‡ªåŠ¨æ’åºå»é‡

// é€‰æ‹©å»ºè®®ï¼š
// - é¡ºåºè®¿é—®ï¼šä¼˜å…ˆ std::vector
// - é¢‘ç¹æŸ¥æ‰¾ï¼šä¼˜å…ˆ std::unordered_map/set
// - æœ‰åºéå†ï¼šä¼˜å…ˆ std::map/set
// - å›ºå®šå¤§å°ï¼šä¼˜å…ˆ std::array
```

#### STL ç®—æ³•ä½¿ç”¨
```cpp
#include <algorithm>
#include <numeric>

// âœ… æ¨èï¼šä½¿ç”¨ STL ç®—æ³•æ›¿ä»£æ‰‹å†™å¾ªç¯
std::vector<float> data = getRawData();

// æŸ¥æ‰¾æœ€å¤§å€¼
auto maxElement = std::max_element(data.begin(), data.end());

// æ¡ä»¶è¿‡æ»¤
auto validData = std::copy_if(data.begin(), data.end(),
    std::back_inserter(std::vector<float>{}),
    [](float val) { return val > 0.0f; });

// æ•°æ®å˜æ¢
std::transform(data.begin(), data.end(), data.begin(),
    [](float val) { return std::sqrt(val); });

// å¹¶è¡Œç®—æ³• (C++17)
#include <execution>
std::sort(std::execution::par, data.begin(), data.end());
```

---

## CUDAä»£ç é£æ ¼

### ğŸ® CUDA ç‰¹æ®Šå‘½åè§„èŒƒ

#### Kernel å‡½æ•°å‘½å
```cuda
// âœ… Kernel å‡½æ•°ï¼šåŠ¨è¯ + æè¿° + "Kernel" åç¼€
__global__ void processSignalKernel(
    const float* input,
    float* output,
    size_t dataSize,
    ProcessingParams params
);

__global__ void computeFFTKernel(
    const cuComplex* timeData,
    cuComplex* freqData,
    int N
);

// âœ… Device å‡½æ•°ï¼šnormal camelCase
__device__ float computeAmplitude(cuComplex value) {
    return sqrtf(value.x * value.x + value.y * value.y);
}

// âœ… Host åŒ…è£…å‡½æ•°ï¼šlaunch + KernelName
cudaError_t launchProcessSignalKernel(
    const ProcessSignalParams& params,
    cudaStream_t stream = nullptr
);
```

#### CUDA å˜é‡å‘½å
```cuda
// âœ… Device æŒ‡é’ˆï¼šd_ å‰ç¼€
float* d_inputData;
cuComplex* d_fftResult;
int* d_indices;

// âœ… Host æŒ‡é’ˆï¼šh_ å‰ç¼€ï¼ˆå¯é€‰ï¼Œç”¨äºåŒºåˆ†ï¼‰
float* h_inputData;
cuComplex* h_fftResult;

// âœ… å…±äº«å†…å­˜ï¼šs_ å‰ç¼€
__shared__ float s_tempData[BLOCK_SIZE];
__shared__ int s_indices[MAX_THREADS];

// âœ… å¸¸é‡å†…å­˜ï¼šc_ å‰ç¼€
__constant__ ProcessingParams c_params;
__constant__ float c_filterCoeffs[MAX_FILTER_SIZE];
```

### âš¡ CUDA ä»£ç ç»„ç»‡

#### Kernel å‡½æ•°ç»“æ„
```cuda
/**
 * @brief å¤„ç†ä¿¡å·æ•°æ®çš„ CUDA æ ¸å‡½æ•°
 * @param input [in] è¾“å…¥ä¿¡å·æ•°æ®
 * @param output [out] å¤„ç†åçš„è¾“å‡ºæ•°æ®
 * @param dataSize [in] æ•°æ®ç‚¹æ•°é‡
 * @param params [in] å¤„ç†å‚æ•°
 */
__global__ void processSignalKernel(
    const float* input,
    float* output,
    size_t dataSize,
    ProcessingParams params
) {
    // 1. è®¡ç®—çº¿ç¨‹ç´¢å¼•
    const int tid = blockIdx.x * blockDim.x + threadIdx.x;
    const int stride = blockDim.x * gridDim.x;

    // 2. å…±äº«å†…å­˜å£°æ˜
    __shared__ float s_buffer[BLOCK_SIZE];

    // 3. è¾¹ç•Œæ£€æŸ¥
    if (tid >= dataSize) return;

    // 4. ä¸»è¦å¤„ç†é€»è¾‘
    for (int i = tid; i < dataSize; i += stride) {
        // å¤„ç†é€»è¾‘
        float value = input[i];
        value = applyProcessing(value, params);
        output[i] = value;
    }

    // 5. åŒæ­¥å’Œå…±äº«å†…å­˜æ“ä½œ
    __syncthreads();

    // 6. å—çº§å½’çº¦æˆ–å…¶ä»–é›†åˆæ“ä½œ
    // ...
}
```

#### CUDA é”™è¯¯æ£€æŸ¥
```cuda
// âœ… ç»Ÿä¸€çš„é”™è¯¯æ£€æŸ¥å®
#define CUDA_CHECK(call) do { \
    cudaError_t error = call; \
    if (error != cudaSuccess) { \
        std::cerr << "CUDA error at " << __FILE__ << ":" << __LINE__ \
                  << " - " << cudaGetErrorString(error) << std::endl; \
        throw std::runtime_error("CUDA operation failed"); \
    } \
} while(0)

// âœ… ä½¿ç”¨ç¤ºä¾‹
void allocateDeviceMemory(float** d_ptr, size_t size) {
    CUDA_CHECK(cudaMalloc(d_ptr, size * sizeof(float)));
}

void launchKernel() {
    processSignalKernel<<<gridSize, blockSize>>>(d_input, d_output, dataSize, params);
    CUDA_CHECK(cudaGetLastError());
    CUDA_CHECK(cudaDeviceSynchronize());
}
```

---

## æ–‡ä»¶ç»„ç»‡è§„èŒƒ

### ğŸ“ å¤´æ–‡ä»¶åŒ…å«é¡ºåº
```cpp
// æ–‡ä»¶ï¼šsrc/processor/DataProcessor.cpp

// 1. å¯¹åº”çš„å¤´æ–‡ä»¶
#include "processor/DataProcessor.h"

// 2. é¡¹ç›®å†…éƒ¨å¤´æ–‡ä»¶ï¼ˆæŒ‰æ¨¡å—åˆ†ç»„ï¼‰
#include "common/Types.h"
#include "common/Logger.h"
#include "interfaces/IDataReceiver.h"

// 3. ç¬¬ä¸‰æ–¹åº“å¤´æ–‡ä»¶
#include <opencv2/opencv.hpp>
#include <eigen3/Eigen/Dense>

// 4. CUDA ç›¸å…³å¤´æ–‡ä»¶
#include <cuda_runtime.h>
#include <cublas_v2.h>
#include <cufft.h>

// 5. C++ æ ‡å‡†åº“å¤´æ–‡ä»¶ï¼ˆæŒ‰å­—æ¯æ’åºï¼‰
#include <algorithm>
#include <memory>
#include <vector>

// 6. C æ ‡å‡†åº“å¤´æ–‡ä»¶
#include <cassert>
#include <cmath>
```

### ğŸ—ï¸ å‘½åç©ºé—´ä½¿ç”¨è§„èŒƒ
```cpp
// âœ… æ–‡ä»¶çº§å‘½åç©ºé—´
namespace radar {
namespace processing {

class DataProcessor : public IDataProcessor {
    // å®ç°
};

} // namespace processing
} // namespace radar

// âœ… å‡½æ•°å†…å±€éƒ¨ using å£°æ˜
void someFunction() {
    using std::vector;
    using std::unique_ptr;

    vector<float> data;
    unique_ptr<Processor> proc;
}

// âŒ é¿å…ï¼šå¤´æ–‡ä»¶ä¸­çš„å…¨å±€ using å£°æ˜
// using namespace std;  // ä¸è¦åœ¨å¤´æ–‡ä»¶ä¸­ä½¿ç”¨

// âœ… å¯æ¥å—ï¼šæºæ–‡ä»¶ä¸­çš„å±€éƒ¨ using
namespace {  // åŒ¿åå‘½åç©ºé—´ï¼Œæ–‡ä»¶å†…éƒ¨ä½¿ç”¨
using namespace radar::processing;
}
```

### ğŸ“‹ ä»£ç åˆ†å—åŸåˆ™
```cpp
class DataProcessor {
public:
    // ===== ç”Ÿå‘½å‘¨æœŸç®¡ç† =====
    DataProcessor(const Config& config);
    ~DataProcessor();
    DataProcessor(const DataProcessor&) = delete;
    DataProcessor& operator=(const DataProcessor&) = delete;

    // ===== æ ¸å¿ƒæ¥å£ =====
    bool initialize() override;
    ProcessingResult process(const RawDataPacket& input) override;
    void cleanup() override;

    // ===== çŠ¶æ€æŸ¥è¯¢ =====
    bool isInitialized() const override;
    ProcessingStats getStatistics() const override;

    // ===== é…ç½®ç®¡ç† =====
    void updateConfig(const Config& newConfig);
    const Config& getConfig() const;

private:
    // ===== å†…éƒ¨å®ç°æ–¹æ³• =====
    bool initializeGPU();
    void releaseGPUResources();
    bool processOnGPU(const float* input, float* output, size_t size);

    // ===== æ•°æ®æˆå‘˜ =====
    Config config_;
    bool initialized_;

    // GPU ç›¸å…³èµ„æº
    float* d_inputBuffer_;
    float* d_outputBuffer_;
    cudaStream_t stream_;

    // ç»Ÿè®¡ä¿¡æ¯
    mutable std::mutex statsMutex_;
    ProcessingStats stats_;
};
```

---

## æ ¼å¼åŒ–å·¥å…·é…ç½®

### ğŸ”§ Clang-Format é…ç½®

#### é¡¹ç›® .clang-format æ–‡ä»¶
```yaml
# .clang-format - é¡¹ç›®æ ¹ç›®å½•
Language: Cpp
BasedOnStyle: Google

# ç¼©è¿›é…ç½®
IndentWidth: 4
TabWidth: 4
UseTab: Never
IndentCaseLabels: true
IndentPPDirectives: BeforeHash

# å¤§æ‹¬å·é£æ ¼
BreakBeforeBraces: Attach
Cpp11BracedListStyle: true

# è¡Œé•¿åº¦
ColumnLimit: 100
BreakBeforeBinaryOperators: NonAssignment

# å‡½æ•°æ ¼å¼åŒ–
AllowShortFunctionsOnASingleLine: Empty
AllowShortIfStatementsOnASingleLine: false
AllowShortLoopsOnASingleLine: false

# æŒ‡é’ˆå’Œå¼•ç”¨
PointerAlignment: Left
ReferenceAlignment: Left

# å‘½åç©ºé—´
NamespaceIndentation: None
CompactNamespaces: false

# è®¿é—®ä¿®é¥°ç¬¦
AccessModifierOffset: -2

# æ³¨é‡Šå¯¹é½
AlignTrailingComments: true
SpacesBeforeTrailingComments: 2

# åŒ…å«æ–‡ä»¶æ’åº
SortIncludes: true
IncludeBlocks: Regroup
IncludeCategories:
  - Regex: '^".*\.h"$'         # é¡¹ç›®å¤´æ–‡ä»¶
    Priority: 1
  - Regex: '^<.*\.h>$'         # C ç³»ç»Ÿå¤´æ–‡ä»¶
    Priority: 3
  - Regex: '^<.*>$'            # C++ æ ‡å‡†åº“
    Priority: 4
  - Regex: '.*'                # å…¶ä»–
    Priority: 2
```

### ğŸ› ï¸ IDE é›†æˆé…ç½®

#### VS Code é…ç½®
```json
// .vscode/settings.json
{
    "C_Cpp.clang_format_style": "file",
    "C_Cpp.clang_format_fallbackStyle": "Google",
    "editor.formatOnSave": true,
    "editor.tabSize": 4,
    "editor.insertSpaces": true,
    "files.trimTrailingWhitespace": true,
    "files.insertFinalNewline": true,

    "C_Cpp.codeAnalysis.clangTidy.enabled": true,
    "C_Cpp.codeAnalysis.runAutomatically": true,

    "editor.rulers": [80, 100],
    "editor.wordWrap": "wordWrapColumn",
    "editor.wordWrapColumn": 100
}
```

#### CLion/Visual Studio é…ç½®
```markdown
CLion é…ç½®ï¼š
1. File -> Settings -> Editor -> Code Style -> C/C++
2. é€‰æ‹© "Set from..." -> "clang-format"
3. æŒ‡å®šé¡¹ç›®æ ¹ç›®å½•çš„ .clang-format æ–‡ä»¶

Visual Studio é…ç½®ï¼š
1. Tools -> Options -> Text Editor -> C/C++ -> Formatting
2. é€‰æ‹© "Use clang-format file"
3. ç¡®ä¿é¡¹ç›®æ ¹ç›®å½•æœ‰ .clang-format æ–‡ä»¶
```

### ğŸ“Š è‡ªåŠ¨åŒ–æ£€æŸ¥é›†æˆ

#### Git Hook é›†æˆ
```bash
#!/bin/bash
# .git/hooks/pre-commit

# æ£€æŸ¥ä»£ç æ ¼å¼
files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(cpp|h|cu|cuh)$')

if [ -n "$files" ]; then
    # æ£€æŸ¥æ ¼å¼
    for file in $files; do
        clang-format --dry-run --Werror "$file"
        if [ $? -ne 0 ]; then
            echo "ä»£ç æ ¼å¼æ£€æŸ¥å¤±è´¥: $file"
            echo "è¯·è¿è¡Œ: clang-format -i $file"
            exit 1
        fi
    done
fi

echo "ä»£ç æ ¼å¼æ£€æŸ¥é€šè¿‡"
```

#### CMake é›†æˆ
```cmake
# æ·»åŠ æ ¼å¼åŒ–ç›®æ ‡
find_program(CLANG_FORMAT_EXE clang-format)
if(CLANG_FORMAT_EXE)
    file(GLOB_RECURSE SOURCE_FILES
         ${CMAKE_SOURCE_DIR}/src/*.cpp
         ${CMAKE_SOURCE_DIR}/src/*.h
         ${CMAKE_SOURCE_DIR}/include/*.h)

    add_custom_target(format
        COMMAND ${CLANG_FORMAT_EXE} -i ${SOURCE_FILES}
        COMMENT "Formatting source code with clang-format"
    )

    add_custom_target(check-format
        COMMAND ${CLANG_FORMAT_EXE} --dry-run --Werror ${SOURCE_FILES}
        COMMENT "Checking code format with clang-format"
    )
endif()
```

---

## ä»£ç å®¡æŸ¥è¦ç‚¹

### âœ… æ ¼å¼æ£€æŸ¥æ¸…å•

#### è‡ªåŠ¨æ£€æŸ¥é¡¹ç›®
```markdown
åŸºç¡€æ ¼å¼ â˜
- [ ] ç¼©è¿›ä½¿ç”¨ 4 ä¸ªç©ºæ ¼ï¼Œä¸ä½¿ç”¨ Tab
- [ ] è¡Œé•¿åº¦ä¸è¶…è¿‡ 100 å­—ç¬¦
- [ ] æ–‡ä»¶æœ«å°¾æœ‰æ¢è¡Œç¬¦
- [ ] è¡Œæœ«æ²¡æœ‰å¤šä½™ç©ºæ ¼

å‘½åè§„èŒƒ â˜
- [ ] ç±»åä½¿ç”¨ PascalCase
- [ ] å‡½æ•°åä½¿ç”¨ camelCase
- [ ] å˜é‡åä½¿ç”¨ snake_case æˆ– camelCase
- [ ] å¸¸é‡ä½¿ç”¨ UPPER_SNAKE_CASE

æ³¨é‡Šæ ¼å¼ â˜
- [ ] å¤´æ–‡ä»¶åŒ…å«æ–‡ä»¶çº§ Doxygen æ³¨é‡Š
- [ ] å…¬å…±æ¥å£åŒ…å«å®Œæ•´çš„æ–¹æ³•æ³¨é‡Š
- [ ] å¤æ‚é€»è¾‘åŒ…å«é€‚å½“çš„å†…è”æ³¨é‡Š
- [ ] TODO/FIXME æ ¼å¼è§„èŒƒ
```

#### C++17 ç‰¹æ€§æ£€æŸ¥
```markdown
ç°ä»£åŒ–ä½¿ç”¨ â˜
- [ ] é€‚å½“ä½¿ç”¨ auto å…³é”®å­—
- [ ] ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æº
- [ ] ä½¿ç”¨ç»“æ„åŒ–ç»‘å®šç®€åŒ–ä»£ç 
- [ ] ä½¿ç”¨ STL ç®—æ³•æ›¿ä»£æ‰‹å†™å¾ªç¯

CUDA ä»£ç æ£€æŸ¥ â˜
- [ ] Kernel å‡½æ•°å‘½ååŒ…å« "Kernel" åç¼€
- [ ] Device å˜é‡ä½¿ç”¨ d_ å‰ç¼€
- [ ] åŒ…å«é€‚å½“çš„é”™è¯¯æ£€æŸ¥
- [ ] å…±äº«å†…å­˜ä½¿ç”¨åˆç†
```

### ğŸš€ æ€§èƒ½è€ƒè™‘

#### æ€§èƒ½æ•æ„Ÿä»£ç æ ¼å¼
```cpp
// âœ… æ€§èƒ½å…³é”®è·¯å¾„ï¼šç®€æ´æ˜äº†
__global__ void criticalKernel(const float* input, float* output, size_t N) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        // ç´§å‡‘çš„å¤„ç†é€»è¾‘
        output[idx] = sqrtf(input[idx] * input[idx] + 1.0f);
    }
}

// âœ… ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„å¸ƒå±€
struct alignas(16) ProcessingData {
    float real;      // 4 bytes
    float imag;      // 4 bytes
    uint32_t flags;  // 4 bytes
    uint32_t id;     // 4 bytes
};  // æ€»å…± 16 bytesï¼Œå¯¹é½åˆ°ç¼“å­˜è¡Œ
```

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦         |
| :--- | :--------- | :----- | :--------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºä»£ç é£æ ¼æŒ‡å— |
