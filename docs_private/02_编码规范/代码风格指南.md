# 代码风格指南

- **标题**: AI协作开发代码风格指南
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 项目规范基础

### 📋 继承现有规范
本指南基于 [`docs/03_技术规范/代码编写规范.md`](../../docs/03_技术规范/代码编写规范.md) 进行扩展和细化，保持与项目整体规范的一致性。

**核心继承要点**:
```markdown
基础要求（强制）：
- 接口类使用 I 前缀 + PascalCase
- 公共方法使用 camelCase
- 文件头注释使用 Doxygen 格式
- 所有头文件使用 #pragma once

扩展细化（本指南）：
- C++17 现代化特性的具体使用方法
- CUDA 代码的特殊格式化要求
- 文件组织的详细结构规范
- 自动化工具的配置和集成
```

### 🎯 适用范围
```markdown
适用代码类型：
- 接口头文件 (include/interfaces/*.h)
- 实现源文件 (src/*/*.cpp)
- CUDA 核函数 (src/*/*.cu)
- 单元测试代码 (tests/*/*.cpp)
- 配置和构建脚本

优先级说明：
1. 公共接口代码：严格遵循所有规范
2. 模块内部实现：遵循核心规范，允许适度灵活
3. 测试代码：遵循基本规范，注重可读性
4. 临时和实验代码：遵循基本格式，做好标记
```

---

## C++17现代化风格

### 🚀 现代化特性使用

#### auto 关键字使用规范
```cpp
// ✅ 推荐：类型明显或复杂的情况
auto data = std::make_unique<ProcessedData>();
auto result = processRawData(inputPacket);
auto iter = dataMap.find(key);

// ✅ 推荐：模板类型推导
template<typename T>
auto createProcessor(const Config& config) -> std::unique_ptr<T> {
    return std::make_unique<T>(config);
}

// ❌ 避免：基本类型不明确
auto count = 10;        // 不如 int count = 10;
auto rate = 3.14f;      // 不如 float rate = 3.14f;

// ✅ 可接受：明确的基本类型
auto count = static_cast<size_t>(10);
auto rate = 3.14f;  // 类型后缀明确
```

#### 智能指针使用规范
```cpp
// ✅ 资源管理优先使用智能指针
class DataProcessor {
private:
    std::unique_ptr<GPUBuffer> deviceBuffer_;
    std::shared_ptr<Config> config_;

public:
    // ✅ 工厂方法返回智能指针
    static std::unique_ptr<DataProcessor> create(const Config& config) {
        return std::make_unique<DataProcessor>(config);
    }

    // ✅ 接口参数使用原始指针或引用
    bool process(const RawDataPacket& input, ProcessedData* output) {
        // 实现处理逻辑
    }
};

// ❌ 避免：不必要的 shared_ptr
std::shared_ptr<int> counter;  // 应该用 int 或 std::unique_ptr<int>

// ✅ 正确：明确的所有权语义
std::unique_ptr<DataBuffer> createBuffer(size_t size);
std::shared_ptr<Config> getSharedConfig();
```

#### 结构化绑定
```cpp
// ✅ 推荐：函数返回多个值时
auto [success, result, errorMsg] = processData(input);
if (success) {
    handleResult(result);
} else {
    logError(errorMsg);
}

// ✅ 推荐：遍历 map 容器
for (const auto& [key, value] : configMap) {
    applyConfig(key, value);
}

// ✅ 推荐：解构复杂对象
auto [timestamp, data, metadata] = packet.extractInfo();
```

### 📦 现代化容器和算法

#### 容器选择指南
```cpp
// ✅ 性能关键场景
std::vector<float> signalData;           // 连续内存，缓存友好
std::array<int, 4> coordinates;          // 固定大小，栈分配
std::unordered_map<std::string, int> lookup;  // 快速查找

// ✅ 特殊需求场景
std::deque<Task> taskQueue;              // 双端插入删除
std::priority_queue<Event> eventQueue;   // 优先级排序
std::set<int> uniqueIds;                 // 自动排序去重

// 选择建议：
// - 顺序访问：优先 std::vector
// - 频繁查找：优先 std::unordered_map/set
// - 有序遍历：优先 std::map/set
// - 固定大小：优先 std::array
```

#### STL 算法使用
```cpp
#include <algorithm>
#include <numeric>

// ✅ 推荐：使用 STL 算法替代手写循环
std::vector<float> data = getRawData();

// 查找最大值
auto maxElement = std::max_element(data.begin(), data.end());

// 条件过滤
auto validData = std::copy_if(data.begin(), data.end(),
    std::back_inserter(std::vector<float>{}),
    [](float val) { return val > 0.0f; });

// 数据变换
std::transform(data.begin(), data.end(), data.begin(),
    [](float val) { return std::sqrt(val); });

// 并行算法 (C++17)
#include <execution>
std::sort(std::execution::par, data.begin(), data.end());
```

---

## CUDA代码风格

### 🎮 CUDA 特殊命名规范

#### Kernel 函数命名
```cuda
// ✅ Kernel 函数：动词 + 描述 + "Kernel" 后缀
__global__ void processSignalKernel(
    const float* input,
    float* output,
    size_t dataSize,
    ProcessingParams params
);

__global__ void computeFFTKernel(
    const cuComplex* timeData,
    cuComplex* freqData,
    int N
);

// ✅ Device 函数：normal camelCase
__device__ float computeAmplitude(cuComplex value) {
    return sqrtf(value.x * value.x + value.y * value.y);
}

// ✅ Host 包装函数：launch + KernelName
cudaError_t launchProcessSignalKernel(
    const ProcessSignalParams& params,
    cudaStream_t stream = nullptr
);
```

#### CUDA 变量命名
```cuda
// ✅ Device 指针：d_ 前缀
float* d_inputData;
cuComplex* d_fftResult;
int* d_indices;

// ✅ Host 指针：h_ 前缀（可选，用于区分）
float* h_inputData;
cuComplex* h_fftResult;

// ✅ 共享内存：s_ 前缀
__shared__ float s_tempData[BLOCK_SIZE];
__shared__ int s_indices[MAX_THREADS];

// ✅ 常量内存：c_ 前缀
__constant__ ProcessingParams c_params;
__constant__ float c_filterCoeffs[MAX_FILTER_SIZE];
```

### ⚡ CUDA 代码组织

#### Kernel 函数结构
```cuda
/**
 * @brief 处理信号数据的 CUDA 核函数
 * @param input [in] 输入信号数据
 * @param output [out] 处理后的输出数据
 * @param dataSize [in] 数据点数量
 * @param params [in] 处理参数
 */
__global__ void processSignalKernel(
    const float* input,
    float* output,
    size_t dataSize,
    ProcessingParams params
) {
    // 1. 计算线程索引
    const int tid = blockIdx.x * blockDim.x + threadIdx.x;
    const int stride = blockDim.x * gridDim.x;

    // 2. 共享内存声明
    __shared__ float s_buffer[BLOCK_SIZE];

    // 3. 边界检查
    if (tid >= dataSize) return;

    // 4. 主要处理逻辑
    for (int i = tid; i < dataSize; i += stride) {
        // 处理逻辑
        float value = input[i];
        value = applyProcessing(value, params);
        output[i] = value;
    }

    // 5. 同步和共享内存操作
    __syncthreads();

    // 6. 块级归约或其他集合操作
    // ...
}
```

#### CUDA 错误检查
```cuda
// ✅ 统一的错误检查宏
#define CUDA_CHECK(call) do { \
    cudaError_t error = call; \
    if (error != cudaSuccess) { \
        std::cerr << "CUDA error at " << __FILE__ << ":" << __LINE__ \
                  << " - " << cudaGetErrorString(error) << std::endl; \
        throw std::runtime_error("CUDA operation failed"); \
    } \
} while(0)

// ✅ 使用示例
void allocateDeviceMemory(float** d_ptr, size_t size) {
    CUDA_CHECK(cudaMalloc(d_ptr, size * sizeof(float)));
}

void launchKernel() {
    processSignalKernel<<<gridSize, blockSize>>>(d_input, d_output, dataSize, params);
    CUDA_CHECK(cudaGetLastError());
    CUDA_CHECK(cudaDeviceSynchronize());
}
```

---

## 文件组织规范

### 📁 头文件包含顺序
```cpp
// 文件：src/processor/DataProcessor.cpp

// 1. 对应的头文件
#include "processor/DataProcessor.h"

// 2. 项目内部头文件（按模块分组）
#include "common/Types.h"
#include "common/Logger.h"
#include "interfaces/IDataReceiver.h"

// 3. 第三方库头文件
#include <opencv2/opencv.hpp>
#include <eigen3/Eigen/Dense>

// 4. CUDA 相关头文件
#include <cuda_runtime.h>
#include <cublas_v2.h>
#include <cufft.h>

// 5. C++ 标准库头文件（按字母排序）
#include <algorithm>
#include <memory>
#include <vector>

// 6. C 标准库头文件
#include <cassert>
#include <cmath>
```

### 🏗️ 命名空间使用规范
```cpp
// ✅ 文件级命名空间
namespace radar {
namespace processing {

class DataProcessor : public IDataProcessor {
    // 实现
};

} // namespace processing
} // namespace radar

// ✅ 函数内局部 using 声明
void someFunction() {
    using std::vector;
    using std::unique_ptr;

    vector<float> data;
    unique_ptr<Processor> proc;
}

// ❌ 避免：头文件中的全局 using 声明
// using namespace std;  // 不要在头文件中使用

// ✅ 可接受：源文件中的局部 using
namespace {  // 匿名命名空间，文件内部使用
using namespace radar::processing;
}
```

### 📋 代码分块原则
```cpp
class DataProcessor {
public:
    // ===== 生命周期管理 =====
    DataProcessor(const Config& config);
    ~DataProcessor();
    DataProcessor(const DataProcessor&) = delete;
    DataProcessor& operator=(const DataProcessor&) = delete;

    // ===== 核心接口 =====
    bool initialize() override;
    ProcessingResult process(const RawDataPacket& input) override;
    void cleanup() override;

    // ===== 状态查询 =====
    bool isInitialized() const override;
    ProcessingStats getStatistics() const override;

    // ===== 配置管理 =====
    void updateConfig(const Config& newConfig);
    const Config& getConfig() const;

private:
    // ===== 内部实现方法 =====
    bool initializeGPU();
    void releaseGPUResources();
    bool processOnGPU(const float* input, float* output, size_t size);

    // ===== 数据成员 =====
    Config config_;
    bool initialized_;

    // GPU 相关资源
    float* d_inputBuffer_;
    float* d_outputBuffer_;
    cudaStream_t stream_;

    // 统计信息
    mutable std::mutex statsMutex_;
    ProcessingStats stats_;
};
```

---

## 格式化工具配置

### 🔧 Clang-Format 配置

#### 项目 .clang-format 文件
```yaml
# .clang-format - 项目根目录
Language: Cpp
BasedOnStyle: Google

# 缩进配置
IndentWidth: 4
TabWidth: 4
UseTab: Never
IndentCaseLabels: true
IndentPPDirectives: BeforeHash

# 大括号风格
BreakBeforeBraces: Attach
Cpp11BracedListStyle: true

# 行长度
ColumnLimit: 100
BreakBeforeBinaryOperators: NonAssignment

# 函数格式化
AllowShortFunctionsOnASingleLine: Empty
AllowShortIfStatementsOnASingleLine: false
AllowShortLoopsOnASingleLine: false

# 指针和引用
PointerAlignment: Left
ReferenceAlignment: Left

# 命名空间
NamespaceIndentation: None
CompactNamespaces: false

# 访问修饰符
AccessModifierOffset: -2

# 注释对齐
AlignTrailingComments: true
SpacesBeforeTrailingComments: 2

# 包含文件排序
SortIncludes: true
IncludeBlocks: Regroup
IncludeCategories:
  - Regex: '^".*\.h"$'         # 项目头文件
    Priority: 1
  - Regex: '^<.*\.h>$'         # C 系统头文件
    Priority: 3
  - Regex: '^<.*>$'            # C++ 标准库
    Priority: 4
  - Regex: '.*'                # 其他
    Priority: 2
```

### 🛠️ IDE 集成配置

#### VS Code 配置
```json
// .vscode/settings.json
{
    "C_Cpp.clang_format_style": "file",
    "C_Cpp.clang_format_fallbackStyle": "Google",
    "editor.formatOnSave": true,
    "editor.tabSize": 4,
    "editor.insertSpaces": true,
    "files.trimTrailingWhitespace": true,
    "files.insertFinalNewline": true,

    "C_Cpp.codeAnalysis.clangTidy.enabled": true,
    "C_Cpp.codeAnalysis.runAutomatically": true,

    "editor.rulers": [80, 100],
    "editor.wordWrap": "wordWrapColumn",
    "editor.wordWrapColumn": 100
}
```

#### CLion/Visual Studio 配置
```markdown
CLion 配置：
1. File -> Settings -> Editor -> Code Style -> C/C++
2. 选择 "Set from..." -> "clang-format"
3. 指定项目根目录的 .clang-format 文件

Visual Studio 配置：
1. Tools -> Options -> Text Editor -> C/C++ -> Formatting
2. 选择 "Use clang-format file"
3. 确保项目根目录有 .clang-format 文件
```

### 📊 自动化检查集成

#### Git Hook 集成
```bash
#!/bin/bash
# .git/hooks/pre-commit

# 检查代码格式
files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(cpp|h|cu|cuh)$')

if [ -n "$files" ]; then
    # 检查格式
    for file in $files; do
        clang-format --dry-run --Werror "$file"
        if [ $? -ne 0 ]; then
            echo "代码格式检查失败: $file"
            echo "请运行: clang-format -i $file"
            exit 1
        fi
    done
fi

echo "代码格式检查通过"
```

#### CMake 集成
```cmake
# 添加格式化目标
find_program(CLANG_FORMAT_EXE clang-format)
if(CLANG_FORMAT_EXE)
    file(GLOB_RECURSE SOURCE_FILES
         ${CMAKE_SOURCE_DIR}/src/*.cpp
         ${CMAKE_SOURCE_DIR}/src/*.h
         ${CMAKE_SOURCE_DIR}/include/*.h)

    add_custom_target(format
        COMMAND ${CLANG_FORMAT_EXE} -i ${SOURCE_FILES}
        COMMENT "Formatting source code with clang-format"
    )

    add_custom_target(check-format
        COMMAND ${CLANG_FORMAT_EXE} --dry-run --Werror ${SOURCE_FILES}
        COMMENT "Checking code format with clang-format"
    )
endif()
```

---

## 代码审查要点

### ✅ 格式检查清单

#### 自动检查项目
```markdown
基础格式 ☐
- [ ] 缩进使用 4 个空格，不使用 Tab
- [ ] 行长度不超过 100 字符
- [ ] 文件末尾有换行符
- [ ] 行末没有多余空格

命名规范 ☐
- [ ] 类名使用 PascalCase
- [ ] 函数名使用 camelCase
- [ ] 变量名使用 snake_case 或 camelCase
- [ ] 常量使用 UPPER_SNAKE_CASE

注释格式 ☐
- [ ] 头文件包含文件级 Doxygen 注释
- [ ] 公共接口包含完整的方法注释
- [ ] 复杂逻辑包含适当的内联注释
- [ ] TODO/FIXME 格式规范
```

#### C++17 特性检查
```markdown
现代化使用 ☐
- [ ] 适当使用 auto 关键字
- [ ] 优先使用智能指针管理资源
- [ ] 使用结构化绑定简化代码
- [ ] 使用 STL 算法替代手写循环

CUDA 代码检查 ☐
- [ ] Kernel 函数命名包含 "Kernel" 后缀
- [ ] Device 变量使用 d_ 前缀
- [ ] 包含适当的错误检查
- [ ] 共享内存使用合理
```

### 🚀 性能考虑

#### 性能敏感代码格式
```cpp
// ✅ 性能关键路径：简洁明了
__global__ void criticalKernel(const float* input, float* output, size_t N) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        // 紧凑的处理逻辑
        output[idx] = sqrtf(input[idx] * input[idx] + 1.0f);
    }
}

// ✅ 缓存友好的数据结构布局
struct alignas(16) ProcessingData {
    float real;      // 4 bytes
    float imag;      // 4 bytes
    uint32_t flags;  // 4 bytes
    uint32_t id;     // 4 bytes
};  // 总共 16 bytes，对齐到缓存行
```

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要         |
| :--- | :--------- | :----- | :--------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建代码风格指南 |
