# ä¾èµ–ç®¡ç†ç­–ç•¥

- **æ ‡é¢˜**: AIåä½œå¼€å‘ä¾èµ–ç®¡ç†ç­–ç•¥æŒ‡å—
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## ä¾èµ–ç®¡ç†æ¶æ„

### ğŸ—ï¸ ä¾èµ–å±‚æ¬¡è®¾è®¡

#### åˆ†å±‚ä¾èµ–æ¨¡å‹
```mermaid
graph TB
    subgraph "åº”ç”¨å±‚ (Application Layer)"
        A1[é›·è¾¾åº”ç”¨]
        A2[å·¥å…·ç¨‹åº]
        A3[æµ‹è¯•ç¨‹åº]
    end

    subgraph "ä¸šåŠ¡å±‚ (Business Layer)"
        B1[æ•°æ®å¤„ç†ç®¡é“]
        B2[ä»»åŠ¡è°ƒåº¦å™¨]
        B3[æ˜¾ç¤ºæ§åˆ¶å™¨]
    end

    subgraph "æœåŠ¡å±‚ (Service Layer)"
        S1[æ•°æ®æ¥æ”¶æœåŠ¡]
        S2[GPUå¤„ç†æœåŠ¡]
        S3[åè®®è§£ææœåŠ¡]
        S4[é…ç½®ç®¡ç†æœåŠ¡]
    end

    subgraph "åŸºç¡€å±‚ (Infrastructure Layer)"
        I1[é€šç”¨å·¥å…·åº“]
        I2[æ¥å£å®šä¹‰åº“]
        I3[ç³»ç»ŸæŠ½è±¡å±‚]
    end

    subgraph "ç¬¬ä¸‰æ–¹åº“ (Third-party Libraries)"
        T1[CUDA Runtime]
        T2[YAML-CPP]
        T3[Google Test]
        T4[OpenGL]
        T5[Boost]
    end

    A1 --> B1
    A1 --> B2
    A1 --> B3
    B1 --> S1
    B1 --> S2
    B2 --> S3
    B3 --> S4
    S1 --> I1
    S2 --> I2
    S3 --> I3
    I1 --> T1
    I2 --> T2
    I3 --> T3
    B3 --> T4
    I1 --> T5
```

#### ä¾èµ–åŸåˆ™å’Œçº¦æŸ
```markdown
## æ ¸å¿ƒä¾èµ–åŸåˆ™

### 1. å•å‘ä¾èµ–åŸåˆ™
- ä¸Šå±‚ä¾èµ–ä¸‹å±‚ï¼Œä¸‹å±‚ä¸ä¾èµ–ä¸Šå±‚
- åŒå±‚æ¨¡å—ä¹‹é—´é€šè¿‡æ¥å£é€šä¿¡
- ç¦æ­¢å¾ªç¯ä¾èµ–

### 2. æ¥å£éš”ç¦»åŸåˆ™
- æ¨¡å—åªä¾èµ–éœ€è¦çš„æ¥å£
- æ¥å£å®šä¹‰ä¸å®ç°åˆ†ç¦»
- æœ€å°ä¾èµ–æš´éœ²

### 3. ä¾èµ–å€’ç½®åŸåˆ™
- é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—å…·ä½“å®ç°
- éƒ½ä¾èµ–äºæŠ½è±¡æ¥å£
- æŠ½è±¡ä¸ä¾èµ–ç»†èŠ‚

### 4. ç¨³å®šä¾èµ–åŸåˆ™
- ä¾èµ–ç¨³å®šæ€§é«˜çš„æ¨¡å—
- é¿å…ä¾èµ–é¢‘ç¹å˜åŒ–çš„æ¨¡å—
- æ ¸å¿ƒæ¨¡å—ä¿æŒæ¥å£ç¨³å®š
```

---

## ç¬¬ä¸‰æ–¹åº“ç®¡ç†

### ğŸ“¦ ä¾èµ–åº“åˆ†ç±»ç®¡ç†

#### æ ¸å¿ƒè¿è¡Œæ—¶ä¾èµ–
```cmake
# cmake/CoreDependencies.cmake - æ ¸å¿ƒä¾èµ–é…ç½®

# CUDA - GPUè®¡ç®—æ ¸å¿ƒä¾èµ–
find_package(CUDAToolkit REQUIRED)
if(NOT CUDAToolkit_FOUND)
    message(FATAL_ERROR "CUDA Toolkit is required for GPU processing")
endif()

set(CUDA_LIBRARIES
    CUDA::cudart
    CUDA::cufft
    CUDA::cublas
    CUDA::curand
)

# OpenGL - å›¾å½¢æ¸²æŸ“æ ¸å¿ƒä¾èµ–
find_package(OpenGL REQUIRED)
find_package(glfw3 REQUIRED)
find_package(GLEW REQUIRED)

set(GRAPHICS_LIBRARIES
    OpenGL::GL
    glfw
    GLEW::GLEW
)

# ç½‘ç»œåº“
find_package(Boost REQUIRED COMPONENTS system asio)
set(NETWORK_LIBRARIES
    Boost::system
    Boost::asio
)

# åºåˆ—åŒ–åº“
find_package(PkgConfig REQUIRED)
pkg_check_modules(YAML_CPP REQUIRED yaml-cpp)
```

#### å¼€å‘å’Œæµ‹è¯•ä¾èµ–
```cmake
# cmake/DevelopmentDependencies.cmake - å¼€å‘ä¾èµ–é…ç½®

# æµ‹è¯•æ¡†æ¶
find_package(GTest REQUIRED)
find_package(GMock REQUIRED)

set(TEST_LIBRARIES
    GTest::gtest
    GTest::gtest_main
    GMock::gmock
    GMock::gmock_main
)

# åŸºå‡†æµ‹è¯•
find_package(benchmark REQUIRED)
set(BENCHMARK_LIBRARIES
    benchmark::benchmark
)

# ä»£ç è¦†ç›–ç‡
if(ENABLE_COVERAGE)
    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")
    endif()
endif()

# é™æ€åˆ†æå·¥å…·
find_program(CLANG_TIDY clang-tidy)
if(CLANG_TIDY)
    set(CMAKE_CXX_CLANG_TIDY ${CLANG_TIDY})
endif()

# å†…å­˜æ£€æŸ¥å·¥å…·
find_program(VALGRIND valgrind)
if(VALGRIND)
    set(MEMORYCHECK_COMMAND ${VALGRIND})
    set(MEMORYCHECK_COMMAND_OPTIONS "--leak-check=full --show-reachable=yes")
endif()
```

#### å¯é€‰åŠŸèƒ½ä¾èµ–
```cmake
# cmake/OptionalDependencies.cmake - å¯é€‰ä¾èµ–é…ç½®

# é«˜çº§æ•°å­¦åº“ (å¯é€‰)
find_package(Eigen3 QUIET)
if(Eigen3_FOUND)
    message(STATUS "Eigen3 found - enabling advanced matrix operations")
    add_compile_definitions(RADAR_HAS_EIGEN3)
    set(MATH_LIBRARIES Eigen3::Eigen)
else()
    message(STATUS "Eigen3 not found - using basic matrix operations")
endif()

# Intel MKL (å¯é€‰ï¼Œç”¨äºæ€§èƒ½ä¼˜åŒ–)
find_package(MKL QUIET)
if(MKL_FOUND)
    message(STATUS "Intel MKL found - enabling optimized BLAS/LAPACK")
    add_compile_definitions(RADAR_HAS_MKL)
    set(MATH_LIBRARIES ${MATH_LIBRARIES} ${MKL_LIBRARIES})
endif()

# é«˜æ€§èƒ½ç½‘ç»œåº“ (å¯é€‰)
find_package(dpdk QUIET)
if(dpdk_FOUND)
    message(STATUS "DPDK found - enabling high-performance networking")
    add_compile_definitions(RADAR_HAS_DPDK)
    set(NETWORK_LIBRARIES ${NETWORK_LIBRARIES} dpdk::dpdk)
endif()

# ç¡¬ä»¶åŠ é€Ÿåº“ (å¯é€‰)
find_package(opencl QUIET)
if(opencl_FOUND)
    message(STATUS "OpenCL found - enabling OpenCL acceleration")
    add_compile_definitions(RADAR_HAS_OPENCL)
    set(COMPUTE_LIBRARIES ${COMPUTE_LIBRARIES} OpenCL::OpenCL)
endif()
```

### ğŸ”’ ç‰ˆæœ¬é”å®šç­–ç•¥

#### ä¾èµ–ç‰ˆæœ¬çŸ©é˜µ
```yaml
# dependencies.yaml - ä¾èµ–ç‰ˆæœ¬é…ç½®
dependencies:
  core:
    cuda:
      version: ">=11.0,<13.0"
      reason: "æ”¯æŒçš„CUDAæ¶æ„èŒƒå›´"
      last_updated: "2025-09-10"

    opengl:
      version: ">=4.5"
      reason: "ç°ä»£OpenGLç‰¹æ€§è¦æ±‚"
      last_updated: "2025-09-10"

    boost:
      version: ">=1.75.0"
      reason: "ç½‘ç»œå’Œç³»ç»Ÿåº“ç¨³å®šç‰ˆæœ¬"
      last_updated: "2025-09-10"

    yaml-cpp:
      version: ">=0.7.0"
      reason: "é…ç½®æ–‡ä»¶è§£æå…¼å®¹æ€§"
      last_updated: "2025-09-10"

  development:
    gtest:
      version: ">=1.11.0"
      reason: "æµ‹è¯•æ¡†æ¶ç°ä»£ç‰¹æ€§"
      last_updated: "2025-09-10"

    benchmark:
      version: ">=1.6.0"
      reason: "æ€§èƒ½åŸºå‡†æµ‹è¯•ç¨³å®šæ€§"
      last_updated: "2025-09-10"

  optional:
    eigen3:
      version: ">=3.4.0"
      reason: "ç°ä»£C++ç‰¹æ€§æ”¯æŒ"
      last_updated: "2025-09-10"

    mkl:
      version: ">=2021.0"
      reason: "Intel oneAPIå…¼å®¹æ€§"
      last_updated: "2025-09-10"

# ç‰ˆæœ¬å…¼å®¹æ€§çŸ©é˜µ
compatibility_matrix:
  platforms:
    linux:
      ubuntu: ["20.04", "22.04"]
      centos: ["8", "9"]

    windows:
      versions: ["10", "11"]
      msvc: ["2019", "2022"]

  compilers:
    gcc: ["9", "10", "11", "12"]
    clang: ["12", "13", "14", "15"]
    msvc: ["19.28", "19.30+"]

  cuda_architectures:
    supported: ["6.0", "6.1", "7.0", "7.5", "8.0", "8.6", "8.9"]
    recommended: ["7.5", "8.0", "8.6"]
```

#### ç‰ˆæœ¬éªŒè¯è„šæœ¬
```bash
#!/bin/bash
# scripts/verify_dependencies.sh - ä¾èµ–ç‰ˆæœ¬éªŒè¯

echo "=== éªŒè¯ç³»ç»Ÿä¾èµ– ==="

# è¯»å–ä¾èµ–é…ç½®
DEPS_CONFIG="dependencies.yaml"

verify_cuda() {
    echo "æ£€æŸ¥CUDAç‰ˆæœ¬..."
    if command -v nvcc &> /dev/null; then
        CUDA_VERSION=$(nvcc --version | grep -oE 'V[0-9]+\.[0-9]+' | cut -c2-)
        echo "  å‘ç°CUDAç‰ˆæœ¬: $CUDA_VERSION"

        # æ£€æŸ¥ç‰ˆæœ¬èŒƒå›´
        if [[ $(echo "$CUDA_VERSION >= 11.0" | bc) -eq 1 ]] && [[ $(echo "$CUDA_VERSION < 13.0" | bc) -eq 1 ]]; then
            echo "  âœ… CUDAç‰ˆæœ¬ç¬¦åˆè¦æ±‚"
        else
            echo "  âŒ CUDAç‰ˆæœ¬ä¸ç¬¦åˆè¦æ±‚ (éœ€è¦ >=11.0,<13.0)"
            return 1
        fi
    else
        echo "  âŒ æœªæ‰¾åˆ°CUDAå®‰è£…"
        return 1
    fi
}

verify_opengl() {
    echo "æ£€æŸ¥OpenGLç‰ˆæœ¬..."
    # ä½¿ç”¨glxinfoæ£€æŸ¥OpenGLç‰ˆæœ¬
    if command -v glxinfo &> /dev/null; then
        GL_VERSION=$(glxinfo | grep "OpenGL version" | grep -oE '[0-9]+\.[0-9]+')
        echo "  å‘ç°OpenGLç‰ˆæœ¬: $GL_VERSION"

        if [[ $(echo "$GL_VERSION >= 4.5" | bc) -eq 1 ]]; then
            echo "  âœ… OpenGLç‰ˆæœ¬ç¬¦åˆè¦æ±‚"
        else
            echo "  âŒ OpenGLç‰ˆæœ¬ä¸ç¬¦åˆè¦æ±‚ (éœ€è¦ >=4.5)"
            return 1
        fi
    else
        echo "  âš ï¸  æ— æ³•æ£€æŸ¥OpenGLç‰ˆæœ¬ (glxinfoæœªå®‰è£…)"
    fi
}

verify_boost() {
    echo "æ£€æŸ¥Boostç‰ˆæœ¬..."
    # æ£€æŸ¥pkg-configä¸­çš„Boostç‰ˆæœ¬
    if pkg-config --exists boost; then
        BOOST_VERSION=$(pkg-config --modversion boost)
        echo "  å‘ç°Boostç‰ˆæœ¬: $BOOST_VERSION"

        # ç®€å•çš„ç‰ˆæœ¬æ£€æŸ¥ (å‡è®¾ç‰ˆæœ¬æ ¼å¼ä¸º x.y.z)
        MAJOR=$(echo $BOOST_VERSION | cut -d. -f1)
        MINOR=$(echo $BOOST_VERSION | cut -d. -f2)

        if [[ $MAJOR -gt 1 ]] || [[ $MAJOR -eq 1 && $MINOR -ge 75 ]]; then
            echo "  âœ… Boostç‰ˆæœ¬ç¬¦åˆè¦æ±‚"
        else
            echo "  âŒ Boostç‰ˆæœ¬ä¸ç¬¦åˆè¦æ±‚ (éœ€è¦ >=1.75.0)"
            return 1
        fi
    else
        echo "  âŒ æœªæ‰¾åˆ°Boostå®‰è£…"
        return 1
    fi
}

verify_compiler() {
    echo "æ£€æŸ¥ç¼–è¯‘å™¨ç‰ˆæœ¬..."

    if [[ "$CXX" == *"g++"* ]] || command -v g++ &> /dev/null; then
        GCC_VERSION=$(g++ --version | head -n1 | grep -oE '[0-9]+\.[0-9]+')
        echo "  å‘ç°GCCç‰ˆæœ¬: $GCC_VERSION"

        MAJOR=$(echo $GCC_VERSION | cut -d. -f1)
        if [[ $MAJOR -ge 9 ]]; then
            echo "  âœ… GCCç‰ˆæœ¬ç¬¦åˆè¦æ±‚"
        else
            echo "  âŒ GCCç‰ˆæœ¬ä¸ç¬¦åˆè¦æ±‚ (éœ€è¦ >=9)"
            return 1
        fi
    elif [[ "$CXX" == *"clang"* ]] || command -v clang++ &> /dev/null; then
        CLANG_VERSION=$(clang++ --version | head -n1 | grep -oE '[0-9]+\.[0-9]+')
        echo "  å‘ç°Clangç‰ˆæœ¬: $CLANG_VERSION"

        MAJOR=$(echo $CLANG_VERSION | cut -d. -f1)
        if [[ $MAJOR -ge 12 ]]; then
            echo "  âœ… Clangç‰ˆæœ¬ç¬¦åˆè¦æ±‚"
        else
            echo "  âŒ Clangç‰ˆæœ¬ä¸ç¬¦åˆè¦æ±‚ (éœ€è¦ >=12)"
            return 1
        fi
    else
        echo "  âŒ æœªæ‰¾åˆ°æ”¯æŒçš„C++ç¼–è¯‘å™¨"
        return 1
    fi
}

# æ‰§è¡ŒéªŒè¯
ERRORS=0

verify_cuda || ((ERRORS++))
verify_opengl || ((ERRORS++))
verify_boost || ((ERRORS++))
verify_compiler || ((ERRORS++))

if [[ $ERRORS -eq 0 ]]; then
    echo ""
    echo "âœ… æ‰€æœ‰ä¾èµ–éªŒè¯é€šè¿‡"
    exit 0
else
    echo ""
    echo "âŒ å‘ç° $ERRORS ä¸ªä¾èµ–é—®é¢˜"
    echo "è¯·å‚è€ƒ docs/DEPENDENCIES.md è§£å†³ä¾èµ–é—®é¢˜"
    exit 1
fi
```

---

## æ¨¡å—é—´ä¾èµ–ç®¡ç†

### ğŸ”„ æ¨¡å—ä¾èµ–å›¾

#### ä¾èµ–å…³ç³»å®šä¹‰
```cpp
// include/common/module_registry.h - æ¨¡å—ä¾èµ–æ³¨å†Œ
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <functional>

namespace radar {

// æ¨¡å—ä¾èµ–ä¿¡æ¯
struct ModuleDependency {
    std::string moduleName;
    std::string version;
    bool optional = false;
    std::string reason;

    ModuleDependency(const std::string& name, const std::string& ver,
                    bool opt = false, const std::string& desc = "")
        : moduleName(name), version(ver), optional(opt), reason(desc) {}
};

// æ¨¡å—ä¿¡æ¯
struct ModuleInfo {
    std::string name;
    std::string version;
    std::string description;
    std::vector<ModuleDependency> dependencies;
    std::function<std::shared_ptr<IModule>()> factory;

    ModuleInfo(const std::string& n, const std::string& v, const std::string& d)
        : name(n), version(v), description(d) {}
};

// æ¨¡å—æ³¨å†Œè¡¨
class ModuleRegistry {
public:
    static ModuleRegistry& getInstance();

    // æ¨¡å—æ³¨å†Œ
    void registerModule(const ModuleInfo& moduleInfo);
    void unregisterModule(const std::string& moduleName);

    // ä¾èµ–è§£æ
    std::vector<std::string> resolveDependencies(const std::string& moduleName);
    bool validateDependencies(const std::string& moduleName);
    std::vector<std::string> getCircularDependencies();

    // æ¨¡å—æŸ¥è¯¢
    bool hasModule(const std::string& moduleName) const;
    ModuleInfo getModuleInfo(const std::string& moduleName) const;
    std::vector<std::string> getAllModules() const;
    std::vector<std::string> getDependents(const std::string& moduleName) const;

    // æ¨¡å—åˆ›å»º
    std::shared_ptr<IModule> createModule(const std::string& moduleName);

    // ä¾èµ–å›¾æ“ä½œ
    void generateDependencyGraph(const std::string& outputPath) const;
    std::vector<std::string> getTopologicalOrder() const;

private:
    ModuleRegistry() = default;

    std::unordered_map<std::string, ModuleInfo> modules_;
    mutable std::shared_mutex registryMutex_;

    bool hasCyclicDependency(const std::string& moduleName,
                           std::unordered_set<std::string>& visiting,
                           std::unordered_set<std::string>& visited) const;

    void topologicalSortUtil(const std::string& moduleName,
                           std::unordered_set<std::string>& visited,
                           std::stack<std::string>& stack) const;
};

// æ¨¡å—æ³¨å†Œå®
#define REGISTER_MODULE(ModuleClass, ModuleName, ModuleVersion, ModuleDescription) \
namespace { \
    struct ModuleClass##Registrar { \
        ModuleClass##Registrar() { \
            ModuleInfo info(ModuleName, ModuleVersion, ModuleDescription); \
            info.factory = []() -> std::shared_ptr<IModule> { \
                return std::make_shared<ModuleClass>(); \
            }; \
            ModuleRegistry::getInstance().registerModule(info); \
        } \
    }; \
    static ModuleClass##Registrar g_##ModuleClass##Registrar; \
}

// ä¾èµ–å£°æ˜å®
#define DECLARE_DEPENDENCY(ModuleName, DependencyName, DependencyVersion, Optional, Reason) \
namespace { \
    struct Dependency##ModuleName##DependencyName { \
        Dependency##ModuleName##DependencyName() { \
            auto& registry = ModuleRegistry::getInstance(); \
            if (registry.hasModule(ModuleName)) { \
                auto info = registry.getModuleInfo(ModuleName); \
                info.dependencies.emplace_back(DependencyName, DependencyVersion, Optional, Reason); \
                registry.registerModule(info); \
            } \
        } \
    }; \
    static Dependency##ModuleName##DependencyName g_dependency##ModuleName##DependencyName; \
}

} // namespace radar
```

#### ä¾èµ–è§£æå®ç°
```cpp
// src/common/module_registry.cpp - ä¾èµ–è§£æå®ç°

#include "common/module_registry.h"
#include <stack>
#include <queue>
#include <fstream>
#include <algorithm>

namespace radar {

std::vector<std::string> ModuleRegistry::resolveDependencies(const std::string& moduleName) {
    std::shared_lock<std::shared_mutex> lock(registryMutex_);

    std::vector<std::string> resolvedOrder;
    std::unordered_set<std::string> visited;
    std::unordered_set<std::string> visiting;

    if (!resolveDependenciesRecursive(moduleName, visited, visiting, resolvedOrder)) {
        throw std::runtime_error("Circular dependency detected for module: " + moduleName);
    }

    return resolvedOrder;
}

bool ModuleRegistry::resolveDependenciesRecursive(
    const std::string& moduleName,
    std::unordered_set<std::string>& visited,
    std::unordered_set<std::string>& visiting,
    std::vector<std::string>& resolvedOrder) {

    if (visiting.find(moduleName) != visiting.end()) {
        return false; // å¾ªç¯ä¾èµ–
    }

    if (visited.find(moduleName) != visited.end()) {
        return true; // å·²å¤„ç†
    }

    visiting.insert(moduleName);

    auto it = modules_.find(moduleName);
    if (it != modules_.end()) {
        // é€’å½’å¤„ç†ä¾èµ–
        for (const auto& dep : it->second.dependencies) {
            if (!dep.optional || hasModule(dep.moduleName)) {
                if (!resolveDependenciesRecursive(dep.moduleName, visited, visiting, resolvedOrder)) {
                    return false;
                }
            }
        }
    }

    visiting.erase(moduleName);
    visited.insert(moduleName);
    resolvedOrder.push_back(moduleName);

    return true;
}

bool ModuleRegistry::validateDependencies(const std::string& moduleName) {
    std::shared_lock<std::shared_mutex> lock(registryMutex_);

    auto it = modules_.find(moduleName);
    if (it == modules_.end()) {
        return false;
    }

    for (const auto& dep : it->second.dependencies) {
        if (!dep.optional && !hasModule(dep.moduleName)) {
            return false;
        }

        // ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
        if (hasModule(dep.moduleName)) {
            auto depInfo = getModuleInfo(dep.moduleName);
            if (!isVersionCompatible(depInfo.version, dep.version)) {
                return false;
            }
        }
    }

    return true;
}

void ModuleRegistry::generateDependencyGraph(const std::string& outputPath) const {
    std::shared_lock<std::shared_mutex> lock(registryMutex_);

    std::ofstream file(outputPath);
    file << "digraph DependencyGraph {\n";
    file << "  rankdir=TB;\n";
    file << "  node [shape=box, style=rounded];\n\n";

    // ç”ŸæˆèŠ‚ç‚¹
    for (const auto& [name, info] : modules_) {
        file << "  \"" << name << "\" [label=\"" << name << "\\n" << info.version << "\"];\n";
    }

    file << "\n";

    // ç”Ÿæˆè¾¹
    for (const auto& [name, info] : modules_) {
        for (const auto& dep : info.dependencies) {
            std::string style = dep.optional ? " [style=dashed]" : "";
            file << "  \"" << name << "\" -> \"" << dep.moduleName << "\"" << style << ";\n";
        }
    }

    file << "}\n";
    file.close();
}

} // namespace radar
```

### ğŸ”§ è¿è¡Œæ—¶ä¾èµ–æ³¨å…¥

#### ä¾èµ–æ³¨å…¥å®¹å™¨
```cpp
// include/common/dependency_injection.h - ä¾èµ–æ³¨å…¥å®¹å™¨
#pragma once

#include <memory>
#include <unordered_map>
#include <typeindex>
#include <functional>
#include <mutex>

namespace radar {

// ç”Ÿå‘½å‘¨æœŸæšä¸¾
enum class Lifetime {
    Transient,  // æ¯æ¬¡åˆ›å»ºæ–°å®ä¾‹
    Singleton,  // å•ä¾‹æ¨¡å¼
    Scoped      // ä½œç”¨åŸŸå†…å•ä¾‹
};

// ä¾èµ–æ³¨å…¥å®¹å™¨
class DIContainer {
public:
    // æ³¨å†ŒæœåŠ¡
    template<typename TInterface, typename TImplementation>
    void registerService(Lifetime lifetime = Lifetime::Transient);

    template<typename TInterface>
    void registerFactory(std::function<std::shared_ptr<TInterface>()> factory,
                        Lifetime lifetime = Lifetime::Transient);

    template<typename TInterface>
    void registerInstance(std::shared_ptr<TInterface> instance);

    // è§£ææœåŠ¡
    template<typename T>
    std::shared_ptr<T> resolve();

    template<typename T>
    bool canResolve() const;

    // ä½œç”¨åŸŸç®¡ç†
    class Scope {
    public:
        Scope(DIContainer& container);
        ~Scope();

        template<typename T>
        std::shared_ptr<T> resolve();

    private:
        DIContainer& container_;
        std::unordered_map<std::type_index, std::shared_ptr<void>> scopedInstances_;
    };

    std::unique_ptr<Scope> createScope();

    // å®¹å™¨ç®¡ç†
    void clear();
    std::vector<std::type_index> getRegisteredTypes() const;

private:
    struct ServiceDescriptor {
        std::function<std::shared_ptr<void>()> factory;
        Lifetime lifetime;
        std::shared_ptr<void> instance; // ç”¨äºå•ä¾‹
    };

    mutable std::shared_mutex servicesMutex_;
    std::unordered_map<std::type_index, ServiceDescriptor> services_;

    template<typename T>
    std::shared_ptr<T> resolveInternal();
};

// æ¨¡æ¿å®ç°
template<typename TInterface, typename TImplementation>
void DIContainer::registerService(Lifetime lifetime) {
    static_assert(std::is_base_of_v<TInterface, TImplementation>,
                  "TImplementation must inherit from TInterface");

    std::unique_lock<std::shared_mutex> lock(servicesMutex_);

    auto factory = []() -> std::shared_ptr<void> {
        return std::static_pointer_cast<void>(std::make_shared<TImplementation>());
    };

    services_[std::type_index(typeid(TInterface))] = {factory, lifetime, nullptr};
}

template<typename T>
std::shared_ptr<T> DIContainer::resolve() {
    return resolveInternal<T>();
}

template<typename T>
std::shared_ptr<T> DIContainer::resolveInternal() {
    std::shared_lock<std::shared_mutex> lock(servicesMutex_);

    auto it = services_.find(std::type_index(typeid(T)));
    if (it == services_.end()) {
        throw std::runtime_error("Service not registered: " + std::string(typeid(T).name()));
    }

    auto& descriptor = it->second;

    switch (descriptor.lifetime) {
        case Lifetime::Transient:
            return std::static_pointer_cast<T>(descriptor.factory());

        case Lifetime::Singleton:
            if (!descriptor.instance) {
                lock.unlock();
                std::unique_lock<std::shared_mutex> writeLock(servicesMutex_);
                if (!descriptor.instance) {
                    descriptor.instance = descriptor.factory();
                }
            }
            return std::static_pointer_cast<T>(descriptor.instance);

        case Lifetime::Scoped:
            // ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸç”±Scopeç±»ç®¡ç†
            return std::static_pointer_cast<T>(descriptor.factory());
    }

    throw std::runtime_error("Unknown lifetime for service: " + std::string(typeid(T).name()));
}

} // namespace radar
```

#### è‡ªåŠ¨ä¾èµ–æ³¨å…¥é…ç½®
```cpp
// src/application/dependency_configuration.cpp - ä¾èµ–é…ç½®
#include "common/dependency_injection.h"
#include "interfaces/data_receiver_interface.h"
#include "interfaces/gpu_processor_interface.h"
#include "interfaces/display_controller_interface.h"
#include "modules/data_receiver/udp_receiver.h"
#include "modules/gpu_processor/cuda_processor.h"
#include "modules/display_control/opengl_controller.h"

namespace radar {

class DependencyConfiguration {
public:
    static void configureServices(DIContainer& container) {
        // æ³¨å†Œæ•°æ®æ¥æ”¶æœåŠ¡
        container.registerService<IDataReceiver, UDPReceiver>(Lifetime::Singleton);

        // æ³¨å†ŒGPUå¤„ç†æœåŠ¡
        container.registerService<IGPUProcessor, CUDAProcessor>(Lifetime::Singleton);

        // æ³¨å†Œæ˜¾ç¤ºæ§åˆ¶æœåŠ¡
        container.registerService<IDisplayController, OpenGLController>(Lifetime::Singleton);

        // æ³¨å†Œé…ç½®ç®¡ç†æœåŠ¡
        container.registerFactory<IConfigurationManager>([]() {
            return std::shared_ptr<IConfigurationManager>(&ConfigurationManager::getInstance(),
                                                         [](IConfigurationManager*) {});
        }, Lifetime::Singleton);

        // æ³¨å†Œæ—¥å¿—æœåŠ¡
        container.registerFactory<ILogger>([]() {
            return LoggerFactory::createLogger("radar");
        }, Lifetime::Singleton);

        // æ³¨å†Œæ€§èƒ½ç›‘æ§æœåŠ¡
        container.registerService<IPerformanceMonitor, PerformanceMonitor>(Lifetime::Singleton);

        // æ³¨å†Œæ•°æ®ç®¡é“æœåŠ¡
        container.registerFactory<IDataPipeline>([&container]() {
            auto pipeline = std::make_shared<DataPipeline>();

            // è‡ªåŠ¨æ³¨å…¥ä¾èµ–
            auto receiver = container.resolve<IDataReceiver>();
            auto processor = container.resolve<IGPUProcessor>();
            auto monitor = container.resolve<IPerformanceMonitor>();

            pipeline->setDataReceiver(receiver);
            pipeline->setDataProcessor(processor);
            pipeline->setPerformanceMonitor(monitor);

            return pipeline;
        }, Lifetime::Singleton);
    }

    static void configureTestServices(DIContainer& container) {
        // æ³¨å†Œæµ‹è¯•ç”¨Mockå¯¹è±¡
        container.registerService<IDataReceiver, MockDataReceiver>(Lifetime::Transient);
        container.registerService<IGPUProcessor, MockGPUProcessor>(Lifetime::Transient);
        container.registerService<IDisplayController, MockDisplayController>(Lifetime::Transient);

        // æ³¨å†Œæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
        container.registerService<ITestDataGenerator, TestDataGenerator>(Lifetime::Singleton);
    }
};

} // namespace radar
```

---

## æ„å»ºç³»ç»Ÿä¾èµ–ç®¡ç†

### ğŸ—ï¸ CMakeä¾èµ–ç®¡ç†

#### è‡ªåŠ¨ä¾èµ–æ£€æµ‹
```cmake
# cmake/AutoDependencyDetection.cmake - è‡ªåŠ¨ä¾èµ–æ£€æµ‹

function(detect_and_configure_dependencies)
    message(STATUS "å¼€å§‹è‡ªåŠ¨æ£€æµ‹ä¾èµ–...")

    # æ£€æµ‹ç³»ç»Ÿç±»å‹
    detect_system_info()

    # æ£€æµ‹æ ¸å¿ƒä¾èµ–
    detect_core_dependencies()

    # æ£€æµ‹å¯é€‰ä¾èµ–
    detect_optional_dependencies()

    # ç”Ÿæˆä¾èµ–æŠ¥å‘Š
    generate_dependency_report()

    message(STATUS "ä¾èµ–æ£€æµ‹å®Œæˆ")
endfunction()

function(detect_system_info)
    # æ£€æµ‹æ“ä½œç³»ç»Ÿ
    if(WIN32)
        set(RADAR_PLATFORM "Windows" PARENT_SCOPE)
    elseif(UNIX AND NOT APPLE)
        set(RADAR_PLATFORM "Linux" PARENT_SCOPE)
    elseif(APPLE)
        set(RADAR_PLATFORM "macOS" PARENT_SCOPE)
    endif()

    # æ£€æµ‹CPUæ¶æ„
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64|AMD64")
        set(RADAR_ARCH "x64" PARENT_SCOPE)
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64")
        set(RADAR_ARCH "arm64" PARENT_SCOPE)
    endif()

    message(STATUS "å¹³å°: ${RADAR_PLATFORM}, æ¶æ„: ${RADAR_ARCH}")
endfunction()

function(detect_core_dependencies)
    # CUDAæ£€æµ‹
    find_package(CUDAToolkit QUIET)
    if(CUDAToolkit_FOUND)
        set(RADAR_HAS_CUDA TRUE PARENT_SCOPE)
        set(RADAR_CUDA_VERSION "${CUDAToolkit_VERSION}" PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°CUDA: ${CUDAToolkit_VERSION}")

        # æ£€æµ‹CUDAæ¶æ„
        include(FindCUDA/select_compute_arch)
        CUDA_DETECT_INSTALLED_GPUS(INSTALLED_GPU_CCS_1)
        string(STRIP "${INSTALLED_GPU_CCS_1}" INSTALLED_GPU_CCS_2)
        string(REPLACE " " ";" INSTALLED_GPU_CCS_3 "${INSTALLED_GPU_CCS_2}")
        string(REPLACE "." "" CUDA_ARCH_LIST "${INSTALLED_GPU_CCS_3}")
        set(RADAR_CUDA_ARCHITECTURES "${CUDA_ARCH_LIST}" PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°CUDAæ¶æ„: ${CUDA_ARCH_LIST}")
    else()
        message(WARNING "æœªæ£€æµ‹åˆ°CUDA - GPUåŠŸèƒ½å°†è¢«ç¦ç”¨")
        set(RADAR_HAS_CUDA FALSE PARENT_SCOPE)
    endif()

    # OpenGLæ£€æµ‹
    find_package(OpenGL QUIET)
    if(OpenGL_FOUND)
        set(RADAR_HAS_OPENGL TRUE PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°OpenGL")
    else()
        message(WARNING "æœªæ£€æµ‹åˆ°OpenGL - å›¾å½¢åŠŸèƒ½å°†è¢«ç¦ç”¨")
        set(RADAR_HAS_OPENGL FALSE PARENT_SCOPE)
    endif()

    # Boostæ£€æµ‹
    find_package(Boost QUIET COMPONENTS system filesystem thread)
    if(Boost_FOUND)
        set(RADAR_HAS_BOOST TRUE PARENT_SCOPE)
        set(RADAR_BOOST_VERSION "${Boost_VERSION}" PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°Boost: ${Boost_VERSION}")
    else()
        message(FATAL_ERROR "æœªæ‰¾åˆ°Booståº“ - è¿™æ˜¯å¿…éœ€çš„ä¾èµ–")
    endif()
endfunction()

function(detect_optional_dependencies)
    # Intel MKLæ£€æµ‹
    find_package(MKL QUIET)
    if(MKL_FOUND)
        set(RADAR_HAS_MKL TRUE PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°Intel MKL - å¯ç”¨ä¼˜åŒ–æ•°å­¦åº“")
    endif()

    # Eigen3æ£€æµ‹
    find_package(Eigen3 QUIET)
    if(Eigen3_FOUND)
        set(RADAR_HAS_EIGEN3 TRUE PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°Eigen3 - å¯ç”¨é«˜çº§çŸ©é˜µè¿ç®—")
    endif()

    # OpenMPæ£€æµ‹
    find_package(OpenMP QUIET)
    if(OpenMP_FOUND)
        set(RADAR_HAS_OPENMP TRUE PARENT_SCOPE)
        message(STATUS "æ£€æµ‹åˆ°OpenMP - å¯ç”¨å¹¶è¡Œè®¡ç®—")
    endif()
endfunction()

function(generate_dependency_report)
    set(REPORT_FILE "${CMAKE_BINARY_DIR}/dependency_report.txt")

    file(WRITE ${REPORT_FILE} "é›·è¾¾ç³»ç»Ÿä¾èµ–æŠ¥å‘Š\n")
    file(APPEND ${REPORT_FILE} "================\n\n")

    file(APPEND ${REPORT_FILE} "ç³»ç»Ÿä¿¡æ¯:\n")
    file(APPEND ${REPORT_FILE} "  å¹³å°: ${RADAR_PLATFORM}\n")
    file(APPEND ${REPORT_FILE} "  æ¶æ„: ${RADAR_ARCH}\n")
    file(APPEND ${REPORT_FILE} "  ç¼–è¯‘å™¨: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}\n\n")

    file(APPEND ${REPORT_FILE} "æ ¸å¿ƒä¾èµ–:\n")
    if(RADAR_HAS_CUDA)
        file(APPEND ${REPORT_FILE} "  âœ… CUDA: ${RADAR_CUDA_VERSION}\n")
        file(APPEND ${REPORT_FILE} "     æ¶æ„: ${RADAR_CUDA_ARCHITECTURES}\n")
    else()
        file(APPEND ${REPORT_FILE} "  âŒ CUDA: æœªæ‰¾åˆ°\n")
    endif()

    if(RADAR_HAS_OPENGL)
        file(APPEND ${REPORT_FILE} "  âœ… OpenGL: å¯ç”¨\n")
    else()
        file(APPEND ${REPORT_FILE} "  âŒ OpenGL: æœªæ‰¾åˆ°\n")
    endif()

    if(RADAR_HAS_BOOST)
        file(APPEND ${REPORT_FILE} "  âœ… Boost: ${RADAR_BOOST_VERSION}\n")
    else()
        file(APPEND ${REPORT_FILE} "  âŒ Boost: æœªæ‰¾åˆ°\n")
    endif()

    file(APPEND ${REPORT_FILE} "\nå¯é€‰ä¾èµ–:\n")
    if(RADAR_HAS_MKL)
        file(APPEND ${REPORT_FILE} "  âœ… Intel MKL: å¯ç”¨\n")
    else()
        file(APPEND ${REPORT_FILE} "  âšª Intel MKL: æœªæ‰¾åˆ°\n")
    endif()

    if(RADAR_HAS_EIGEN3)
        file(APPEND ${REPORT_FILE} "  âœ… Eigen3: å¯ç”¨\n")
    else()
        file(APPEND ${REPORT_FILE} "  âšª Eigen3: æœªæ‰¾åˆ°\n")
    endif()

    if(RADAR_HAS_OPENMP)
        file(APPEND ${REPORT_FILE} "  âœ… OpenMP: å¯ç”¨\n")
    else()
        file(APPEND ${REPORT_FILE} "  âšª OpenMP: æœªæ‰¾åˆ°\n")
    endif()

    message(STATUS "ä¾èµ–æŠ¥å‘Šå·²ç”Ÿæˆ: ${REPORT_FILE}")
endfunction()
```

#### ä¾èµ–å†²çªè§£å†³
```cmake
# cmake/ConflictResolution.cmake - ä¾èµ–å†²çªè§£å†³

function(resolve_dependency_conflicts)
    message(STATUS "æ£€æŸ¥ä¾èµ–å†²çª...")

    # è§£å†³Boostç‰ˆæœ¬å†²çª
    resolve_boost_conflicts()

    # è§£å†³CUDAç‰ˆæœ¬å†²çª
    resolve_cuda_conflicts()

    # è§£å†³ç¼–è¯‘å™¨å†²çª
    resolve_compiler_conflicts()

    message(STATUS "ä¾èµ–å†²çªæ£€æŸ¥å®Œæˆ")
endfunction()

function(resolve_boost_conflicts)
    # æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦æœ‰å¤šä¸ªBoostç‰ˆæœ¬
    if(Boost_FOUND)
        get_target_property(BOOST_INCLUDE_DIRS Boost::boost INTERFACE_INCLUDE_DIRECTORIES)

        # æ£€æŸ¥æ˜¯å¦æœ‰å†²çªçš„Boostç‰ˆæœ¬
        find_path(SYSTEM_BOOST_INCLUDE boost/version.hpp
                 PATHS /usr/include /usr/local/include
                 NO_DEFAULT_PATH)

        if(SYSTEM_BOOST_INCLUDE AND NOT SYSTEM_BOOST_INCLUDE STREQUAL BOOST_INCLUDE_DIRS)
            message(WARNING "æ£€æµ‹åˆ°å¤šä¸ªBoostç‰ˆæœ¬:")
            message(WARNING "  ä½¿ç”¨ç‰ˆæœ¬: ${Boost_VERSION} (${BOOST_INCLUDE_DIRS})")
            message(WARNING "  ç³»ç»Ÿç‰ˆæœ¬: ${SYSTEM_BOOST_INCLUDE}")
            message(WARNING "å»ºè®®å¸è½½å†²çªçš„Boostç‰ˆæœ¬ä»¥é¿å…é“¾æ¥é”™è¯¯")
        endif()
    endif()
endfunction()

function(resolve_cuda_conflicts)
    if(RADAR_HAS_CUDA)
        # æ£€æŸ¥CUDAç‰ˆæœ¬å…¼å®¹æ€§
        if(CUDAToolkit_VERSION VERSION_LESS "11.0")
            message(FATAL_ERROR "CUDAç‰ˆæœ¬è¿‡ä½: ${CUDAToolkit_VERSION}, éœ€è¦ >= 11.0")
        endif()

        if(CUDAToolkit_VERSION VERSION_GREATER_EQUAL "13.0")
            message(WARNING "CUDAç‰ˆæœ¬è¾ƒæ–°: ${CUDAToolkit_VERSION}, å¯èƒ½å­˜åœ¨å…¼å®¹æ€§é—®é¢˜")
        endif()

        # æ£€æŸ¥CUDAä¸ç¼–è¯‘å™¨å…¼å®¹æ€§
        if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
            if(CMAKE_CXX_COMPILER_VERSION VERSION_GREATER "12.0" AND
               CUDAToolkit_VERSION VERSION_LESS "12.0")
                message(WARNING "GCCç‰ˆæœ¬å¯èƒ½ä¸CUDAä¸å…¼å®¹:")
                message(WARNING "  GCC: ${CMAKE_CXX_COMPILER_VERSION}")
                message(WARNING "  CUDA: ${CUDAToolkit_VERSION}")
            endif()
        endif()
    endif()
endfunction()

function(resolve_compiler_conflicts)
    # æ£€æŸ¥ç¼–è¯‘å™¨ç‰ˆæœ¬
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "9.0")
            message(FATAL_ERROR "GCCç‰ˆæœ¬è¿‡ä½: ${CMAKE_CXX_COMPILER_VERSION}, éœ€è¦ >= 9.0")
        endif()
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "12.0")
            message(FATAL_ERROR "Clangç‰ˆæœ¬è¿‡ä½: ${CMAKE_CXX_COMPILER_VERSION}, éœ€è¦ >= 12.0")
        endif()
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
        if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "19.28")
            message(FATAL_ERROR "MSVCç‰ˆæœ¬è¿‡ä½: ${CMAKE_CXX_COMPILER_VERSION}, éœ€è¦ >= 19.28")
        endif()
    endif()

    # æ£€æŸ¥C++æ ‡å‡†æ”¯æŒ
    if(CMAKE_CXX_STANDARD LESS 17)
        message(FATAL_ERROR "éœ€è¦C++17æˆ–æ›´é«˜ç‰ˆæœ¬")
    endif()
endfunction()
```

---

## ä¾èµ–ç›‘æ§å’Œç»´æŠ¤

### ğŸ“Š ä¾èµ–å¥åº·ç›‘æ§

#### ä¾èµ–ç›‘æ§ç³»ç»Ÿ
```cpp
// include/common/dependency_monitor.h - ä¾èµ–ç›‘æ§ç³»ç»Ÿ
#pragma once

#include <string>
#include <vector>
#include <chrono>
#include <memory>
#include <functional>

namespace radar {

// ä¾èµ–çŠ¶æ€
enum class DependencyStatus {
    Healthy,        // æ­£å¸¸
    Warning,        // è­¦å‘Š
    Critical,       // ä¸¥é‡
    Unavailable     // ä¸å¯ç”¨
};

// ä¾èµ–å¥åº·ä¿¡æ¯
struct DependencyHealth {
    std::string name;
    DependencyStatus status;
    std::string version;
    std::chrono::milliseconds responseTime;
    double cpuUsage;
    double memoryUsage;
    uint64_t errorCount;
    std::string lastError;
    std::chrono::system_clock::time_point lastCheck;

    bool isHealthy() const { return status == DependencyStatus::Healthy; }
    bool needsAttention() const { return status >= DependencyStatus::Warning; }
};

// ä¾èµ–ç›‘æ§æ¥å£
class IDependencyMonitor {
public:
    virtual ~IDependencyMonitor() = default;

    // ç›‘æ§ç®¡ç†
    virtual void startMonitoring() = 0;
    virtual void stopMonitoring() = 0;
    virtual bool isMonitoring() const = 0;

    // å¥åº·æ£€æŸ¥
    virtual DependencyHealth checkDependency(const std::string& name) = 0;
    virtual std::vector<DependencyHealth> checkAllDependencies() = 0;

    // ç›‘æ§é…ç½®
    virtual void setCheckInterval(std::chrono::seconds interval) = 0;
    virtual void addDependency(const std::string& name,
                              std::function<DependencyHealth()> healthChecker) = 0;
    virtual void removeDependency(const std::string& name) = 0;

    // äº‹ä»¶å¤„ç†
    using HealthChangeCallback = std::function<void(const DependencyHealth&)>;
    virtual void onHealthChange(HealthChangeCallback callback) = 0;

    // ç»Ÿè®¡ä¿¡æ¯
    virtual std::vector<DependencyHealth> getHealthHistory(
        const std::string& name,
        std::chrono::hours duration) = 0;
    virtual double getOverallHealthScore() const = 0;
};

// ä¾èµ–ç›‘æ§å®ç°
class DependencyMonitor : public IDependencyMonitor {
public:
    DependencyMonitor();
    virtual ~DependencyMonitor();

    // IDependencyMonitoræ¥å£å®ç°
    void startMonitoring() override;
    void stopMonitoring() override;
    bool isMonitoring() const override;

    DependencyHealth checkDependency(const std::string& name) override;
    std::vector<DependencyHealth> checkAllDependencies() override;

    void setCheckInterval(std::chrono::seconds interval) override;
    void addDependency(const std::string& name,
                      std::function<DependencyHealth()> healthChecker) override;
    void removeDependency(const std::string& name) override;

    void onHealthChange(HealthChangeCallback callback) override;

    std::vector<DependencyHealth> getHealthHistory(
        const std::string& name,
        std::chrono::hours duration) override;
    double getOverallHealthScore() const override;

private:
    struct DependencyInfo {
        std::string name;
        std::function<DependencyHealth()> healthChecker;
        std::vector<DependencyHealth> history;
        DependencyHealth lastHealth;
    };

    std::unordered_map<std::string, DependencyInfo> dependencies_;
    std::vector<HealthChangeCallback> callbacks_;
    std::chrono::seconds checkInterval_;

    std::atomic<bool> monitoring_;
    std::thread monitoringThread_;
    mutable std::shared_mutex dependenciesMutex_;

    void monitoringLoop();
    void notifyHealthChange(const DependencyHealth& health);
    void cleanupHistory();
};

} // namespace radar
```

#### å†…ç½®ä¾èµ–æ£€æŸ¥å™¨
```cpp
// src/common/builtin_dependency_checkers.cpp - å†…ç½®ä¾èµ–æ£€æŸ¥å™¨
#include "common/dependency_monitor.h"
#include <cuda_runtime.h>
#include <GL/gl.h>
#include <boost/version.hpp>

namespace radar {

class BuiltinDependencyCheckers {
public:
    static void registerAll(DependencyMonitor& monitor) {
        monitor.addDependency("CUDA", checkCUDA);
        monitor.addDependency("OpenGL", checkOpenGL);
        monitor.addDependency("Boost", checkBoost);
        monitor.addDependency("System Memory", checkSystemMemory);
        monitor.addDependency("Disk Space", checkDiskSpace);
    }

private:
    static DependencyHealth checkCUDA() {
        DependencyHealth health;
        health.name = "CUDA";
        health.lastCheck = std::chrono::system_clock::now();

        auto start = std::chrono::high_resolution_clock::now();

        try {
            int deviceCount;
            cudaError_t error = cudaGetDeviceCount(&deviceCount);

            if (error != cudaSuccess) {
                health.status = DependencyStatus::Critical;
                health.lastError = cudaGetErrorString(error);
                return health;
            }

            if (deviceCount == 0) {
                health.status = DependencyStatus::Critical;
                health.lastError = "No CUDA devices found";
                return health;
            }

            // æ£€æŸ¥è®¾å¤‡å±æ€§
            cudaDeviceProp prop;
            cudaGetDeviceProperties(&prop, 0);

            // æ£€æŸ¥å†…å­˜ä½¿ç”¨
            size_t free, total;
            cudaMemGetInfo(&free, &total);
            health.memoryUsage = (double)(total - free) / total * 100.0;

            // æ£€æŸ¥æ€§èƒ½
            auto end = std::chrono::high_resolution_clock::now();
            health.responseTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

            health.version = std::to_string(prop.major) + "." + std::to_string(prop.minor);

            if (health.memoryUsage > 90.0) {
                health.status = DependencyStatus::Warning;
                health.lastError = "GPU memory usage high: " + std::to_string(health.memoryUsage) + "%";
            } else {
                health.status = DependencyStatus::Healthy;
            }

        } catch (const std::exception& e) {
            health.status = DependencyStatus::Critical;
            health.lastError = e.what();
        }

        return health;
    }

    static DependencyHealth checkOpenGL() {
        DependencyHealth health;
        health.name = "OpenGL";
        health.lastCheck = std::chrono::system_clock::now();

        auto start = std::chrono::high_resolution_clock::now();

        try {
            // ç®€å•çš„OpenGLä¸Šä¸‹æ–‡æ£€æŸ¥
            GLenum error = glGetError();
            if (error != GL_NO_ERROR) {
                health.status = DependencyStatus::Warning;
                health.lastError = "OpenGL error: " + std::to_string(error);
            } else {
                health.status = DependencyStatus::Healthy;
            }

            const GLubyte* version = glGetString(GL_VERSION);
            if (version) {
                health.version = reinterpret_cast<const char*>(version);
            }

            auto end = std::chrono::high_resolution_clock::now();
            health.responseTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

        } catch (const std::exception& e) {
            health.status = DependencyStatus::Critical;
            health.lastError = e.what();
        }

        return health;
    }

    static DependencyHealth checkBoost() {
        DependencyHealth health;
        health.name = "Boost";
        health.version = BOOST_LIB_VERSION;
        health.status = DependencyStatus::Healthy;
        health.lastCheck = std::chrono::system_clock::now();
        health.responseTime = std::chrono::milliseconds(0);

        return health;
    }

    static DependencyHealth checkSystemMemory() {
        DependencyHealth health;
        health.name = "System Memory";
        health.lastCheck = std::chrono::system_clock::now();

        // è·å–ç³»ç»Ÿå†…å­˜ä¿¡æ¯ (Linuxç¤ºä¾‹)
        std::ifstream meminfo("/proc/meminfo");
        if (meminfo.is_open()) {
            std::string line;
            size_t totalMem = 0, availMem = 0;

            while (std::getline(meminfo, line)) {
                if (line.substr(0, 9) == "MemTotal:") {
                    totalMem = std::stoull(line.substr(10)) * 1024; // KB to bytes
                } else if (line.substr(0, 12) == "MemAvailable:") {
                    availMem = std::stoull(line.substr(13)) * 1024; // KB to bytes
                }
            }

            if (totalMem > 0) {
                health.memoryUsage = (double)(totalMem - availMem) / totalMem * 100.0;

                if (health.memoryUsage > 90.0) {
                    health.status = DependencyStatus::Critical;
                    health.lastError = "System memory critically low";
                } else if (health.memoryUsage > 80.0) {
                    health.status = DependencyStatus::Warning;
                    health.lastError = "System memory usage high";
                } else {
                    health.status = DependencyStatus::Healthy;
                }
            }
        }

        return health;
    }

    static DependencyHealth checkDiskSpace() {
        DependencyHealth health;
        health.name = "Disk Space";
        health.lastCheck = std::chrono::system_clock::now();

        try {
            namespace fs = std::filesystem;
            auto space = fs::space(".");

            double usagePercent = (double)(space.capacity - space.available) / space.capacity * 100.0;

            if (usagePercent > 95.0) {
                health.status = DependencyStatus::Critical;
                health.lastError = "Disk space critically low";
            } else if (usagePercent > 85.0) {
                health.status = DependencyStatus::Warning;
                health.lastError = "Disk space usage high";
            } else {
                health.status = DependencyStatus::Healthy;
            }

        } catch (const std::exception& e) {
            health.status = DependencyStatus::Critical;
            health.lastError = e.what();
        }

        return health;
    }
};

} // namespace radar
```

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦             |
| :--- | :--------- | :----- | :------------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºä¾èµ–ç®¡ç†ç­–ç•¥æŒ‡å— |
