# æ–‡ä»¶åˆ›å»ºé¡ºåº

- **æ ‡é¢˜**: AIåä½œå¼€å‘æ–‡ä»¶åˆ›å»ºé¡ºåºæŒ‡å—
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## æ–‡ä»¶åˆ›å»ºå±‚æ¬¡ç»“æ„

### ğŸ—ï¸ åˆ›å»ºé¡ºåºåŸåˆ™

#### åŸåˆ™1ï¼šä¾èµ–å…³ç³»ä¼˜å…ˆ
```mermaid
graph TD
    A[åŸºç¡€ç±»å‹å®šä¹‰] --> B[æ¥å£å®šä¹‰]
    B --> C[åŸºç¡€å®ç°ç±»]
    C --> D[å¤åˆç»„ä»¶]
    D --> E[åº”ç”¨å±‚ä»£ç ]
    E --> F[é…ç½®å’Œæµ‹è¯•]

    subgraph "åŸºç¡€å±‚"
        A1[constants.h]
        A2[types.h]
        A3[error_codes.h]
    end

    subgraph "æ¥å£å±‚"
        B1[module_interface.h]
        B2[data_receiver_interface.h]
        B3[processor_interface.h]
    end

    subgraph "å®ç°å±‚"
        C1[åŸºç¡€å·¥å…·ç±»]
        C2[æ•°æ®å¤„ç†ç±»]
        C3[é€šä¿¡ç±»]
    end

    A --> A1
    A --> A2
    A --> A3
    B --> B1
    B --> B2
    B --> B3
```

#### åŸåˆ™2ï¼šç¼–è¯‘ä¾èµ–æœ€å°åŒ–
```markdown
## ç¼–è¯‘ä¾èµ–ä¼˜åŒ–ç­–ç•¥

### å‰å‘å£°æ˜ä¼˜å…ˆ
- å¤´æ–‡ä»¶ä¸­ä¼˜å…ˆä½¿ç”¨å‰å‘å£°æ˜
- å‡å°‘ä¸å¿…è¦çš„#include
- ä½¿ç”¨Pimplæ¨¡å¼éšè—å®ç°ç»†èŠ‚

### æ¥å£ä¸å®ç°åˆ†ç¦»
- æ¥å£å®šä¹‰ç‹¬ç«‹äºå®ç°
- æŠ½è±¡ç±»ä¸ä¾èµ–å…·ä½“å®ç°
- ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºå¯¹è±¡

### æ¨¡æ¿ç‰¹åŒ–å»¶è¿Ÿ
- æ¨¡æ¿å®šä¹‰ä¸ç‰¹åŒ–åˆ†ç¦»
- ç‰¹åŒ–ä»£ç æ”¾åœ¨å•ç‹¬æ–‡ä»¶
- é¿å…å¤´æ–‡ä»¶ä¸­çš„é‡é‡çº§æ¨¡æ¿
```

---

## åŸºç¡€è®¾æ–½æ–‡ä»¶åˆ›å»ºé¡ºåº

### ğŸ“ é˜¶æ®µ1ï¼šæ ¸å¿ƒåŸºç¡€æ–‡ä»¶ (ç¬¬1å¤©)

#### 1.1 åŸºç¡€ç±»å‹å®šä¹‰ (2å°æ—¶)
```cpp
// include/common/types.h - æœ€å…ˆåˆ›å»º
#pragma once

#include <cstdint>
#include <chrono>
#include <memory>
#include <vector>
#include <string>

namespace radar {

// åŸºç¡€æ•°æ®ç±»å‹
using TimeStamp = std::chrono::time_point<std::chrono::high_resolution_clock>;
using DataBuffer = std::vector<uint8_t>;
using FloatBuffer = std::vector<float>;
using ComplexBuffer = std::vector<std::complex<float>>;

// å¤§å°ç±»å‹
using DataSize = size_t;
using ChannelId = uint32_t;
using SequenceId = uint64_t;

// é…ç½®ç±»å‹
struct Point3D {
    float x, y, z;

    Point3D() : x(0), y(0), z(0) {}
    Point3D(float x_, float y_, float z_) : x(x_), y(y_), z(z_) {}
};

struct DataRange {
    size_t start;
    size_t length;

    DataRange() : start(0), length(0) {}
    DataRange(size_t s, size_t l) : start(s), length(l) {}

    size_t end() const { return start + length; }
    bool isValid() const { return length > 0; }
};

// æ™ºèƒ½æŒ‡é’ˆç±»å‹åˆ«å
template<typename T>
using UniquePtr = std::unique_ptr<T>;

template<typename T>
using SharedPtr = std::shared_ptr<T>;

template<typename T>
using WeakPtr = std::weak_ptr<T>;

} // namespace radar
```

#### 1.2 é”™è¯¯ç å®šä¹‰ (2å°æ—¶)
```cpp
// include/common/error_codes.h - ç¬¬äºŒä¸ªåˆ›å»º
#pragma once

#include <string>
#include <system_error>

namespace radar {

// é”™è¯¯ç æšä¸¾
enum class ErrorCode : int {
    Success = 0,

    // é€šç”¨é”™è¯¯ (1-99)
    UnknownError = 1,
    InvalidArgument = 2,
    OutOfMemory = 3,
    Timeout = 4,
    NotImplemented = 5,

    // åˆå§‹åŒ–é”™è¯¯ (100-199)
    InitializationFailed = 100,
    ConfigurationError = 101,
    ResourceUnavailable = 102,
    DependencyMissing = 103,

    // æ•°æ®å¤„ç†é”™è¯¯ (200-299)
    InvalidData = 200,
    DataCorrupted = 201,
    ProcessingFailed = 202,
    AlgorithmError = 203,

    // é€šä¿¡é”™è¯¯ (300-399)
    ConnectionFailed = 300,
    NetworkError = 301,
    ProtocolError = 302,
    TransmissionError = 303,

    // ç¡¬ä»¶é”™è¯¯ (400-499)
    HardwareError = 400,
    GPUError = 401,
    StorageError = 402,
    SensorError = 403,

    // ç³»ç»Ÿé”™è¯¯ (500-599)
    SystemError = 500,
    FileSystemError = 501,
    PermissionDenied = 502,
    ResourceExhausted = 503
};

// é”™è¯¯ç è½¬å­—ç¬¦ä¸²
std::string toString(ErrorCode code);

// é”™è¯¯ç ç±»åˆ«
class ErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override;
    std::string message(int ev) const override;
};

const ErrorCategory& getErrorCategory();

// ä¾¿åˆ©å‡½æ•°
std::error_code makeErrorCode(ErrorCode code);

} // namespace radar

// ä½¿é”™è¯¯ç å¯ä»¥ä¸std::error_codeé…åˆä½¿ç”¨
namespace std {
template<>
struct is_error_code_enum<radar::ErrorCode> : true_type {};
}
```

#### 1.3 å¸¸é‡å®šä¹‰ (1å°æ—¶)
```cpp
// include/common/constants.h - ç¬¬ä¸‰ä¸ªåˆ›å»º
#pragma once

#include <cstddef>
#include <chrono>

namespace radar {
namespace constants {

// ç³»ç»Ÿå¸¸é‡
constexpr size_t DEFAULT_BUFFER_SIZE = 1024 * 1024; // 1MB
constexpr size_t MAX_BUFFER_SIZE = 100 * 1024 * 1024; // 100MB
constexpr size_t MIN_BUFFER_SIZE = 1024; // 1KB

// æ€§èƒ½å¸¸é‡
constexpr std::chrono::milliseconds DEFAULT_TIMEOUT{1000};
constexpr std::chrono::milliseconds MAX_PROCESSING_TIME{10}; // 10mså®æ—¶è¦æ±‚
constexpr size_t DEFAULT_THREAD_COUNT = 4;

// æ•°æ®å¤„ç†å¸¸é‡
constexpr double SAMPLING_RATE = 1000000.0; // 1MHz
constexpr size_t FFT_SIZE = 1024;
constexpr double WINDOW_OVERLAP = 0.5;

// ç½‘ç»œå¸¸é‡
constexpr uint16_t DEFAULT_PORT = 8080;
constexpr size_t MAX_PACKET_SIZE = 65536; // 64KB
constexpr std::chrono::seconds HEARTBEAT_INTERVAL{30};

// æ–‡ä»¶è·¯å¾„å¸¸é‡
constexpr const char* DEFAULT_CONFIG_PATH = "configs/system_config.yaml";
constexpr const char* DEFAULT_LOG_PATH = "logs/";
constexpr const char* DEFAULT_DATA_PATH = "data/";

// ç®—æ³•å¸¸é‡
constexpr double PI = 3.14159265358979323846;
constexpr double TWO_PI = 2.0 * PI;
constexpr float EPSILON = 1e-6f;

} // namespace constants
} // namespace radar
```

### ğŸ“ é˜¶æ®µ2ï¼šæ¥å£å®šä¹‰æ–‡ä»¶ (ç¬¬1å¤©ä¸‹åˆ)

#### 2.1 åŸºç¡€æ¨¡å—æ¥å£ (2å°æ—¶)
```cpp
// include/interfaces/module_interface.h - æ¨¡å—åŸºç¡€æ¥å£
#pragma once

#include "common/types.h"
#include "common/error_codes.h"
#include <string>

namespace radar {

// æ¨¡å—çŠ¶æ€æšä¸¾
enum class ModuleState {
    Uninitialized,
    Initializing,
    Ready,
    Running,
    Paused,
    Error,
    Shutdown
};

// æ¨¡å—é…ç½®åŸºç±»
class ModuleConfiguration {
public:
    virtual ~ModuleConfiguration() = default;
    virtual bool validate() const = 0;
    virtual std::string toString() const = 0;
};

// æ¨¡å—ç»Ÿè®¡ä¿¡æ¯
struct ModuleStatistics {
    uint64_t processedCount = 0;
    uint64_t errorCount = 0;
    std::chrono::microseconds totalProcessingTime{0};
    std::chrono::microseconds averageProcessingTime{0};
    TimeStamp lastProcessTime;

    void reset() {
        processedCount = 0;
        errorCount = 0;
        totalProcessingTime = std::chrono::microseconds{0};
        averageProcessingTime = std::chrono::microseconds{0};
        lastProcessTime = TimeStamp{};
    }
};

// åŸºç¡€æ¨¡å—æ¥å£
class IModule {
public:
    virtual ~IModule() = default;

    // ç”Ÿå‘½å‘¨æœŸç®¡ç†
    virtual ErrorCode initialize(const ModuleConfiguration& config) = 0;
    virtual ErrorCode start() = 0;
    virtual ErrorCode stop() = 0;
    virtual ErrorCode shutdown() = 0;

    // çŠ¶æ€æŸ¥è¯¢
    virtual ModuleState getState() const = 0;
    virtual std::string getModuleName() const = 0;
    virtual std::string getModuleVersion() const = 0;

    // é…ç½®ç®¡ç†
    virtual ErrorCode updateConfiguration(const ModuleConfiguration& config) = 0;
    virtual UniquePtr<ModuleConfiguration> getConfiguration() const = 0;

    // ç»Ÿè®¡ä¿¡æ¯
    virtual ModuleStatistics getStatistics() const = 0;
    virtual void resetStatistics() = 0;

    // å¥åº·æ£€æŸ¥
    virtual bool isHealthy() const = 0;
    virtual std::string getHealthInfo() const = 0;
};

} // namespace radar
```

#### 2.2 æ•°æ®æ¥æ”¶æ¥å£ (2å°æ—¶)
```cpp
// include/interfaces/data_receiver_interface.h - æ•°æ®æ¥æ”¶æ¥å£
#pragma once

#include "module_interface.h"
#include "common/types.h"
#include <functional>

namespace radar {

// æ•°æ®åŒ…ç»“æ„
struct DataPacket {
    SequenceId sequenceId;
    TimeStamp timestamp;
    ChannelId channelId;
    DataBuffer data;

    DataPacket() : sequenceId(0), channelId(0) {}

    bool isValid() const {
        return !data.empty() && sequenceId > 0;
    }

    size_t getDataSize() const {
        return data.size();
    }
};

// æ¥æ”¶ç»Ÿè®¡ä¿¡æ¯
struct ReceptionStatistics {
    uint64_t packetsReceived = 0;
    uint64_t packetsDropped = 0;
    uint64_t bytesReceived = 0;
    uint64_t crcErrors = 0;
    double receptionRate = 0.0; // packets/second

    void reset() {
        packetsReceived = 0;
        packetsDropped = 0;
        bytesReceived = 0;
        crcErrors = 0;
        receptionRate = 0.0;
    }
};

// æ•°æ®æ¥æ”¶å™¨é…ç½®
class DataReceiverConfiguration : public ModuleConfiguration {
public:
    virtual ~DataReceiverConfiguration() = default;

    virtual size_t getBufferSize() const = 0;
    virtual std::chrono::milliseconds getTimeout() const = 0;
    virtual bool isValidationEnabled() const = 0;
};

// æ•°æ®å›è°ƒå‡½æ•°ç±»å‹
using DataCallback = std::function<void(const DataPacket& packet)>;
using ErrorCallback = std::function<void(ErrorCode error, const std::string& message)>;

// æ•°æ®æ¥æ”¶å™¨æ¥å£
class IDataReceiver : public IModule {
public:
    virtual ~IDataReceiver() = default;

    // æ•°æ®æ¥æ”¶
    virtual ErrorCode receiveData(DataPacket& packet) = 0;
    virtual ErrorCode receiveDataAsync(DataCallback onData, ErrorCallback onError) = 0;

    // ç¼“å†²åŒºç®¡ç†
    virtual size_t getAvailableDataSize() const = 0;
    virtual size_t getBufferCapacity() const = 0;
    virtual double getBufferUsageRatio() const = 0;

    // æ¥æ”¶æ§åˆ¶
    virtual ErrorCode pauseReception() = 0;
    virtual ErrorCode resumeReception() = 0;
    virtual ErrorCode flushBuffer() = 0;

    // ç»Ÿè®¡ä¿¡æ¯
    virtual ReceptionStatistics getReceptionStatistics() const = 0;
    virtual void resetReceptionStatistics() = 0;

    // è¿æ¥ç®¡ç†
    virtual bool isConnected() const = 0;
    virtual ErrorCode reconnect() = 0;
};

} // namespace radar
```

### ğŸ“ é˜¶æ®µ3ï¼šåŸºç¡€å®ç°ç±» (ç¬¬2-3å¤©)

#### 3.1 åŸºç¡€æ¨¡å—å®ç° (åŠå¤©)
```cpp
// src/common/base_module.h - åŸºç¡€æ¨¡å—å®ç°åŸºç±»
#pragma once

#include "interfaces/module_interface.h"
#include <mutex>
#include <atomic>

namespace radar {

class BaseModule : public IModule {
public:
    BaseModule(const std::string& moduleName, const std::string& moduleVersion);
    virtual ~BaseModule() = default;

    // IModuleæ¥å£å®ç°
    ErrorCode initialize(const ModuleConfiguration& config) override final;
    ErrorCode start() override final;
    ErrorCode stop() override final;
    ErrorCode shutdown() override final;

    ModuleState getState() const override final;
    std::string getModuleName() const override final;
    std::string getModuleVersion() const override final;

    ModuleStatistics getStatistics() const override final;
    void resetStatistics() override final;

    bool isHealthy() const override;
    std::string getHealthInfo() const override;

protected:
    // å­ç±»éœ€è¦å®ç°çš„è™šå‡½æ•°
    virtual ErrorCode doInitialize(const ModuleConfiguration& config) = 0;
    virtual ErrorCode doStart() = 0;
    virtual ErrorCode doStop() = 0;
    virtual ErrorCode doShutdown() = 0;

    virtual bool checkHealth() const { return true; }
    virtual std::string getHealthDetails() const { return "OK"; }

    // çŠ¶æ€ç®¡ç†è¾…åŠ©å‡½æ•°
    void setState(ModuleState newState);
    void updateStatistics(std::chrono::microseconds processingTime, bool success = true);

    // é…ç½®ç®¡ç†
    void setConfiguration(UniquePtr<ModuleConfiguration> config);
    const ModuleConfiguration* getCurrentConfiguration() const;

private:
    const std::string moduleName_;
    const std::string moduleVersion_;

    mutable std::mutex stateMutex_;
    std::atomic<ModuleState> currentState_;

    mutable std::mutex statisticsMutex_;
    ModuleStatistics statistics_;

    mutable std::mutex configMutex_;
    UniquePtr<ModuleConfiguration> currentConfig_;
};

} // namespace radar
```

#### 3.2 é…ç½®ç®¡ç†å™¨ (åŠå¤©)
```cpp
// src/common/configuration_manager.h - é…ç½®ç®¡ç†å™¨
#pragma once

#include "common/types.h"
#include "common/error_codes.h"
#include <yaml-cpp/yaml.h>
#include <unordered_map>
#include <shared_mutex>

namespace radar {

class ConfigurationManager {
public:
    static ConfigurationManager& getInstance();

    // é…ç½®æ–‡ä»¶åŠ è½½
    ErrorCode loadFromFile(const std::string& configFile);
    ErrorCode loadFromString(const std::string& yamlContent);
    ErrorCode saveToFile(const std::string& configFile) const;

    // é…ç½®å€¼è®¿é—®
    template<typename T>
    T getValue(const std::string& key, const T& defaultValue = T{}) const;

    template<typename T>
    ErrorCode setValue(const std::string& key, const T& value);

    // é…ç½®èŠ‚è®¿é—®
    bool hasSection(const std::string& section) const;
    std::vector<std::string> getSectionKeys(const std::string& section) const;

    // é…ç½®éªŒè¯
    ErrorCode validateConfiguration() const;
    std::vector<std::string> getValidationErrors() const;

    // é…ç½®ç›‘å¬
    using ConfigChangeCallback = std::function<void(const std::string& key, const YAML::Node& oldValue, const YAML::Node& newValue)>;
    void addChangeListener(const std::string& key, ConfigChangeCallback callback);
    void removeChangeListener(const std::string& key);

    // é…ç½®å¿«ç…§
    YAML::Node getSnapshot() const;
    ErrorCode restoreFromSnapshot(const YAML::Node& snapshot);

private:
    ConfigurationManager() = default;

    mutable std::shared_mutex configMutex_;
    YAML::Node rootConfig_;

    std::unordered_map<std::string, std::vector<ConfigChangeCallback>> changeListeners_;
    mutable std::mutex listenersMutex_;

    void notifyListeners(const std::string& key, const YAML::Node& oldValue, const YAML::Node& newValue);
    std::string normalizeKey(const std::string& key) const;
};

// æ¨¡æ¿ç‰¹åŒ–å®ç°
template<typename T>
T ConfigurationManager::getValue(const std::string& key, const T& defaultValue) const {
    std::shared_lock<std::shared_mutex> lock(configMutex_);

    try {
        auto normalizedKey = normalizeKey(key);
        auto keys = split(normalizedKey, '.');

        YAML::Node current = rootConfig_;
        for (const auto& k : keys) {
            if (!current[k]) {
                return defaultValue;
            }
            current = current[k];
        }

        return current.as<T>();
    } catch (const std::exception&) {
        return defaultValue;
    }
}

} // namespace radar
```

### ğŸ“ é˜¶æ®µ4ï¼šå¤åˆç»„ä»¶ (ç¬¬4-5å¤©)

#### 4.1 æ•°æ®å¤„ç†ç®¡é“ (1å¤©)
```cpp
// src/data/data_pipeline.h - æ•°æ®å¤„ç†ç®¡é“
#pragma once

#include "interfaces/data_receiver_interface.h"
#include "common/base_module.h"
#include "common/thread_pool.h"
#include <queue>
#include <condition_variable>

namespace radar {

// å¤„ç†é˜¶æ®µæ¥å£
class IProcessingStage {
public:
    virtual ~IProcessingStage() = default;
    virtual ErrorCode process(const DataPacket& input, DataPacket& output) = 0;
    virtual std::string getStageName() const = 0;
};

// ç®¡é“é…ç½®
class PipelineConfiguration : public ModuleConfiguration {
public:
    size_t bufferSize = 1000;
    size_t threadCount = 4;
    std::chrono::milliseconds timeout{1000};
    bool enableParallelProcessing = true;

    bool validate() const override {
        return bufferSize > 0 && threadCount > 0 && timeout.count() > 0;
    }

    std::string toString() const override {
        return "PipelineConfig{bufferSize=" + std::to_string(bufferSize) +
               ", threadCount=" + std::to_string(threadCount) + "}";
    }
};

// æ•°æ®å¤„ç†ç®¡é“
class DataPipeline : public BaseModule {
public:
    DataPipeline();
    virtual ~DataPipeline();

    // ç®¡é“æ„å»º
    ErrorCode addStage(UniquePtr<IProcessingStage> stage);
    ErrorCode removeStage(const std::string& stageName);
    size_t getStageCount() const;

    // æ•°æ®å¤„ç†
    ErrorCode processData(const DataPacket& input, DataPacket& output);
    ErrorCode processDataAsync(const DataPacket& input,
                              std::function<void(const DataPacket&, ErrorCode)> callback);

    // æ‰¹å¤„ç†
    ErrorCode processBatch(const std::vector<DataPacket>& inputs,
                          std::vector<DataPacket>& outputs);

    // ç®¡é“çŠ¶æ€
    size_t getQueueSize() const;
    double getProcessingRate() const; // packets/second
    std::vector<std::string> getStageNames() const;

protected:
    ErrorCode doInitialize(const ModuleConfiguration& config) override;
    ErrorCode doStart() override;
    ErrorCode doStop() override;
    ErrorCode doShutdown() override;

private:
    std::vector<UniquePtr<IProcessingStage>> stages_;
    mutable std::shared_mutex stagesMutex_;

    UniquePtr<ThreadPool> threadPool_;

    std::queue<std::pair<DataPacket, std::function<void(const DataPacket&, ErrorCode)>>> processingQueue_;
    mutable std::mutex queueMutex_;
    std::condition_variable queueCondition_;

    std::atomic<bool> stopProcessing_{false};
    std::thread processingThread_;

    void processingLoop();
    ErrorCode processInternal(const DataPacket& input, DataPacket& output);
};

} // namespace radar
```

---

## æ¨¡å—ç‰¹å®šæ–‡ä»¶åˆ›å»ºé¡ºåº

### ğŸ”§ æ•°æ®æ¥æ”¶æ¨¡å—æ–‡ä»¶é¡ºåº

#### ç¬¬1é˜¶æ®µï¼šæ¥å£å’Œé…ç½® (åŠå¤©)
```markdown
1. data_receiver_types.h        - æ•°æ®æ¥æ”¶ç›¸å…³ç±»å‹å®šä¹‰
2. data_receiver_config.h       - æ•°æ®æ¥æ”¶å™¨é…ç½®ç±»
3. network_receiver_interface.h - ç½‘ç»œæ•°æ®æ¥æ”¶æ¥å£
4. file_receiver_interface.h    - æ–‡ä»¶æ•°æ®æ¥æ”¶æ¥å£
```

#### ç¬¬2é˜¶æ®µï¼šåŸºç¡€å®ç° (1å¤©)
```markdown
1. base_data_receiver.cpp       - åŸºç¡€æ•°æ®æ¥æ”¶å™¨å®ç°
2. packet_validator.cpp         - æ•°æ®åŒ…éªŒè¯å™¨
3. buffer_manager.cpp          - ç¼“å†²åŒºç®¡ç†å™¨
4. reception_statistics.cpp    - æ¥æ”¶ç»Ÿè®¡ç®¡ç†
```

#### ç¬¬3é˜¶æ®µï¼šå…·ä½“å®ç° (1.5å¤©)
```markdown
1. udp_receiver.cpp            - UDPæ•°æ®æ¥æ”¶å™¨
2. tcp_receiver.cpp            - TCPæ•°æ®æ¥æ”¶å™¨
3. file_receiver.cpp           - æ–‡ä»¶æ•°æ®æ¥æ”¶å™¨
4. multicast_receiver.cpp      - ç»„æ’­æ•°æ®æ¥æ”¶å™¨
```

#### ç¬¬4é˜¶æ®µï¼šæµ‹è¯•å’Œé›†æˆ (0.5å¤©)
```markdown
1. data_receiver_tests.cpp     - å•å…ƒæµ‹è¯•
2. integration_tests.cpp       - é›†æˆæµ‹è¯•
3. performance_tests.cpp       - æ€§èƒ½æµ‹è¯•
```

### âš™ï¸ GPUå¤„ç†æ¨¡å—æ–‡ä»¶é¡ºåº

#### ç¬¬1é˜¶æ®µï¼šCUDAåŸºç¡€ (åŠå¤©)
```markdown
1. cuda_common.h               - CUDAé€šç”¨å®šä¹‰
2. gpu_memory_manager.h        - GPUå†…å­˜ç®¡ç†å™¨æ¥å£
3. cuda_error_handling.h       - CUDAé”™è¯¯å¤„ç†
4. gpu_device_info.h          - GPUè®¾å¤‡ä¿¡æ¯
```

#### ç¬¬2é˜¶æ®µï¼šæ ¸å¿ƒç®—æ³• (1.5å¤©)
```markdown
1. fft_processor.cu           - FFTå¤„ç†å™¨CUDAå®ç°
2. signal_processor.cu        - ä¿¡å·å¤„ç†CUDAå†…æ ¸
3. detection_algorithm.cu     - ç›®æ ‡æ£€æµ‹CUDAç®—æ³•
4. filter_kernels.cu         - æ»¤æ³¢å™¨CUDAå†…æ ¸
```

#### ç¬¬3é˜¶æ®µï¼šåŒ…è£…å™¨å’Œæ¥å£ (1å¤©)
```markdown
1. gpu_processor_interface.cpp - GPUå¤„ç†å™¨æ¥å£å®ç°
2. cuda_memory_manager.cpp     - CUDAå†…å­˜ç®¡ç†å™¨
3. gpu_performance_monitor.cpp - GPUæ€§èƒ½ç›‘æ§
4. gpu_resource_manager.cpp    - GPUèµ„æºç®¡ç†
```

### ğŸ“Š æ˜¾ç¤ºæ§åˆ¶æ¨¡å—æ–‡ä»¶é¡ºåº

#### ç¬¬1é˜¶æ®µï¼šå›¾å½¢åŸºç¡€ (åŠå¤©)
```markdown
1. graphics_types.h           - å›¾å½¢ç›¸å…³ç±»å‹å®šä¹‰
2. display_interface.h        - æ˜¾ç¤ºæ¥å£å®šä¹‰
3. render_context.h          - æ¸²æŸ“ä¸Šä¸‹æ–‡
4. graphics_primitive.h      - å›¾å½¢åŸºå…ƒ
```

#### ç¬¬2é˜¶æ®µï¼šæ¸²æŸ“å®ç° (1å¤©)
```markdown
1. opengl_renderer.cpp       - OpenGLæ¸²æŸ“å™¨
2. plot_renderer.cpp         - å›¾è¡¨æ¸²æŸ“å™¨
3. heatmap_renderer.cpp      - çƒ­åŠ›å›¾æ¸²æŸ“å™¨
4. 3d_renderer.cpp          - 3Dåœºæ™¯æ¸²æŸ“å™¨
```

#### ç¬¬3é˜¶æ®µï¼šUIç»„ä»¶ (1å¤©)
```markdown
1. control_panel.cpp         - æ§åˆ¶é¢æ¿
2. status_display.cpp        - çŠ¶æ€æ˜¾ç¤º
3. parameter_editor.cpp      - å‚æ•°ç¼–è¾‘å™¨
4. data_visualization.cpp    - æ•°æ®å¯è§†åŒ–
```

---

## æµ‹è¯•æ–‡ä»¶åˆ›å»ºé¡ºåº

### ğŸ§ª æµ‹è¯•æ–‡ä»¶å±‚æ¬¡ç»“æ„

#### å•å…ƒæµ‹è¯•åˆ›å»ºé¡ºåº
```markdown
## åŸºç¡€æµ‹è¯• (ç¬¬1å¤©)
1. types_test.cpp              - åŸºç¡€ç±»å‹æµ‹è¯•
2. error_codes_test.cpp        - é”™è¯¯ç æµ‹è¯•
3. configuration_test.cpp      - é…ç½®ç®¡ç†æµ‹è¯•
4. base_module_test.cpp        - åŸºç¡€æ¨¡å—æµ‹è¯•

## æ¥å£æµ‹è¯• (ç¬¬2å¤©)
1. module_interface_test.cpp   - æ¨¡å—æ¥å£æµ‹è¯•
2. data_receiver_test.cpp      - æ•°æ®æ¥æ”¶å™¨æµ‹è¯•
3. processor_interface_test.cpp - å¤„ç†å™¨æ¥å£æµ‹è¯•
4. pipeline_test.cpp          - æ•°æ®ç®¡é“æµ‹è¯•

## å®ç°æµ‹è¯• (ç¬¬3-4å¤©)
1. udp_receiver_test.cpp       - UDPæ¥æ”¶å™¨æµ‹è¯•
2. fft_processor_test.cpp      - FFTå¤„ç†å™¨æµ‹è¯•
3. gpu_manager_test.cpp        - GPUç®¡ç†å™¨æµ‹è¯•
4. display_controller_test.cpp - æ˜¾ç¤ºæ§åˆ¶å™¨æµ‹è¯•

## é›†æˆæµ‹è¯• (ç¬¬5å¤©)
1. end_to_end_test.cpp        - ç«¯åˆ°ç«¯æµ‹è¯•
2. performance_test.cpp       - æ€§èƒ½æµ‹è¯•
3. stability_test.cpp         - ç¨³å®šæ€§æµ‹è¯•
4. regression_test.cpp        - å›å½’æµ‹è¯•
```

#### æµ‹è¯•å·¥å…·å’Œæ¡†æ¶
```cpp
// tests/common/test_framework.h - æµ‹è¯•æ¡†æ¶
#pragma once

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "common/types.h"
#include "common/error_codes.h"

namespace radar {
namespace testing {

// æµ‹è¯•åŸºç±»
class RadarTestBase : public ::testing::Test {
protected:
    void SetUp() override;
    void TearDown() override;

    // é€šç”¨æµ‹è¯•å·¥å…·
    DataPacket createTestPacket(size_t dataSize = 1024);
    std::vector<DataPacket> createTestPacketSequence(size_t count, size_t dataSize = 1024);

    // æ€§èƒ½æµ‹è¯•å·¥å…·
    void measureExecutionTime(std::function<void()> func, const std::string& testName);
    void verifyPerformanceRequirement(std::chrono::microseconds actualTime,
                                    std::chrono::microseconds requiredTime);

    // å†…å­˜æµ‹è¯•å·¥å…·
    size_t getCurrentMemoryUsage();
    void verifyNoMemoryLeak(std::function<void()> func);

private:
    size_t initialMemoryUsage_;
};

// Mockå¯¹è±¡ç”Ÿæˆå®
#define MOCK_MODULE_INTERFACE(ClassName) \
class Mock##ClassName : public ClassName { \
public: \
    MOCK_METHOD(ErrorCode, initialize, (const ModuleConfiguration&), (override)); \
    MOCK_METHOD(ErrorCode, start, (), (override)); \
    MOCK_METHOD(ErrorCode, stop, (), (override)); \
    MOCK_METHOD(ErrorCode, shutdown, (), (override)); \
    MOCK_METHOD(ModuleState, getState, (), (const, override)); \
    MOCK_METHOD(std::string, getModuleName, (), (const, override)); \
    MOCK_METHOD(std::string, getModuleVersion, (), (const, override)); \
}

// æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
class TestDataGenerator {
public:
    static std::vector<float> generateSineWave(size_t samples, double frequency, double sampleRate);
    static std::vector<float> generateNoise(size_t samples, double amplitude = 1.0);
    static std::vector<float> generateChirpSignal(size_t samples, double startFreq, double endFreq, double sampleRate);
    static DataPacket generateRadarDataPacket(size_t samples);
};

} // namespace testing
} // namespace radar
```

---

## æ–‡æ¡£æ–‡ä»¶åˆ›å»ºé¡ºåº

### ğŸ“š æ–‡æ¡£åˆ›å»ºå±‚æ¬¡

#### APIæ–‡æ¡£åˆ›å»ºé¡ºåº
```markdown
## åŸºç¡€APIæ–‡æ¡£ (ç¬¬1å¤©)
1. README.md                   - é¡¹ç›®æ¦‚è¿°å’Œå¿«é€Ÿå¼€å§‹
2. ARCHITECTURE.md             - ç³»ç»Ÿæ¶æ„è¯´æ˜
3. BUILDING.md                 - æ„å»ºè¯´æ˜
4. CONFIGURATION.md            - é…ç½®è¯´æ˜

## æ¨¡å—APIæ–‡æ¡£ (ç¬¬2-3å¤©)
1. data_receiver_api.md        - æ•°æ®æ¥æ”¶å™¨API
2. gpu_processor_api.md        - GPUå¤„ç†å™¨API
3. display_controller_api.md   - æ˜¾ç¤ºæ§åˆ¶å™¨API
4. protocol_parser_api.md      - åè®®è§£æå™¨API

## é«˜çº§æ–‡æ¡£ (ç¬¬4å¤©)
1. PERFORMANCE_TUNING.md       - æ€§èƒ½è°ƒä¼˜æŒ‡å—
2. TROUBLESHOOTING.md          - æ•…éšœæ’é™¤æŒ‡å—
3. EXTENDING.md                - æ‰©å±•å¼€å‘æŒ‡å—
4. DEPLOYMENT.md               - éƒ¨ç½²æŒ‡å—
```

#### æ–‡æ¡£ç”Ÿæˆè‡ªåŠ¨åŒ–
```bash
#!/bin/bash
# scripts/generate_docs.sh - æ–‡æ¡£ç”Ÿæˆè„šæœ¬

echo "=== ç”ŸæˆAPIæ–‡æ¡£ ==="

# ç”ŸæˆDoxygenæ–‡æ¡£
doxygen docs/Doxyfile

# ç”ŸæˆUMLå›¾
plantuml docs/diagrams/*.puml

# ç”Ÿæˆä»£ç è¦†ç›–ç‡æŠ¥å‘Š
lcov --capture --directory build --output-file coverage.info
genhtml coverage.info --output-directory docs/coverage

# ç”Ÿæˆæ€§èƒ½åŸºå‡†æŠ¥å‘Š
./build/performance_tests --benchmark_format=json > docs/benchmark_results.json

# ç”Ÿæˆä¾èµ–å…³ç³»å›¾
cmake --graphviz=docs/dependencies.dot .
dot -Tpng docs/dependencies.dot -o docs/dependencies.png

echo "=== æ–‡æ¡£ç”Ÿæˆå®Œæˆ ==="
echo "APIæ–‡æ¡£: docs/html/index.html"
echo "è¦†ç›–ç‡æŠ¥å‘Š: docs/coverage/index.html"
echo "æ€§èƒ½æŠ¥å‘Š: docs/benchmark_results.json"
echo "ä¾èµ–å…³ç³»å›¾: docs/dependencies.png"
```

---

## CMakeæ„å»ºæ–‡ä»¶åˆ›å»ºé¡ºåº

### ğŸ”¨ æ„å»ºç³»ç»Ÿæ–‡ä»¶å±‚æ¬¡

#### CMakeæ–‡ä»¶åˆ›å»ºé¡ºåº
```cmake
# æ ¹çº§CMakeLists.txt - æœ€å…ˆåˆ›å»º
cmake_minimum_required(VERSION 3.20)
project(RadarMVPSystem VERSION 1.0.0 LANGUAGES CXX CUDA)

# è®¾ç½®C++æ ‡å‡†
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# åŒ…å«è‡ªå®šä¹‰CMakeæ¨¡å—
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# å¼•å…¥é…ç½®æ–‡ä»¶
include(CompilerSettings)
include(PackageConfig)

# å…¨å±€è®¾ç½®
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# æ·»åŠ å­ç›®å½•
add_subdirectory(third_party)
add_subdirectory(src)
add_subdirectory(tests)

# å®‰è£…è§„åˆ™
include(GNUInstallDirs)
install(DIRECTORY configs/ DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/radar)
install(DIRECTORY docs/ DESTINATION ${CMAKE_INSTALL_DOCDIR})
```

#### æ¨¡å—çº§CMakeLists.txtåˆ›å»ºé¡ºåº
```markdown
## ç¬¬1å±‚ï¼šåŸºç¡€åº“ (ç¬¬1å¤©)
1. src/common/CMakeLists.txt       - é€šç”¨åº“æ„å»º
2. src/interfaces/CMakeLists.txt   - æ¥å£åº“æ„å»º
3. third_party/CMakeLists.txt      - ç¬¬ä¸‰æ–¹åº“é…ç½®

## ç¬¬2å±‚ï¼šæ ¸å¿ƒæ¨¡å— (ç¬¬2å¤©)
1. src/modules/data_receiver/CMakeLists.txt    - æ•°æ®æ¥æ”¶æ¨¡å—
2. src/modules/gpu_processor/CMakeLists.txt    - GPUå¤„ç†æ¨¡å—
3. src/modules/protocol_parser/CMakeLists.txt  - åè®®è§£ææ¨¡å—

## ç¬¬3å±‚ï¼šåº”ç”¨å±‚ (ç¬¬3å¤©)
1. src/application/CMakeLists.txt  - åº”ç”¨ç¨‹åºæ„å»º
2. src/modules/display_control/CMakeLists.txt - æ˜¾ç¤ºæ§åˆ¶æ¨¡å—
3. src/modules/task_scheduler/CMakeLists.txt  - ä»»åŠ¡è°ƒåº¦æ¨¡å—

## ç¬¬4å±‚ï¼šæµ‹è¯•å’Œå·¥å…· (ç¬¬4å¤©)
1. tests/unit_tests/CMakeLists.txt    - å•å…ƒæµ‹è¯•æ„å»º
2. tests/integration_tests/CMakeLists.txt - é›†æˆæµ‹è¯•æ„å»º
3. tools/CMakeLists.txt               - å·¥å…·ç¨‹åºæ„å»º
```

---

## è‡ªåŠ¨åŒ–åˆ›å»ºå·¥å…·

### ğŸ¤– æ–‡ä»¶ç”Ÿæˆè„šæœ¬

#### æ¨¡å—æ–‡ä»¶ç”Ÿæˆå™¨
```bash
#!/bin/bash
# scripts/generate_module.sh - æ¨¡å—æ–‡ä»¶ç”Ÿæˆè„šæœ¬

MODULE_NAME=$1
MODULE_TYPE=${2:-"processor"}  # processor, receiver, controller

if [ -z "$MODULE_NAME" ]; then
    echo "ç”¨æ³•: $0 <æ¨¡å—å> [æ¨¡å—ç±»å‹]"
    echo "æ¨¡å—ç±»å‹: processor, receiver, controller"
    exit 1
fi

echo "=== ç”Ÿæˆæ¨¡å—: $MODULE_NAME (ç±»å‹: $MODULE_TYPE) ==="

# åˆ›å»ºç›®å½•ç»“æ„
mkdir -p "src/modules/${MODULE_NAME}"
mkdir -p "include/modules/${MODULE_NAME}"
mkdir -p "tests/unit_tests/${MODULE_NAME}"
mkdir -p "configs/modules/${MODULE_NAME}"

# ç”Ÿæˆæ¥å£æ–‡ä»¶
cat > "include/modules/${MODULE_NAME}/${MODULE_NAME}_interface.h" << EOF
#pragma once

#include "interfaces/module_interface.h"

namespace radar {
namespace ${MODULE_NAME} {

class I${MODULE_NAME^} : public IModule {
public:
    virtual ~I${MODULE_NAME^}() = default;

    // TODO: æ·»åŠ æ¨¡å—ç‰¹å®šæ¥å£
};

} // namespace ${MODULE_NAME}
} // namespace radar
EOF

# ç”Ÿæˆå®ç°æ–‡ä»¶
cat > "src/modules/${MODULE_NAME}/${MODULE_NAME}.h" << EOF
#pragma once

#include "modules/${MODULE_NAME}/${MODULE_NAME}_interface.h"
#include "common/base_module.h"

namespace radar {
namespace ${MODULE_NAME} {

class ${MODULE_NAME^} : public BaseModule, public I${MODULE_NAME^} {
public:
    ${MODULE_NAME^}();
    virtual ~${MODULE_NAME^}();

protected:
    ErrorCode doInitialize(const ModuleConfiguration& config) override;
    ErrorCode doStart() override;
    ErrorCode doStop() override;
    ErrorCode doShutdown() override;

private:
    // TODO: æ·»åŠ ç§æœ‰æˆå‘˜
};

} // namespace ${MODULE_NAME}
} // namespace radar
EOF

# ç”ŸæˆCMakeLists.txt
cat > "src/modules/${MODULE_NAME}/CMakeLists.txt" << EOF
# ${MODULE_NAME^} æ¨¡å—æ„å»ºé…ç½®

add_library(${MODULE_NAME}
    ${MODULE_NAME}.cpp
    ${MODULE_NAME}_config.cpp
)

target_include_directories(${MODULE_NAME}
    PUBLIC
        \${PROJECT_SOURCE_DIR}/include
    PRIVATE
        \${CMAKE_CURRENT_SOURCE_DIR}
)

target_link_libraries(${MODULE_NAME}
    PUBLIC
        radar_common
        radar_interfaces
    PRIVATE
        # TODO: æ·»åŠ ä¾èµ–åº“
)

# å®‰è£…è§„åˆ™
install(TARGETS ${MODULE_NAME}
    LIBRARY DESTINATION \${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION \${CMAKE_INSTALL_LIBDIR}
)
EOF

# ç”Ÿæˆæµ‹è¯•æ–‡ä»¶
cat > "tests/unit_tests/${MODULE_NAME}/${MODULE_NAME}_test.cpp" << EOF
#include <gtest/gtest.h>
#include "modules/${MODULE_NAME}/${MODULE_NAME}.h"
#include "tests/common/test_framework.h"

using namespace radar;
using namespace radar::${MODULE_NAME};
using namespace radar::testing;

class ${MODULE_NAME^}Test : public RadarTestBase {
protected:
    void SetUp() override {
        RadarTestBase::SetUp();
        ${MODULE_NAME}_= std::make_unique<${MODULE_NAME^}>();
    }

    std::unique_ptr<${MODULE_NAME^}> ${MODULE_NAME}_;
};

TEST_F(${MODULE_NAME^}Test, BasicInitialization) {
    // TODO: æ·»åŠ åˆå§‹åŒ–æµ‹è¯•
    EXPECT_EQ(${MODULE_NAME}_->getState(), ModuleState::Uninitialized);
}

TEST_F(${MODULE_NAME^}Test, ConfigurationManagement) {
    // TODO: æ·»åŠ é…ç½®ç®¡ç†æµ‹è¯•
}

TEST_F(${MODULE_NAME^}Test, LifecycleManagement) {
    // TODO: æ·»åŠ ç”Ÿå‘½å‘¨æœŸæµ‹è¯•
}
EOF

echo "âœ… æ¨¡å— $MODULE_NAME æ–‡ä»¶ç»“æ„ç”Ÿæˆå®Œæˆ"
echo "ğŸ“ åˆ›å»ºçš„æ–‡ä»¶:"
echo "  - include/modules/${MODULE_NAME}/${MODULE_NAME}_interface.h"
echo "  - src/modules/${MODULE_NAME}/${MODULE_NAME}.h"
echo "  - src/modules/${MODULE_NAME}/CMakeLists.txt"
echo "  - tests/unit_tests/${MODULE_NAME}/${MODULE_NAME}_test.cpp"
echo ""
echo "ğŸ“ ä¸‹ä¸€æ­¥:"
echo "  1. å®Œå–„æ¥å£å®šä¹‰"
echo "  2. å®ç°æ ¸å¿ƒåŠŸèƒ½"
echo "  3. ç¼–å†™é…ç½®ç±»"
echo "  4. æ·»åŠ æµ‹è¯•ç”¨ä¾‹"
```

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦             |
| :--- | :--------- | :----- | :------------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºæ–‡ä»¶åˆ›å»ºé¡ºåºæŒ‡å— |
