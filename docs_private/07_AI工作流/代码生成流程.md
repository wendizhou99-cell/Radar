# AIä»£ç ç”Ÿæˆæµç¨‹

- **æ ‡é¢˜**: AIæ™ºèƒ½ä»£ç ç”Ÿæˆæ€ç»´ä¸è´¨é‡ä¿è¯æµç¨‹
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-11
- **è´Ÿè´£äºº**: Kelin

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰AIåœ¨å®Œæˆæ–¹æ¡ˆè®¾è®¡å’Œä¾èµ–åˆ†æåï¼Œå¦‚ä½•æ™ºèƒ½åœ°ç”Ÿæˆé«˜è´¨é‡ä»£ç çš„æ€ç»´æ¨¡å¼å’Œæµç¨‹ã€‚é‡ç‚¹åœ¨äºAIå¦‚ä½•å°†è®¾è®¡æ–¹æ¡ˆè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„ä»£ç ï¼Œå¹¶ç¡®ä¿ä»£ç çš„æ­£ç¡®æ€§ã€å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ã€‚

---

## ğŸš€ ä»£ç ç”Ÿæˆçš„æ ¸å¿ƒæ€ç»´

### ä»è®¾è®¡åˆ°ä»£ç çš„æ™ºèƒ½è½¬æ¢

AIå¿…é¡»å…·å¤‡å°†æŠ½è±¡è®¾è®¡è½¬åŒ–ä¸ºå…·ä½“ä»£ç å®ç°çš„æ™ºèƒ½èƒ½åŠ›ã€‚

**è½¬æ¢æ€ç»´é“¾**:
```
æŠ€æœ¯æ–¹æ¡ˆ â†’ æ¶æ„å®ç° â†’ æ¥å£å®šä¹‰ â†’ æ ¸å¿ƒé€»è¾‘ â†’ é”™è¯¯å¤„ç† â†’ æµ‹è¯•ä»£ç 
```

**å…·ä½“è½¬æ¢è¿‡ç¨‹**:
```
è®¾è®¡è¾“å…¥ï¼š"ç”¨æˆ·è®¤è¯æ¨¡å—ï¼Œæ”¯æŒå¯†ç å’ŒTokenä¸¤ç§è®¤è¯æ–¹å¼"
â†“
AIçš„ä»£ç ç”Ÿæˆæ€ç»´ï¼š

1. æ¶æ„å±‚é¢è½¬æ¢
   - ç­–ç•¥æ¨¡å¼ï¼šIAuthStrategyæ¥å£ + PasswordAuth/TokenAuthå®ç°
   - å·¥å‚æ¨¡å¼ï¼šAuthStrategyFactoryè´Ÿè´£ç­–ç•¥åˆ›å»º
   - é—¨é¢æ¨¡å¼ï¼šAuthenticationServiceæä¾›ç»Ÿä¸€æ¥å£

2. æ¥å£å±‚é¢è½¬æ¢
   - å®šä¹‰æ¸…æ™°çš„è¾“å…¥è¾“å‡ºï¼šAuthRequest â†’ AuthResult
   - å¼‚å¸¸å¤„ç†æœºåˆ¶ï¼šAuthenticationExceptionå±‚æ¬¡
   - é…ç½®æ¥å£ï¼šAuthConfigé…ç½®ç­–ç•¥å‚æ•°

3. å®ç°å±‚é¢è½¬æ¢
   - æ ¸å¿ƒç®—æ³•ï¼šå¯†ç éªŒè¯ã€Tokenè§£æé€»è¾‘
   - æ•°æ®è®¿é—®ï¼šç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢ã€ä¼šè¯ç®¡ç†
   - å®‰å…¨è€ƒè™‘ï¼šå¯†ç å“ˆå¸Œã€Tokenç­¾åéªŒè¯

4. è´¨é‡ä¿è¯è½¬æ¢
   - å•å…ƒæµ‹è¯•ï¼šæ¯ä¸ªç­–ç•¥ç±»çš„ç‹¬ç«‹æµ‹è¯•
   - é›†æˆæµ‹è¯•ï¼šè®¤è¯æµç¨‹çš„ç«¯åˆ°ç«¯æµ‹è¯•
   - æ€§èƒ½æµ‹è¯•ï¼šé«˜å¹¶å‘è®¤è¯çš„æ€§èƒ½åŸºå‡†
```

### æ¸è¿›å¼ä»£ç ç”Ÿæˆç­–ç•¥

AIåº”è¯¥é‡‡ç”¨æ¸è¿›å¼çš„ä»£ç ç”Ÿæˆæ–¹å¼ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„ä»£ç éƒ½æ˜¯å¯ç¼–è¯‘ã€å¯æµ‹è¯•çš„ã€‚

**ç”Ÿæˆé˜¶æ®µè§„åˆ’**:
```
é˜¶æ®µ1ï¼šæ¥å£å’Œæ•°æ®ç»“æ„ (å¯ç¼–è¯‘)
â”œâ”€â”€ å¤´æ–‡ä»¶å®šä¹‰
â”œâ”€â”€ æ¥å£å£°æ˜
â”œâ”€â”€ æ•°æ®ç»“æ„å®šä¹‰
â””â”€â”€ åŸºç¡€å¼‚å¸¸ç±»

é˜¶æ®µ2ï¼šæ ¸å¿ƒå®ç°éª¨æ¶ (å¯è¿è¡Œ)
â”œâ”€â”€ ç±»çš„åŸºæœ¬å®ç°
â”œâ”€â”€ æ–¹æ³•çš„ç©ºå®ç°æˆ–ç®€å•å®ç°
â”œâ”€â”€ åŸºç¡€çš„é”™è¯¯å¤„ç†
â””â”€â”€ ç®€å•çš„å•å…ƒæµ‹è¯•

é˜¶æ®µ3ï¼šå®Œæ•´åŠŸèƒ½å®ç° (åŠŸèƒ½å®Œæ•´)
â”œâ”€â”€ æ ¸å¿ƒç®—æ³•å®ç°
â”œâ”€â”€ å®Œæ•´çš„é”™è¯¯å¤„ç†
â”œâ”€â”€ æ€§èƒ½ä¼˜åŒ–
â””â”€â”€ å®Œæ•´çš„æµ‹è¯•å¥—ä»¶

é˜¶æ®µ4ï¼šé›†æˆå’Œä¼˜åŒ– (ç”Ÿäº§å°±ç»ª)
â”œâ”€â”€ ä¸å…¶ä»–æ¨¡å—çš„é›†æˆ
â”œâ”€â”€ é…ç½®æ–‡ä»¶æ”¯æŒ
â”œâ”€â”€ æ—¥å¿—å’Œç›‘æ§
â””â”€â”€ æ–‡æ¡£å’Œç¤ºä¾‹
```

---

## ğŸ—ï¸ ä»£ç ç»“æ„çš„æ™ºèƒ½è®¾è®¡

### æ–‡ä»¶ç»„ç»‡çš„æ™ºèƒ½åŒ–

AIå¿…é¡»éµå¾ªæ¸…æ™°çš„æ–‡ä»¶ç»„ç»‡åŸåˆ™ï¼Œç¡®ä¿ä»£ç ç»“æ„çš„å¯ç»´æŠ¤æ€§ã€‚

**æ–‡ä»¶ç»„ç»‡ç­–ç•¥**:
```
æ¨¡å—æ–‡ä»¶ç»“æ„ï¼š
src/modules/[module_name]/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ interfaces/          # å…¬å…±æ¥å£å®šä¹‰
â”‚   â”‚   â””â”€â”€ i_auth_service.h
â”‚   â”œâ”€â”€ types/              # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â”‚   â””â”€â”€ auth_types.h
â”‚   â””â”€â”€ [module_name].h     # æ¨¡å—ä¸»å¤´æ–‡ä»¶
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ strategies/         # ç­–ç•¥å®ç°
â”‚   â”‚   â”œâ”€â”€ password_auth.cpp
â”‚   â”‚   â””â”€â”€ token_auth.cpp
â”‚   â”œâ”€â”€ factories/          # å·¥å‚ç±»å®ç°
â”‚   â”‚   â””â”€â”€ auth_factory.cpp
â”‚   â””â”€â”€ auth_service.cpp    # ä¸»æœåŠ¡å®ç°
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/               # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_password_auth.cpp
â”‚   â”‚   â””â”€â”€ test_token_auth.cpp
â”‚   â””â”€â”€ integration/        # é›†æˆæµ‹è¯•
â”‚       â””â”€â”€ test_auth_service.cpp
â””â”€â”€ configs/
    â””â”€â”€ auth_config.yaml    # é…ç½®æ–‡ä»¶ç¤ºä¾‹
```

### ä»£ç å±‚æ¬¡çš„æ™ºèƒ½è®¾è®¡

AIç”Ÿæˆçš„ä»£ç å¿…é¡»å…·æœ‰æ¸…æ™°çš„å±‚æ¬¡ç»“æ„ã€‚

**å±‚æ¬¡è®¾è®¡åŸåˆ™**:
```
è¡¨ç¤ºå±‚ (Presentation Layer)
â”œâ”€â”€ APIæ§åˆ¶å™¨ï¼šå¤„ç†HTTPè¯·æ±‚
â”œâ”€â”€ æ•°æ®éªŒè¯ï¼šè¾“å…¥å‚æ•°æ ¡éªŒ
â””â”€â”€ å“åº”æ ¼å¼åŒ–ï¼šç»Ÿä¸€çš„å“åº”æ ¼å¼

ä¸šåŠ¡å±‚ (Business Layer)
â”œâ”€â”€ æœåŠ¡ç±»ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”œâ”€â”€ ç­–ç•¥å®ç°ï¼šç®—æ³•å’Œè§„åˆ™
â””â”€â”€ å·¥ä½œæµç¼–æ’ï¼šå¤æ‚ä¸šåŠ¡æµç¨‹

æ•°æ®å±‚ (Data Layer)
â”œâ”€â”€ ä»“å‚¨æ¥å£ï¼šæ•°æ®è®¿é—®æŠ½è±¡
â”œâ”€â”€ å®ä½“æ¨¡å‹ï¼šä¸šåŠ¡æ•°æ®æ¨¡å‹
â””â”€â”€ æ•°æ®è½¬æ¢ï¼šå†…å¤–éƒ¨æ•°æ®æ ¼å¼è½¬æ¢

åŸºç¡€å±‚ (Infrastructure Layer)
â”œâ”€â”€ é…ç½®ç®¡ç†ï¼šç³»ç»Ÿé…ç½®åŠ è½½
â”œâ”€â”€ æ—¥å¿—è®°å½•ï¼šç»“æ„åŒ–æ—¥å¿—
â””â”€â”€ å¼‚å¸¸å¤„ç†ï¼šç»Ÿä¸€å¼‚å¸¸ç®¡ç†
```

**åˆ†å±‚å®ç°ç¤ºä¾‹**:
```cpp
// è¡¨ç¤ºå±‚ï¼šAPIæ§åˆ¶å™¨
class AuthController {
public:
    HttpResponse authenticate(const HttpRequest& request) {
        try {
            // è¾“å…¥éªŒè¯
            auto authRequest = validateAndParse(request);

            // è°ƒç”¨ä¸šåŠ¡å±‚
            auto result = authService_->authenticate(authRequest);

            // æ ¼å¼åŒ–å“åº”
            return formatResponse(result);
        } catch (const ValidationException& e) {
            return HttpResponse::badRequest(e.what());
        } catch (const AuthenticationException& e) {
            return HttpResponse::unauthorized(e.what());
        }
    }
};

// ä¸šåŠ¡å±‚ï¼šæ ¸å¿ƒæœåŠ¡
class AuthenticationService : public IAuthService {
public:
    AuthResult authenticate(const AuthRequest& request) override {
        // ç­–ç•¥é€‰æ‹©
        auto strategy = strategyFactory_->createStrategy(request.type);

        // æ‰§è¡Œè®¤è¯
        auto user = strategy->authenticate(request);

        // ç”Ÿæˆä¼šè¯
        auto session = sessionManager_->createSession(user);

        return AuthResult{user, session};
    }
};

// æ•°æ®å±‚ï¼šä»“å‚¨å®ç°
class UserRepository : public IUserRepository {
public:
    std::optional<User> findByEmail(const std::string& email) override {
        auto sql = "SELECT * FROM users WHERE email = ?";
        auto result = database_->execute(sql, email);
        return result.empty() ? std::nullopt :
               std::make_optional(mapToUser(result[0]));
    }
};
```

---

## ğŸ”§ ä»£ç è´¨é‡çš„æ™ºèƒ½ä¿è¯

### ç¼–ç è§„èŒƒçš„è‡ªåŠ¨åº”ç”¨

AIå¿…é¡»è‡ªåŠ¨åº”ç”¨é¡¹ç›®çš„ç¼–ç è§„èŒƒï¼Œç¡®ä¿ä»£ç é£æ ¼çš„ä¸€è‡´æ€§ã€‚

**è§„èŒƒæ£€æŸ¥æ¸…å•**:
```
å‘½åè§„èŒƒï¼š
â–¡ ç±»åä½¿ç”¨å¸•æ–¯å¡å‘½åæ³• (PascalCase)
â–¡ æ–¹æ³•åä½¿ç”¨é©¼å³°å‘½åæ³• (camelCase)
â–¡ å˜é‡åä½¿ç”¨é©¼å³°å‘½åæ³•ï¼Œå‰ç¼€è¡¨æ˜ä½œç”¨åŸŸ
â–¡ å¸¸é‡ä½¿ç”¨å…¨å¤§å†™ä¸‹åˆ’çº¿åˆ†éš” (UPPER_CASE)
â–¡ ç§æœ‰æˆå‘˜å˜é‡ä½¿ç”¨ä¸‹åˆ’çº¿åç¼€ (member_)

æ³¨é‡Šè§„èŒƒï¼š
â–¡ ç±»å’Œæ¥å£ä½¿ç”¨Doxygenæ ¼å¼æ³¨é‡Š
â–¡ å…¬å…±æ–¹æ³•åŒ…å«å‚æ•°å’Œè¿”å›å€¼è¯´æ˜
â–¡ å¤æ‚ç®—æ³•åŒ…å«é€»è¾‘è¯´æ˜æ³¨é‡Š
â–¡ TODO/FIXMEæ³¨é‡ŠåŒ…å«è´£ä»»äººå’Œæ—¶é—´

ä»£ç ç»“æ„ï¼š
â–¡ å¤´æ–‡ä»¶åŒ…å«é˜²æŠ¤å®æˆ–#pragma once
â–¡ includeé¡ºåºï¼šç³»ç»Ÿå¤´æ–‡ä»¶ â†’ ç¬¬ä¸‰æ–¹ â†’ é¡¹ç›®å¤´æ–‡ä»¶
â–¡ å‡½æ•°é•¿åº¦ä¸è¶…è¿‡50è¡Œï¼Œç±»é•¿åº¦ä¸è¶…è¿‡500è¡Œ
â–¡ åœˆå¤æ‚åº¦ä¸è¶…è¿‡10
```

**è‡ªåŠ¨è§„èŒƒåº”ç”¨ç¤ºä¾‹**:
```cpp
/**
 * @brief ç”¨æˆ·è®¤è¯æœåŠ¡å®ç°
 *
 * æä¾›å¤šç§è®¤è¯ç­–ç•¥çš„ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒå¯†ç è®¤è¯å’ŒTokenè®¤è¯ã€‚
 *
 * @author AI Generator
 * @date 2025-09-11
 * @version 1.0
 */
class AuthenticationService : public IAuthService {
private:
    std::shared_ptr<IUserRepository> userRepository_;          // ç”¨æˆ·æ•°æ®ä»“å‚¨
    std::shared_ptr<IAuthStrategyFactory> strategyFactory_;    // è®¤è¯ç­–ç•¥å·¥å‚
    std::shared_ptr<ISessionManager> sessionManager_;         // ä¼šè¯ç®¡ç†å™¨

public:
    /**
     * @brief æ„é€ å‡½æ•°
     *
     * @param userRepo ç”¨æˆ·æ•°æ®ä»“å‚¨æ¥å£
     * @param strategyFactory è®¤è¯ç­–ç•¥å·¥å‚æ¥å£
     * @param sessionMgr ä¼šè¯ç®¡ç†å™¨æ¥å£
     */
    AuthenticationService(
        std::shared_ptr<IUserRepository> userRepo,
        std::shared_ptr<IAuthStrategyFactory> strategyFactory,
        std::shared_ptr<ISessionManager> sessionMgr
    ) : userRepository_(std::move(userRepo)),
        strategyFactory_(std::move(strategyFactory)),
        sessionManager_(std::move(sessionMgr)) {}

    /**
     * @brief æ‰§è¡Œç”¨æˆ·è®¤è¯
     *
     * @param request è®¤è¯è¯·æ±‚ï¼ŒåŒ…å«è®¤è¯ç±»å‹å’Œå‡­æ®
     * @return AuthResult è®¤è¯ç»“æœï¼ŒåŒ…å«ç”¨æˆ·ä¿¡æ¯å’Œä¼šè¯
     * @throws AuthenticationException å½“è®¤è¯å¤±è´¥æ—¶æŠ›å‡º
     * @throws ValidationException å½“è¾“å…¥å‚æ•°æ— æ•ˆæ—¶æŠ›å‡º
     */
    AuthResult authenticate(const AuthRequest& request) override;
};
```

### é”™è¯¯å¤„ç†çš„æ™ºèƒ½åŒ–

AIå¿…é¡»ä¸ºç”Ÿæˆçš„ä»£ç æä¾›å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚

**é”™è¯¯å¤„ç†ç­–ç•¥**:
```
å¼‚å¸¸å±‚æ¬¡è®¾è®¡ï¼š
BaseException
â”œâ”€â”€ ValidationException      # è¾“å…¥éªŒè¯é”™è¯¯
â”‚   â”œâ”€â”€ InvalidFormatException
â”‚   â””â”€â”€ MissingParameterException
â”œâ”€â”€ AuthenticationException  # è®¤è¯ç›¸å…³é”™è¯¯
â”‚   â”œâ”€â”€ InvalidCredentialsException
â”‚   â”œâ”€â”€ AccountLockedException
â”‚   â””â”€â”€ TokenExpiredException
â”œâ”€â”€ AuthorizationException   # æˆæƒç›¸å…³é”™è¯¯
â”‚   â”œâ”€â”€ InsufficientPermissionException
â”‚   â””â”€â”€ ResourceNotFoundException
â””â”€â”€ SystemException         # ç³»ç»Ÿçº§é”™è¯¯
    â”œâ”€â”€ DatabaseException
    â”œâ”€â”€ NetworkException
    â””â”€â”€ ConfigurationException
```

**é”™è¯¯å¤„ç†å®ç°ç¤ºä¾‹**:
```cpp
AuthResult AuthenticationService::authenticate(const AuthRequest& request) {
    try {
        // è¾“å…¥éªŒè¯
        validateAuthRequest(request);

        // è·å–è®¤è¯ç­–ç•¥
        auto strategy = strategyFactory_->createStrategy(request.type);
        if (!strategy) {
            throw ValidationException("Unsupported authentication type: "
                                    + std::to_string(request.type));
        }

        // æ‰§è¡Œè®¤è¯
        auto user = strategy->authenticate(request);
        if (!user) {
            throw InvalidCredentialsException("Invalid credentials provided");
        }

        // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
        if (user->isLocked()) {
            throw AccountLockedException("Account is locked. Contact administrator.");
        }

        // åˆ›å»ºä¼šè¯
        auto session = sessionManager_->createSession(*user);

        // è®°å½•æˆåŠŸæ—¥å¿—
        logger_->info("User {} authenticated successfully", user->email);

        return AuthResult{*user, session};

    } catch (const DatabaseException& e) {
        logger_->error("Database error during authentication: {}", e.what());
        throw SystemException("Authentication service temporarily unavailable");
    } catch (const std::exception& e) {
        logger_->error("Unexpected error during authentication: {}", e.what());
        throw SystemException("Internal authentication error");
    }
}
```

### æ€§èƒ½ä¼˜åŒ–çš„æ™ºèƒ½åŒ–

AIå¿…é¡»åœ¨ä»£ç ç”Ÿæˆè¿‡ç¨‹ä¸­è€ƒè™‘æ€§èƒ½ä¼˜åŒ–ã€‚

**æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**:
```
å†…å­˜ç®¡ç†ä¼˜åŒ–ï¼š
â”œâ”€â”€ ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆé¿å…å†…å­˜æ³„æ¼
â”œâ”€â”€ å¯¹è±¡æ± å‡å°‘é¢‘ç¹åˆ†é…
â”œâ”€â”€ ç§»åŠ¨è¯­ä¹‰å‡å°‘ä¸å¿…è¦æ‹·è´
â””â”€â”€ RAIIæ¨¡å¼ç¡®ä¿èµ„æºæ¸…ç†

ç®—æ³•ä¼˜åŒ–ï¼š
â”œâ”€â”€ æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–ï¼ˆç¼“å­˜ã€ç´¢å¼•ï¼‰
â”œâ”€â”€ ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–ï¼ˆæµå¼å¤„ç†ï¼‰
â”œâ”€â”€ å¹¶å‘ä¼˜åŒ–ï¼ˆçº¿ç¨‹æ± ã€æ— é”ç»“æ„ï¼‰
â””â”€â”€ æ‰¹å¤„ç†ä¼˜åŒ–ï¼ˆå‡å°‘ç³»ç»Ÿè°ƒç”¨ï¼‰

I/Oä¼˜åŒ–ï¼š
â”œâ”€â”€ å¼‚æ­¥I/Oé¿å…é˜»å¡
â”œâ”€â”€ è¿æ¥æ± å¤ç”¨è¿æ¥
â”œâ”€â”€ ç¼“å­˜ç­–ç•¥å‡å°‘é‡å¤è®¿é—®
â””â”€â”€ å‹ç¼©ä¼ è¾“å‡å°‘ç½‘ç»œå¼€é”€
```

**æ€§èƒ½ä¼˜åŒ–å®ç°ç¤ºä¾‹**:
```cpp
class AuthenticationService {
private:
    // ç¼“å­˜è®¤è¯ç»“æœï¼Œé¿å…é‡å¤éªŒè¯
    mutable std::shared_mutex cacheMutex_;
    std::unordered_map<std::string, std::pair<AuthResult, std::chrono::time_point<std::chrono::steady_clock>>> authCache_;

    // å¯¹è±¡æ± ï¼Œå‡å°‘Tokenè§£æçš„å†…å­˜åˆ†é…
    mutable ObjectPool<TokenParser> tokenParserPool_;

public:
    AuthResult authenticate(const AuthRequest& request) override {
        // æ£€æŸ¥ç¼“å­˜ï¼ˆè¯»é”ï¼‰
        {
            std::shared_lock<std::shared_mutex> lock(cacheMutex_);
            auto it = authCache_.find(request.cacheKey());
            if (it != authCache_.end() && !isExpired(it->second.second)) {
                return it->second.first;  // ç¼“å­˜å‘½ä¸­ï¼Œç›´æ¥è¿”å›
            }
        }

        // æ‰§è¡Œè®¤è¯é€»è¾‘
        auto result = performAuthentication(request);

        // æ›´æ–°ç¼“å­˜ï¼ˆå†™é”ï¼‰
        {
            std::unique_lock<std::shared_mutex> lock(cacheMutex_);
            authCache_[request.cacheKey()] = {result, std::chrono::steady_clock::now()};
        }

        return result;
    }

private:
    AuthResult performAuthentication(const AuthRequest& request) {
        // ä½¿ç”¨å¯¹è±¡æ± è·å–Tokenè§£æå™¨
        auto parser = tokenParserPool_.acquire();

        // å¼‚æ­¥æ‰§è¡Œè€—æ—¶æ“ä½œ
        auto userFuture = std::async(std::launch::async, [this, &request]() {
            return userRepository_->findByEmail(request.email);
        });

        auto validationFuture = std::async(std::launch::async, [&parser, &request]() {
            return parser->validateToken(request.token);
        });

        // ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ
        auto user = userFuture.get();
        auto isValidToken = validationFuture.get();

        // å½’è¿˜å¯¹è±¡åˆ°æ± ä¸­
        tokenParserPool_.release(std::move(parser));

        if (user && isValidToken) {
            return AuthResult{*user, createSession(*user)};
        } else {
            throw InvalidCredentialsException("Authentication failed");
        }
    }
};
```

---

## ğŸ§ª æµ‹è¯•ä»£ç çš„æ™ºèƒ½ç”Ÿæˆ

### æµ‹è¯•ç­–ç•¥çš„æ™ºèƒ½è®¾è®¡

AIå¿…é¡»ä¸ºç”Ÿæˆçš„ä»£ç è‡ªåŠ¨åˆ›å»ºå®Œæ•´çš„æµ‹è¯•å¥—ä»¶ã€‚

**æµ‹è¯•è¦†ç›–ç­–ç•¥**:
```
å•å…ƒæµ‹è¯•è¦†ç›–ï¼š
â”œâ”€â”€ æ­£å¸¸è·¯å¾„æµ‹è¯• (Happy Path)
â”œâ”€â”€ è¾¹ç•Œæ¡ä»¶æµ‹è¯• (Boundary Cases)
â”œâ”€â”€ å¼‚å¸¸æƒ…å†µæµ‹è¯• (Exception Cases)
â””â”€â”€ æ€§èƒ½åŸºå‡†æµ‹è¯• (Performance Benchmarks)

é›†æˆæµ‹è¯•è¦†ç›–ï¼š
â”œâ”€â”€ æ¨¡å—é—´æ¥å£æµ‹è¯•
â”œâ”€â”€ æ•°æ®æµå®Œæ•´æ€§æµ‹è¯•
â”œâ”€â”€ ç«¯åˆ°ç«¯ä¸šåŠ¡æµç¨‹æµ‹è¯•
â””â”€â”€ å¹¶å‘åœºæ™¯æµ‹è¯•

æµ‹è¯•æ•°æ®ç®¡ç†ï¼š
â”œâ”€â”€ æµ‹è¯•å¤¹å…· (Test Fixtures)
â”œâ”€â”€ Mockå¯¹è±¡åˆ›å»º
â”œâ”€â”€ æµ‹è¯•æ•°æ®ç”Ÿæˆ
â””â”€â”€ æµ‹è¯•ç¯å¢ƒéš”ç¦»
```

**æµ‹è¯•ä»£ç ç”Ÿæˆç¤ºä¾‹**:
```cpp
/**
 * @brief AuthenticationServiceå•å…ƒæµ‹è¯•
 */
class AuthenticationServiceTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºMockå¯¹è±¡
        mockUserRepo_ = std::make_shared<MockUserRepository>();
        mockStrategyFactory_ = std::make_shared<MockAuthStrategyFactory>();
        mockSessionManager_ = std::make_shared<MockSessionManager>();

        // åˆ›å»ºè¢«æµ‹è¯•å¯¹è±¡
        authService_ = std::make_unique<AuthenticationService>(
            mockUserRepo_, mockStrategyFactory_, mockSessionManager_
        );
    }

    std::shared_ptr<MockUserRepository> mockUserRepo_;
    std::shared_ptr<MockAuthStrategyFactory> mockStrategyFactory_;
    std::shared_ptr<MockSessionManager> mockSessionManager_;
    std::unique_ptr<AuthenticationService> authService_;
};

TEST_F(AuthenticationServiceTest, AuthenticateWithValidCredentials_ShouldReturnSuccess) {
    // Arrange
    AuthRequest request{AuthType::PASSWORD, "user@example.com", "password123"};
    User expectedUser{"123", "user@example.com", "John Doe"};
    Session expectedSession{"session_123", "123"};

    auto mockStrategy = std::make_shared<MockPasswordAuthStrategy>();
    EXPECT_CALL(*mockStrategyFactory_, createStrategy(AuthType::PASSWORD))
        .WillOnce(Return(mockStrategy));
    EXPECT_CALL(*mockStrategy, authenticate(request))
        .WillOnce(Return(expectedUser));
    EXPECT_CALL(*mockSessionManager_, createSession(expectedUser))
        .WillOnce(Return(expectedSession));

    // Act
    auto result = authService_->authenticate(request);

    // Assert
    EXPECT_EQ(result.user.id, expectedUser.id);
    EXPECT_EQ(result.session.id, expectedSession.id);
}

TEST_F(AuthenticationServiceTest, AuthenticateWithInvalidCredentials_ShouldThrowException) {
    // Arrange
    AuthRequest request{AuthType::PASSWORD, "user@example.com", "wrongpassword"};

    auto mockStrategy = std::make_shared<MockPasswordAuthStrategy>();
    EXPECT_CALL(*mockStrategyFactory_, createStrategy(AuthType::PASSWORD))
        .WillOnce(Return(mockStrategy));
    EXPECT_CALL(*mockStrategy, authenticate(request))
        .WillOnce(Throw(InvalidCredentialsException("Invalid password")));

    // Act & Assert
    EXPECT_THROW(authService_->authenticate(request), InvalidCredentialsException);
}

TEST_F(AuthenticationServiceTest, AuthenticatePerformance_ShouldMeetLatencyRequirement) {
    // Arrange
    AuthRequest request{AuthType::TOKEN, "user@example.com", "valid_token"};
    setupMockForSuccessfulAuth(request);

    // Act - æ‰§è¡Œå¤šæ¬¡æµ‹è¯•ä»¥è·å¾—ç¨³å®šçš„æ€§èƒ½æ•°æ®
    const int iterations = 1000;
    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < iterations; ++i) {
        authService_->authenticate(request);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto avgDuration = std::chrono::duration_cast<std::chrono::microseconds>(
        end - start) / iterations;

    // Assert - å¹³å‡å»¶è¿Ÿåº”å°äº1æ¯«ç§’
    EXPECT_LT(avgDuration.count(), 1000) << "Authentication latency too high: "
                                        << avgDuration.count() << " microseconds";
}
```

---

## ğŸ“¦ å®Œæ•´äº¤ä»˜çš„æ™ºèƒ½åŒ–

### æ„å»ºé…ç½®çš„è‡ªåŠ¨ç”Ÿæˆ

AIå¿…é¡»ä¸ºç”Ÿæˆçš„ä»£ç æä¾›å®Œæ•´çš„æ„å»ºé…ç½®ã€‚

**CMakeLists.txtç”Ÿæˆç¤ºä¾‹**:
```cmake
# è®¤è¯æ¨¡å—CMakeLists.txt - AIè‡ªåŠ¨ç”Ÿæˆ
cmake_minimum_required(VERSION 3.16)

# è®¾ç½®æ¨¡å—åç§°
set(MODULE_NAME authentication)
project(${MODULE_NAME})

# è®¾ç½®C++æ ‡å‡†
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# åŒ…å«ç›®å½•
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../common/include
)

# æºæ–‡ä»¶
set(SOURCES
    src/auth_service.cpp
    src/strategies/password_auth.cpp
    src/strategies/token_auth.cpp
    src/factories/auth_factory.cpp
)

# å¤´æ–‡ä»¶
set(HEADERS
    include/interfaces/i_auth_service.h
    include/types/auth_types.h
    include/authentication.h
)

# åˆ›å»ºé™æ€åº“
add_library(${MODULE_NAME} STATIC ${SOURCES} ${HEADERS})

# é“¾æ¥ä¾èµ–
target_link_libraries(${MODULE_NAME}
    common
    database
    crypto
    ${OPENSSL_LIBRARIES}
)

# ç¼–è¯‘é€‰é¡¹
target_compile_options(${MODULE_NAME} PRIVATE
    -Wall -Wextra -Werror
    $<$<CONFIG:Debug>:-g -O0>
    $<$<CONFIG:Release>:-O3 -DNDEBUG>
)

# æµ‹è¯•ç›®æ ‡
if(BUILD_TESTS)
    add_subdirectory(tests)
endif()

# å®‰è£…é…ç½®
install(TARGETS ${MODULE_NAME}
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
)

install(DIRECTORY include/
    DESTINATION include
    FILES_MATCHING PATTERN "*.h"
)
```

### é…ç½®æ–‡ä»¶çš„æ™ºèƒ½ç”Ÿæˆ

AIåº”è¯¥ç”Ÿæˆç›¸åº”çš„é…ç½®æ–‡ä»¶æ¨¡æ¿ã€‚

**é…ç½®æ–‡ä»¶ç”Ÿæˆç¤ºä¾‹**:
```yaml
# è®¤è¯æ¨¡å—é…ç½® - AIè‡ªåŠ¨ç”Ÿæˆ
authentication:
  # å¯†ç è®¤è¯é…ç½®
  password:
    hash_algorithm: "bcrypt"          # å“ˆå¸Œç®—æ³•ï¼šbcrypt, scrypt, argon2
    hash_cost: 12                     # å“ˆå¸Œæˆæœ¬å› å­
    min_password_length: 8            # æœ€å°å¯†ç é•¿åº¦
    max_login_attempts: 5             # æœ€å¤§ç™»å½•å°è¯•æ¬¡æ•°
    lockout_duration: "15m"           # è´¦æˆ·é”å®šæ—¶é•¿

  # Tokenè®¤è¯é…ç½®
  token:
    secret_key: "${JWT_SECRET_KEY}"   # JWTå¯†é’¥ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼‰
    expiry_duration: "24h"            # Tokenè¿‡æœŸæ—¶é—´
    refresh_threshold: "1h"           # åˆ·æ–°é˜ˆå€¼
    issuer: "my-app"                  # å‘è¡Œè€…

  # ä¼šè¯ç®¡ç†é…ç½®
  session:
    storage_type: "redis"             # å­˜å‚¨ç±»å‹ï¼šmemory, redis, database
    redis_url: "${REDIS_URL}"         # Redisè¿æ¥URL
    session_timeout: "30m"            # ä¼šè¯è¶…æ—¶æ—¶é—´
    cleanup_interval: "5m"            # æ¸…ç†é—´éš”

  # ç¼“å­˜é…ç½®
  cache:
    enabled: true                     # æ˜¯å¦å¯ç”¨ç¼“å­˜
    ttl: "5m"                        # ç¼“å­˜ç”Ÿå­˜æ—¶é—´
    max_size: 10000                  # æœ€å¤§ç¼“å­˜æ¡ç›®æ•°

  # æ—¥å¿—é…ç½®
  logging:
    level: "info"                    # æ—¥å¿—çº§åˆ«ï¼šdebug, info, warn, error
    audit_enabled: true              # æ˜¯å¦å¯ç”¨å®¡è®¡æ—¥å¿—
    audit_file: "/var/log/auth_audit.log"  # å®¡è®¡æ—¥å¿—æ–‡ä»¶
```

### ä½¿ç”¨æ–‡æ¡£çš„æ™ºèƒ½ç”Ÿæˆ

AIåº”è¯¥ç”Ÿæˆå®Œæ•´çš„ä½¿ç”¨æ–‡æ¡£ã€‚

**README.mdç”Ÿæˆç¤ºä¾‹**:
```markdown
# è®¤è¯æ¨¡å— (Authentication Module)

## æ¦‚è¿°

è®¤è¯æ¨¡å—æä¾›äº†ç»Ÿä¸€çš„ç”¨æˆ·è®¤è¯æ¥å£ï¼Œæ”¯æŒå¯†ç è®¤è¯å’ŒTokenè®¤è¯ä¸¤ç§æ–¹å¼ã€‚

## ç‰¹æ€§

- âœ… å¤šç§è®¤è¯ç­–ç•¥ï¼ˆå¯†ç ã€Tokenï¼‰
- âœ… ä¼šè¯ç®¡ç†
- âœ… è®¤è¯ç»“æœç¼“å­˜
- âœ… è´¦æˆ·é”å®šä¿æŠ¤
- âœ… å®¡è®¡æ—¥å¿—è®°å½•
- âœ… é«˜æ€§èƒ½å¼‚æ­¥å¤„ç†

## å¿«é€Ÿå¼€å§‹

### 1. ç¼–è¯‘å®‰è£…

```bash
mkdir build && cd build
cmake .. -DBUILD_TESTS=ON
make -j4
make install
```

### 2. é…ç½®

å¤åˆ¶é…ç½®æ–‡ä»¶æ¨¡æ¿å¹¶ä¿®æ”¹ï¼š
```bash
cp configs/auth_config.yaml.template /etc/myapp/auth_config.yaml
# ç¼–è¾‘é…ç½®æ–‡ä»¶ï¼Œè®¾ç½®æ•°æ®åº“è¿æ¥ã€JWTå¯†é’¥ç­‰
```

### 3. ä½¿ç”¨ç¤ºä¾‹

```cpp
#include "authentication.h"

int main() {
    // åˆ›å»ºä¾èµ–å¯¹è±¡
    auto userRepo = std::make_shared<DatabaseUserRepository>();
    auto strategyFactory = std::make_shared<AuthStrategyFactory>();
    auto sessionManager = std::make_shared<RedisSessionManager>();

    // åˆ›å»ºè®¤è¯æœåŠ¡
    auto authService = std::make_unique<AuthenticationService>(
        userRepo, strategyFactory, sessionManager
    );

    try {
        // æ‰§è¡Œè®¤è¯
        AuthRequest request{AuthType::PASSWORD, "user@example.com", "password123"};
        auto result = authService->authenticate(request);

        std::cout << "Authentication successful: " << result.user.name << std::endl;
        std::cout << "Session ID: " << result.session.id << std::endl;

    } catch (const AuthenticationException& e) {
        std::cerr << "Authentication failed: " << e.what() << std::endl;
    }

    return 0;
}
```

## API å‚è€ƒ

### AuthenticationService

ä¸»è¦çš„è®¤è¯æœåŠ¡ç±»ï¼Œæä¾›ç»Ÿä¸€çš„è®¤è¯æ¥å£ã€‚

#### æ–¹æ³•

- `AuthResult authenticate(const AuthRequest& request)`
  - æ‰§è¡Œç”¨æˆ·è®¤è¯
  - å‚æ•°ï¼š`request` - è®¤è¯è¯·æ±‚ï¼ŒåŒ…å«è®¤è¯ç±»å‹å’Œå‡­æ®
  - è¿”å›ï¼š`AuthResult` - è®¤è¯ç»“æœï¼ŒåŒ…å«ç”¨æˆ·ä¿¡æ¯å’Œä¼šè¯
  - å¼‚å¸¸ï¼š`AuthenticationException` - å½“è®¤è¯å¤±è´¥æ—¶

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦                                 |
| :--- | :--------- | :----- | :--------------------------------------- |
| v1.0 | 2025-09-11 | Kelin  | åˆ›å»ºAIæ™ºèƒ½ä»£ç ç”Ÿæˆæ€ç»´ä¸è´¨é‡ä¿è¯æµç¨‹æ–‡æ¡£ |
