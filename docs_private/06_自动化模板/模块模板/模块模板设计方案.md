# 模块模板设计方案

- **标题**: AI协作开发标准化模块模板方案
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 设计目标

### 🎯 核心目标
- **标准化代码结构**: 确保所有模块遵循统一的代码组织方式
- **AI友好的模板**: 便于AI理解和复用的模板结构
- **快速开发**: 减少重复性代码编写，提高开发效率
- **质量保证**: 内置最佳实践和错误处理机制
- **可维护性**: 清晰的模块接口和实现分离

### 📋 模板清单
1. **接口类模板.hpp** - 标准接口类定义模板
2. **实现类模板.cpp** - 接口实现类模板
3. **单元测试模板.cpp** - 单元测试文件模板
4. **CMakeLists模板.txt** - 模块构建配置模板

---

## 接口类模板设计

### 📁 接口类模板.hpp

#### 模板特点
```cpp
// 标准化头文件结构
#pragma once

// 系统头文件
#include <memory>
#include <string>
#include <vector>

// 项目头文件
#include "common/types.h"
#include "common/error_codes.h"
#include "interfaces/module_interface.h"

namespace radar::{MODULE_NAMESPACE} {

/**
 * @brief {MODULE_DESCRIPTION}
 *
 * 详细描述模块功能和使用方法
 *
 * @example
 * auto module = std::make_unique<{MODULE_NAME}Impl>();
 * module->initialize(config);
 * auto result = module->process(data);
 */
class {MODULE_NAME}Interface : public ModuleInterface {
public:
    // 构造函数和析构函数
    {MODULE_NAME}Interface() = default;
    virtual ~{MODULE_NAME}Interface() = default;

    // 禁用拷贝构造和赋值
    {MODULE_NAME}Interface(const {MODULE_NAME}Interface&) = delete;
    {MODULE_NAME}Interface& operator=(const {MODULE_NAME}Interface&) = delete;

    // 核心接口方法
    virtual ErrorCode initialize(const Config& config) = 0;
    virtual ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) = 0;
    virtual ErrorCode cleanup() = 0;

    // 状态查询方法
    virtual bool is_initialized() const = 0;
    virtual ModuleStatus get_status() const = 0;

    // 工厂方法
    static std::unique_ptr<{MODULE_NAME}Interface> create();
};

} // namespace radar::{MODULE_NAMESPACE}
```

#### 设计原则
- **接口分离**: 纯虚函数定义，不包含实现
- **RAII管理**: 明确的生命周期管理
- **错误处理**: 统一的错误码返回机制
- **状态查询**: 提供模块状态查询能力
- **工厂模式**: 通过工厂方法创建实例

---

## 实现类模板设计

### 📁 实现类模板.cpp

#### 模板特点
```cpp
#include "{MODULE_NAME_LOWER}_interface.h"
#include "common/logging.h"
#include "common/config_wrapper.h"

namespace radar::{MODULE_NAMESPACE} {

class {MODULE_NAME}Impl : public {MODULE_NAME}Interface {
public:
    {MODULE_NAME}Impl();
    ~{MODULE_NAME}Impl() override;

    // 接口实现
    ErrorCode initialize(const Config& config) override;
    ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) override;
    ErrorCode cleanup() override;

    // 状态查询
    bool is_initialized() const override { return is_initialized_; }
    ModuleStatus get_status() const override { return status_; }

private:
    // 私有成员变量
    bool is_initialized_ = false;
    ModuleStatus status_ = ModuleStatus::Uninitialized;
    Config config_;

    // 私有成员函数
    ErrorCode validate_config(const Config& config);
    ErrorCode setup_resources();
    void release_resources();

    // 核心处理逻辑
    ErrorCode process_impl({INPUT_TYPE} input, {OUTPUT_TYPE}& output);
};

// 工厂方法实现
std::unique_ptr<{MODULE_NAME}Interface> {MODULE_NAME}Interface::create() {
    return std::make_unique<{MODULE_NAME}Impl>();
}

// 构造函数
{MODULE_NAME}Impl::{MODULE_NAME}Impl() {
    RADAR_DEBUG("Creating {MODULE_NAME} module");
}

// 析构函数
{MODULE_NAME}Impl::~{MODULE_NAME}Impl() {
    if (is_initialized_) {
        cleanup();
    }
    RADAR_DEBUG("Destroying {MODULE_NAME} module");
}

// 初始化实现
ErrorCode {MODULE_NAME}Impl::initialize(const Config& config) {
    RADAR_INFO("Initializing {MODULE_NAME} module");

    if (is_initialized_) {
        RADAR_WARN("{MODULE_NAME} already initialized");
        return ErrorCode::AlreadyInitialized;
    }

    // 验证配置
    auto error = validate_config(config);
    if (error != ErrorCode::Success) {
        return error;
    }

    config_ = config;

    // 设置资源
    error = setup_resources();
    if (error != ErrorCode::Success) {
        RADAR_ERROR("Failed to setup resources for {MODULE_NAME}");
        return error;
    }

    is_initialized_ = true;
    status_ = ModuleStatus::Ready;

    RADAR_INFO("{MODULE_NAME} module initialized successfully");
    return ErrorCode::Success;
}

} // namespace radar::{MODULE_NAMESPACE}
```

#### 设计原则
- **错误处理**: 完整的错误处理和日志记录
- **资源管理**: RAII和明确的资源生命周期
- **状态管理**: 清晰的状态转换逻辑
- **配置验证**: 输入参数的完整性检查
- **性能考虑**: 避免不必要的拷贝和分配

---

## 单元测试模板设计

### 📁 单元测试模板.cpp

#### 模板特点
```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "{MODULE_NAME_LOWER}_interface.h"
#include "tests/common/test_base.h"

using namespace radar::{MODULE_NAMESPACE};
using ::testing::_;
using ::testing::Return;

class {MODULE_NAME}Test : public radar::test::RadarTestBase {
protected:
    void SetUp() override {
        RadarTestBase::SetUp();

        // 创建测试实例
        module_ = {MODULE_NAME}Interface::create();
        ASSERT_NE(module_, nullptr);

        // 设置测试配置
        setup_test_config();
    }

    void TearDown() override {
        if (module_ && module_->is_initialized()) {
            module_->cleanup();
        }
        module_.reset();

        RadarTestBase::TearDown();
    }

    void setup_test_config() {
        test_config_.{CONFIG_PARAM_1} = {DEFAULT_VALUE_1};
        test_config_.{CONFIG_PARAM_2} = {DEFAULT_VALUE_2};
    }

    std::unique_ptr<{MODULE_NAME}Interface> module_;
    Config test_config_;
};

// 基础功能测试
TEST_F({MODULE_NAME}Test, Constructor) {
    EXPECT_FALSE(module_->is_initialized());
    EXPECT_EQ(module_->get_status(), ModuleStatus::Uninitialized);
}

TEST_F({MODULE_NAME}Test, InitializeSuccess) {
    auto result = module_->initialize(test_config_);

    EXPECT_EQ(result, ErrorCode::Success);
    EXPECT_TRUE(module_->is_initialized());
    EXPECT_EQ(module_->get_status(), ModuleStatus::Ready);
}

TEST_F({MODULE_NAME}Test, InitializeInvalidConfig) {
    Config invalid_config;
    // 设置无效配置

    auto result = module_->initialize(invalid_config);

    EXPECT_NE(result, ErrorCode::Success);
    EXPECT_FALSE(module_->is_initialized());
}

TEST_F({MODULE_NAME}Test, ProcessBeforeInitialize) {
    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    auto result = module_->process(input, output);

    EXPECT_EQ(result, ErrorCode::NotInitialized);
}

TEST_F({MODULE_NAME}Test, ProcessNormalInput) {
    // 初始化模块
    ASSERT_EQ(module_->initialize(test_config_), ErrorCode::Success);

    // 准备测试数据
    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    // 执行处理
    auto result = module_->process(input, output);

    // 验证结果
    EXPECT_EQ(result, ErrorCode::Success);
    EXPECT_TRUE(validate_output(output));
}

// 性能测试
TEST_F({MODULE_NAME}Test, PerformanceBenchmark) {
    ASSERT_EQ(module_->initialize(test_config_), ErrorCode::Success);

    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    auto start = std::chrono::high_resolution_clock::now();

    constexpr int iterations = 1000;
    for (int i = 0; i < iterations; ++i) {
        module_->process(input, output);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    auto avg_time = duration.count() / iterations;
    EXPECT_LT(avg_time, {PERFORMANCE_THRESHOLD_US}); // 性能阈值检查

    RADAR_INFO("Average processing time: {} μs", avg_time);
}

// 辅助函数
{INPUT_TYPE} {MODULE_NAME}Test::create_test_input() {
    // 创建测试输入数据
    {INPUT_TYPE} input;
    // 填充测试数据
    return input;
}

bool {MODULE_NAME}Test::validate_output(const {OUTPUT_TYPE}& output) {
    // 验证输出数据的正确性
    return true;
}
```

#### 设计原则
- **测试覆盖**: 正常流程、错误流程、边界条件
- **性能测试**: 内置性能基准测试
- **数据驱动**: 可配置的测试数据和阈值
- **Mock支持**: 为依赖项提供Mock机制
- **可维护性**: 清晰的测试结构和辅助函数

---

## 构建配置模板设计

### 📁 CMakeLists模板.txt

#### 模板特点
```cmake
# {MODULE_NAME} 模块构建配置
# 自动生成于 {GENERATION_DATE}

# 模块库定义
add_library(radar_{MODULE_NAME_LOWER})

# 源文件
target_sources(radar_{MODULE_NAME_LOWER}
    PRIVATE
        {MODULE_NAME_LOWER}_impl.cpp
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}/{MODULE_NAME_LOWER}_interface.h
)

# 包含目录
target_include_directories(radar_{MODULE_NAME_LOWER}
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_BINARY_DIR}/include
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
)

# 链接库
target_link_libraries(radar_{MODULE_NAME_LOWER}
    PUBLIC
        radar_common
        radar_interfaces
    PRIVATE
        spdlog::spdlog
        yaml-cpp
        ${MODULE_SPECIFIC_LIBS}
)

# 编译定义
target_compile_definitions(radar_{MODULE_NAME_LOWER}
    PRIVATE
        MODULE_NAME="{MODULE_NAME}"
        $<$<CONFIG:Debug>:DEBUG_BUILD>
        $<$<CONFIG:Release>:RELEASE_BUILD>
)

# 编译选项
target_compile_options(radar_{MODULE_NAME_LOWER}
    PRIVATE
        $<$<CXX_COMPILER_ID:GNU>:-Wall -Wextra -Wpedantic>
        $<$<CXX_COMPILER_ID:Clang>:-Wall -Wextra -Wpedantic>
        $<$<CXX_COMPILER_ID:MSVC>:/W4>
)

# 条件编译 - CUDA支持
if(ENABLE_CUDA AND {MODULE_USES_CUDA})
    enable_language(CUDA)

    target_sources(radar_{MODULE_NAME_LOWER}
        PRIVATE
            {MODULE_NAME_LOWER}_cuda.cu
    )

    set_target_properties(radar_{MODULE_NAME_LOWER} PROPERTIES
        CUDA_STANDARD 17
        CUDA_STANDARD_REQUIRED ON
        CUDA_SEPARABLE_COMPILATION ON
    )

    target_link_libraries(radar_{MODULE_NAME_LOWER}
        PRIVATE
            CUDA::cudart
            CUDA::cufft
    )
endif()

# 安装配置
install(TARGETS radar_{MODULE_NAME_LOWER}
    EXPORT RadarTargets
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

install(FILES
    ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}/{MODULE_NAME_LOWER}_interface.h
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/{MODULE_PATH}
)

# 测试配置
if(BUILD_TESTS)
    add_subdirectory(tests)
endif()

# 示例配置
if(BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()

# === 测试目标 ===
if(BUILD_TESTS)
    # 单元测试
    add_executable(test_{MODULE_NAME_LOWER}
        tests/test_{MODULE_NAME_LOWER}.cpp
    )

    target_link_libraries(test_{MODULE_NAME_LOWER}
        PRIVATE
            radar_{MODULE_NAME_LOWER}
            GTest::gtest
            GTest::gtest_main
            GTest::gmock
    )

    target_include_directories(test_{MODULE_NAME_LOWER}
        PRIVATE
            ${CMAKE_SOURCE_DIR}/tests/mock
    )

    add_test(NAME {MODULE_NAME}UnitTests COMMAND test_{MODULE_NAME_LOWER})

    set_tests_properties({MODULE_NAME}UnitTests PROPERTIES
        TIMEOUT 60
        LABELS "unit;{MODULE_NAME_LOWER}"
    )

    # 性能测试
    if(BUILD_BENCHMARKS)
        add_executable(benchmark_{MODULE_NAME_LOWER}
            benchmarks/benchmark_{MODULE_NAME_LOWER}.cpp
        )

        target_link_libraries(benchmark_{MODULE_NAME_LOWER}
            PRIVATE
                radar_{MODULE_NAME_LOWER}
                benchmark::benchmark
                benchmark::benchmark_main
        )

        # 基准测试不作为常规测试运行
        # add_test(NAME {MODULE_NAME}Benchmarks COMMAND benchmark_{MODULE_NAME_LOWER})
    endif()
endif()

# === 文档生成 ===
if(BUILD_DOCUMENTATION)
    find_package(Doxygen QUIET)
    if(Doxygen_FOUND)
        set(DOXYGEN_PROJECT_NAME "{MODULE_NAME} Module")
        set(DOXYGEN_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/docs/{MODULE_NAME_LOWER})

        doxygen_add_docs(docs_{MODULE_NAME_LOWER}
            ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}
            ${CMAKE_CURRENT_SOURCE_DIR}
            COMMENT "Generate {MODULE_NAME} documentation"
        )
    endif()
endif()
```

#### 设计原则
- **模块化**: 独立的模块构建配置
- **条件编译**: 支持可选功能和平台差异
- **测试集成**: 自动化测试目标配置
- **安装支持**: 完整的安装和打包支持
- **文档生成**: 自动文档生成配置

---

## 模板变量定义

### 🔧 可配置变量列表

#### 基础变量
```yaml
module_variables:
  MODULE_NAME: "DataReceiver"           # 模块名称 (PascalCase)
  MODULE_NAME_LOWER: "data_receiver"    # 模块名称 (snake_case)
  MODULE_NAMESPACE: "data"              # 命名空间
  MODULE_PATH: "modules/data_receiver"  # 头文件路径
  MODULE_DESCRIPTION: "雷达数据接收模块" # 模块描述

type_variables:
  INPUT_TYPE: "const RawDataPacket&"    # 输入类型
  OUTPUT_TYPE: "ProcessedData"          # 输出类型
  CONFIG_PARAM_1: "buffer_size"         # 配置参数1
  CONFIG_PARAM_2: "timeout_ms"          # 配置参数2
  DEFAULT_VALUE_1: "1024"               # 默认值1
  DEFAULT_VALUE_2: "5000"               # 默认值2

build_variables:
  MODULE_USES_CUDA: "false"             # 是否使用CUDA
  MODULE_SPECIFIC_LIBS: ""              # 特定链接库
  PERFORMANCE_THRESHOLD_US: "1000"     # 性能阈值(微秒)
  GENERATION_DATE: "2025-09-10"        # 生成日期
```

#### 高级配置
```yaml
advanced_options:
  interface_inheritance: "ModuleInterface"    # 基接口类
  error_handling_style: "error_codes"        # 错误处理方式
  logging_level: "INFO"                      # 日志级别
  thread_safety: "single_threaded"          # 线程安全级别
  memory_management: "smart_pointers"       # 内存管理方式
```

---

## AI使用指南

### 🤖 模板使用流程

#### AI自动化步骤
1. **接收模块需求**: 用户指定模块名称和基本功能
2. **变量替换**: 根据模块信息自动替换模板变量
3. **类型推导**: 根据功能自动推导输入输出类型
4. **依赖分析**: 确定所需的链接库和头文件
5. **生成文件**: 基于模板生成完整的模块文件

#### 模板定制化
```cpp
// AI需要根据具体需求调整的部分
namespace radar::{MODULE_NAMESPACE} {  // 根据模块类型确定命名空间

class {MODULE_NAME}Interface {
    // 根据模块功能定义核心接口
    virtual ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) = 0;

    // 根据需要添加特定接口
    virtual ErrorCode configure({SPECIFIC_CONFIG_TYPE}& config) = 0;
};

} // namespace
```

#### 质量检查点
- [ ] 模板变量完全替换
- [ ] 命名空间正确设置
- [ ] 头文件包含完整
- [ ] 错误处理逻辑完整
- [ ] 测试用例覆盖主要功能
- [ ] CMake配置正确
- [ ] 文档注释完整

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要             |
| :--- | :--------- | :----- | :------------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建模块模板设计方案 |
