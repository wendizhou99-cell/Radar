# æ¨¡å—æ¨¡æ¿è®¾è®¡æ–¹æ¡ˆ

- **æ ‡é¢˜**: AIåä½œå¼€å‘æ ‡å‡†åŒ–æ¨¡å—æ¨¡æ¿æ–¹æ¡ˆ
- **å½“å‰ç‰ˆæœ¬**: v1.0
- **æœ€åæ›´æ–°**: 2025-09-10
- **è´Ÿè´£äºº**: Kelin

---

## è®¾è®¡ç›®æ ‡

### ğŸ¯ æ ¸å¿ƒç›®æ ‡
- **æ ‡å‡†åŒ–ä»£ç ç»“æ„**: ç¡®ä¿æ‰€æœ‰æ¨¡å—éµå¾ªç»Ÿä¸€çš„ä»£ç ç»„ç»‡æ–¹å¼
- **AIå‹å¥½çš„æ¨¡æ¿**: ä¾¿äºAIç†è§£å’Œå¤ç”¨çš„æ¨¡æ¿ç»“æ„
- **å¿«é€Ÿå¼€å‘**: å‡å°‘é‡å¤æ€§ä»£ç ç¼–å†™ï¼Œæé«˜å¼€å‘æ•ˆç‡
- **è´¨é‡ä¿è¯**: å†…ç½®æœ€ä½³å®è·µå’Œé”™è¯¯å¤„ç†æœºåˆ¶
- **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„æ¨¡å—æ¥å£å’Œå®ç°åˆ†ç¦»

### ğŸ“‹ æ¨¡æ¿æ¸…å•
1. **æ¥å£ç±»æ¨¡æ¿.hpp** - æ ‡å‡†æ¥å£ç±»å®šä¹‰æ¨¡æ¿
2. **å®ç°ç±»æ¨¡æ¿.cpp** - æ¥å£å®ç°ç±»æ¨¡æ¿
3. **å•å…ƒæµ‹è¯•æ¨¡æ¿.cpp** - å•å…ƒæµ‹è¯•æ–‡ä»¶æ¨¡æ¿
4. **CMakeListsæ¨¡æ¿.txt** - æ¨¡å—æ„å»ºé…ç½®æ¨¡æ¿

---

## æ¥å£ç±»æ¨¡æ¿è®¾è®¡

### ğŸ“ æ¥å£ç±»æ¨¡æ¿.hpp

#### æ¨¡æ¿ç‰¹ç‚¹
```cpp
// æ ‡å‡†åŒ–å¤´æ–‡ä»¶ç»“æ„
#pragma once

// ç³»ç»Ÿå¤´æ–‡ä»¶
#include <memory>
#include <string>
#include <vector>

// é¡¹ç›®å¤´æ–‡ä»¶
#include "common/types.h"
#include "common/error_codes.h"
#include "interfaces/module_interface.h"

namespace radar::{MODULE_NAMESPACE} {

/**
 * @brief {MODULE_DESCRIPTION}
 *
 * è¯¦ç»†æè¿°æ¨¡å—åŠŸèƒ½å’Œä½¿ç”¨æ–¹æ³•
 *
 * @example
 * auto module = std::make_unique<{MODULE_NAME}Impl>();
 * module->initialize(config);
 * auto result = module->process(data);
 */
class {MODULE_NAME}Interface : public ModuleInterface {
public:
    // æ„é€ å‡½æ•°å’Œææ„å‡½æ•°
    {MODULE_NAME}Interface() = default;
    virtual ~{MODULE_NAME}Interface() = default;

    // ç¦ç”¨æ‹·è´æ„é€ å’Œèµ‹å€¼
    {MODULE_NAME}Interface(const {MODULE_NAME}Interface&) = delete;
    {MODULE_NAME}Interface& operator=(const {MODULE_NAME}Interface&) = delete;

    // æ ¸å¿ƒæ¥å£æ–¹æ³•
    virtual ErrorCode initialize(const Config& config) = 0;
    virtual ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) = 0;
    virtual ErrorCode cleanup() = 0;

    // çŠ¶æ€æŸ¥è¯¢æ–¹æ³•
    virtual bool is_initialized() const = 0;
    virtual ModuleStatus get_status() const = 0;

    // å·¥å‚æ–¹æ³•
    static std::unique_ptr<{MODULE_NAME}Interface> create();
};

} // namespace radar::{MODULE_NAMESPACE}
```

#### è®¾è®¡åŸåˆ™
- **æ¥å£åˆ†ç¦»**: çº¯è™šå‡½æ•°å®šä¹‰ï¼Œä¸åŒ…å«å®ç°
- **RAIIç®¡ç†**: æ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„é”™è¯¯ç è¿”å›æœºåˆ¶
- **çŠ¶æ€æŸ¥è¯¢**: æä¾›æ¨¡å—çŠ¶æ€æŸ¥è¯¢èƒ½åŠ›
- **å·¥å‚æ¨¡å¼**: é€šè¿‡å·¥å‚æ–¹æ³•åˆ›å»ºå®ä¾‹

---

## å®ç°ç±»æ¨¡æ¿è®¾è®¡

### ğŸ“ å®ç°ç±»æ¨¡æ¿.cpp

#### æ¨¡æ¿ç‰¹ç‚¹
```cpp
#include "{MODULE_NAME_LOWER}_interface.h"
#include "common/logging.h"
#include "common/config_wrapper.h"

namespace radar::{MODULE_NAMESPACE} {

class {MODULE_NAME}Impl : public {MODULE_NAME}Interface {
public:
    {MODULE_NAME}Impl();
    ~{MODULE_NAME}Impl() override;

    // æ¥å£å®ç°
    ErrorCode initialize(const Config& config) override;
    ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) override;
    ErrorCode cleanup() override;

    // çŠ¶æ€æŸ¥è¯¢
    bool is_initialized() const override { return is_initialized_; }
    ModuleStatus get_status() const override { return status_; }

private:
    // ç§æœ‰æˆå‘˜å˜é‡
    bool is_initialized_ = false;
    ModuleStatus status_ = ModuleStatus::Uninitialized;
    Config config_;

    // ç§æœ‰æˆå‘˜å‡½æ•°
    ErrorCode validate_config(const Config& config);
    ErrorCode setup_resources();
    void release_resources();

    // æ ¸å¿ƒå¤„ç†é€»è¾‘
    ErrorCode process_impl({INPUT_TYPE} input, {OUTPUT_TYPE}& output);
};

// å·¥å‚æ–¹æ³•å®ç°
std::unique_ptr<{MODULE_NAME}Interface> {MODULE_NAME}Interface::create() {
    return std::make_unique<{MODULE_NAME}Impl>();
}

// æ„é€ å‡½æ•°
{MODULE_NAME}Impl::{MODULE_NAME}Impl() {
    RADAR_DEBUG("Creating {MODULE_NAME} module");
}

// ææ„å‡½æ•°
{MODULE_NAME}Impl::~{MODULE_NAME}Impl() {
    if (is_initialized_) {
        cleanup();
    }
    RADAR_DEBUG("Destroying {MODULE_NAME} module");
}

// åˆå§‹åŒ–å®ç°
ErrorCode {MODULE_NAME}Impl::initialize(const Config& config) {
    RADAR_INFO("Initializing {MODULE_NAME} module");

    if (is_initialized_) {
        RADAR_WARN("{MODULE_NAME} already initialized");
        return ErrorCode::AlreadyInitialized;
    }

    // éªŒè¯é…ç½®
    auto error = validate_config(config);
    if (error != ErrorCode::Success) {
        return error;
    }

    config_ = config;

    // è®¾ç½®èµ„æº
    error = setup_resources();
    if (error != ErrorCode::Success) {
        RADAR_ERROR("Failed to setup resources for {MODULE_NAME}");
        return error;
    }

    is_initialized_ = true;
    status_ = ModuleStatus::Ready;

    RADAR_INFO("{MODULE_NAME} module initialized successfully");
    return ErrorCode::Success;
}

} // namespace radar::{MODULE_NAMESPACE}
```

#### è®¾è®¡åŸåˆ™
- **é”™è¯¯å¤„ç†**: å®Œæ•´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- **èµ„æºç®¡ç†**: RAIIå’Œæ˜ç¡®çš„èµ„æºç”Ÿå‘½å‘¨æœŸ
- **çŠ¶æ€ç®¡ç†**: æ¸…æ™°çš„çŠ¶æ€è½¬æ¢é€»è¾‘
- **é…ç½®éªŒè¯**: è¾“å…¥å‚æ•°çš„å®Œæ•´æ€§æ£€æŸ¥
- **æ€§èƒ½è€ƒè™‘**: é¿å…ä¸å¿…è¦çš„æ‹·è´å’Œåˆ†é…

---

## å•å…ƒæµ‹è¯•æ¨¡æ¿è®¾è®¡

### ğŸ“ å•å…ƒæµ‹è¯•æ¨¡æ¿.cpp

#### æ¨¡æ¿ç‰¹ç‚¹
```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "{MODULE_NAME_LOWER}_interface.h"
#include "tests/common/test_base.h"

using namespace radar::{MODULE_NAMESPACE};
using ::testing::_;
using ::testing::Return;

class {MODULE_NAME}Test : public radar::test::RadarTestBase {
protected:
    void SetUp() override {
        RadarTestBase::SetUp();

        // åˆ›å»ºæµ‹è¯•å®ä¾‹
        module_ = {MODULE_NAME}Interface::create();
        ASSERT_NE(module_, nullptr);

        // è®¾ç½®æµ‹è¯•é…ç½®
        setup_test_config();
    }

    void TearDown() override {
        if (module_ && module_->is_initialized()) {
            module_->cleanup();
        }
        module_.reset();

        RadarTestBase::TearDown();
    }

    void setup_test_config() {
        test_config_.{CONFIG_PARAM_1} = {DEFAULT_VALUE_1};
        test_config_.{CONFIG_PARAM_2} = {DEFAULT_VALUE_2};
    }

    std::unique_ptr<{MODULE_NAME}Interface> module_;
    Config test_config_;
};

// åŸºç¡€åŠŸèƒ½æµ‹è¯•
TEST_F({MODULE_NAME}Test, Constructor) {
    EXPECT_FALSE(module_->is_initialized());
    EXPECT_EQ(module_->get_status(), ModuleStatus::Uninitialized);
}

TEST_F({MODULE_NAME}Test, InitializeSuccess) {
    auto result = module_->initialize(test_config_);

    EXPECT_EQ(result, ErrorCode::Success);
    EXPECT_TRUE(module_->is_initialized());
    EXPECT_EQ(module_->get_status(), ModuleStatus::Ready);
}

TEST_F({MODULE_NAME}Test, InitializeInvalidConfig) {
    Config invalid_config;
    // è®¾ç½®æ— æ•ˆé…ç½®

    auto result = module_->initialize(invalid_config);

    EXPECT_NE(result, ErrorCode::Success);
    EXPECT_FALSE(module_->is_initialized());
}

TEST_F({MODULE_NAME}Test, ProcessBeforeInitialize) {
    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    auto result = module_->process(input, output);

    EXPECT_EQ(result, ErrorCode::NotInitialized);
}

TEST_F({MODULE_NAME}Test, ProcessNormalInput) {
    // åˆå§‹åŒ–æ¨¡å—
    ASSERT_EQ(module_->initialize(test_config_), ErrorCode::Success);

    // å‡†å¤‡æµ‹è¯•æ•°æ®
    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    // æ‰§è¡Œå¤„ç†
    auto result = module_->process(input, output);

    // éªŒè¯ç»“æœ
    EXPECT_EQ(result, ErrorCode::Success);
    EXPECT_TRUE(validate_output(output));
}

// æ€§èƒ½æµ‹è¯•
TEST_F({MODULE_NAME}Test, PerformanceBenchmark) {
    ASSERT_EQ(module_->initialize(test_config_), ErrorCode::Success);

    {INPUT_TYPE} input = create_test_input();
    {OUTPUT_TYPE} output;

    auto start = std::chrono::high_resolution_clock::now();

    constexpr int iterations = 1000;
    for (int i = 0; i < iterations; ++i) {
        module_->process(input, output);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    auto avg_time = duration.count() / iterations;
    EXPECT_LT(avg_time, {PERFORMANCE_THRESHOLD_US}); // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥

    RADAR_INFO("Average processing time: {} Î¼s", avg_time);
}

// è¾…åŠ©å‡½æ•°
{INPUT_TYPE} {MODULE_NAME}Test::create_test_input() {
    // åˆ›å»ºæµ‹è¯•è¾“å…¥æ•°æ®
    {INPUT_TYPE} input;
    // å¡«å……æµ‹è¯•æ•°æ®
    return input;
}

bool {MODULE_NAME}Test::validate_output(const {OUTPUT_TYPE}& output) {
    // éªŒè¯è¾“å‡ºæ•°æ®çš„æ­£ç¡®æ€§
    return true;
}
```

#### è®¾è®¡åŸåˆ™
- **æµ‹è¯•è¦†ç›–**: æ­£å¸¸æµç¨‹ã€é”™è¯¯æµç¨‹ã€è¾¹ç•Œæ¡ä»¶
- **æ€§èƒ½æµ‹è¯•**: å†…ç½®æ€§èƒ½åŸºå‡†æµ‹è¯•
- **æ•°æ®é©±åŠ¨**: å¯é…ç½®çš„æµ‹è¯•æ•°æ®å’Œé˜ˆå€¼
- **Mockæ”¯æŒ**: ä¸ºä¾èµ–é¡¹æä¾›Mockæœºåˆ¶
- **å¯ç»´æŠ¤æ€§**: æ¸…æ™°çš„æµ‹è¯•ç»“æ„å’Œè¾…åŠ©å‡½æ•°

---

## æ„å»ºé…ç½®æ¨¡æ¿è®¾è®¡

### ğŸ“ CMakeListsæ¨¡æ¿.txt

#### æ¨¡æ¿ç‰¹ç‚¹
```cmake
# {MODULE_NAME} æ¨¡å—æ„å»ºé…ç½®
# è‡ªåŠ¨ç”Ÿæˆäº {GENERATION_DATE}

# æ¨¡å—åº“å®šä¹‰
add_library(radar_{MODULE_NAME_LOWER})

# æºæ–‡ä»¶
target_sources(radar_{MODULE_NAME_LOWER}
    PRIVATE
        {MODULE_NAME_LOWER}_impl.cpp
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}/{MODULE_NAME_LOWER}_interface.h
)

# åŒ…å«ç›®å½•
target_include_directories(radar_{MODULE_NAME_LOWER}
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_BINARY_DIR}/include
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
)

# é“¾æ¥åº“
target_link_libraries(radar_{MODULE_NAME_LOWER}
    PUBLIC
        radar_common
        radar_interfaces
    PRIVATE
        spdlog::spdlog
        yaml-cpp
        ${MODULE_SPECIFIC_LIBS}
)

# ç¼–è¯‘å®šä¹‰
target_compile_definitions(radar_{MODULE_NAME_LOWER}
    PRIVATE
        MODULE_NAME="{MODULE_NAME}"
        $<$<CONFIG:Debug>:DEBUG_BUILD>
        $<$<CONFIG:Release>:RELEASE_BUILD>
)

# ç¼–è¯‘é€‰é¡¹
target_compile_options(radar_{MODULE_NAME_LOWER}
    PRIVATE
        $<$<CXX_COMPILER_ID:GNU>:-Wall -Wextra -Wpedantic>
        $<$<CXX_COMPILER_ID:Clang>:-Wall -Wextra -Wpedantic>
        $<$<CXX_COMPILER_ID:MSVC>:/W4>
)

# æ¡ä»¶ç¼–è¯‘ - CUDAæ”¯æŒ
if(ENABLE_CUDA AND {MODULE_USES_CUDA})
    enable_language(CUDA)

    target_sources(radar_{MODULE_NAME_LOWER}
        PRIVATE
            {MODULE_NAME_LOWER}_cuda.cu
    )

    set_target_properties(radar_{MODULE_NAME_LOWER} PROPERTIES
        CUDA_STANDARD 17
        CUDA_STANDARD_REQUIRED ON
        CUDA_SEPARABLE_COMPILATION ON
    )

    target_link_libraries(radar_{MODULE_NAME_LOWER}
        PRIVATE
            CUDA::cudart
            CUDA::cufft
    )
endif()

# å®‰è£…é…ç½®
install(TARGETS radar_{MODULE_NAME_LOWER}
    EXPORT RadarTargets
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

install(FILES
    ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}/{MODULE_NAME_LOWER}_interface.h
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/{MODULE_PATH}
)

# æµ‹è¯•é…ç½®
if(BUILD_TESTS)
    add_subdirectory(tests)
endif()

# ç¤ºä¾‹é…ç½®
if(BUILD_EXAMPLES)
    add_subdirectory(examples)
endif()

# === æµ‹è¯•ç›®æ ‡ ===
if(BUILD_TESTS)
    # å•å…ƒæµ‹è¯•
    add_executable(test_{MODULE_NAME_LOWER}
        tests/test_{MODULE_NAME_LOWER}.cpp
    )

    target_link_libraries(test_{MODULE_NAME_LOWER}
        PRIVATE
            radar_{MODULE_NAME_LOWER}
            GTest::gtest
            GTest::gtest_main
            GTest::gmock
    )

    target_include_directories(test_{MODULE_NAME_LOWER}
        PRIVATE
            ${CMAKE_SOURCE_DIR}/tests/mock
    )

    add_test(NAME {MODULE_NAME}UnitTests COMMAND test_{MODULE_NAME_LOWER})

    set_tests_properties({MODULE_NAME}UnitTests PROPERTIES
        TIMEOUT 60
        LABELS "unit;{MODULE_NAME_LOWER}"
    )

    # æ€§èƒ½æµ‹è¯•
    if(BUILD_BENCHMARKS)
        add_executable(benchmark_{MODULE_NAME_LOWER}
            benchmarks/benchmark_{MODULE_NAME_LOWER}.cpp
        )

        target_link_libraries(benchmark_{MODULE_NAME_LOWER}
            PRIVATE
                radar_{MODULE_NAME_LOWER}
                benchmark::benchmark
                benchmark::benchmark_main
        )

        # åŸºå‡†æµ‹è¯•ä¸ä½œä¸ºå¸¸è§„æµ‹è¯•è¿è¡Œ
        # add_test(NAME {MODULE_NAME}Benchmarks COMMAND benchmark_{MODULE_NAME_LOWER})
    endif()
endif()

# === æ–‡æ¡£ç”Ÿæˆ ===
if(BUILD_DOCUMENTATION)
    find_package(Doxygen QUIET)
    if(Doxygen_FOUND)
        set(DOXYGEN_PROJECT_NAME "{MODULE_NAME} Module")
        set(DOXYGEN_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/docs/{MODULE_NAME_LOWER})

        doxygen_add_docs(docs_{MODULE_NAME_LOWER}
            ${CMAKE_SOURCE_DIR}/include/{MODULE_PATH}
            ${CMAKE_CURRENT_SOURCE_DIR}
            COMMENT "Generate {MODULE_NAME} documentation"
        )
    endif()
endif()
```

#### è®¾è®¡åŸåˆ™
- **æ¨¡å—åŒ–**: ç‹¬ç«‹çš„æ¨¡å—æ„å»ºé…ç½®
- **æ¡ä»¶ç¼–è¯‘**: æ”¯æŒå¯é€‰åŠŸèƒ½å’Œå¹³å°å·®å¼‚
- **æµ‹è¯•é›†æˆ**: è‡ªåŠ¨åŒ–æµ‹è¯•ç›®æ ‡é…ç½®
- **å®‰è£…æ”¯æŒ**: å®Œæ•´çš„å®‰è£…å’Œæ‰“åŒ…æ”¯æŒ
- **æ–‡æ¡£ç”Ÿæˆ**: è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆé…ç½®

---

## æ¨¡æ¿å˜é‡å®šä¹‰

### ğŸ”§ å¯é…ç½®å˜é‡åˆ—è¡¨

#### åŸºç¡€å˜é‡
```yaml
module_variables:
  MODULE_NAME: "DataReceiver"           # æ¨¡å—åç§° (PascalCase)
  MODULE_NAME_LOWER: "data_receiver"    # æ¨¡å—åç§° (snake_case)
  MODULE_NAMESPACE: "data"              # å‘½åç©ºé—´
  MODULE_PATH: "modules/data_receiver"  # å¤´æ–‡ä»¶è·¯å¾„
  MODULE_DESCRIPTION: "é›·è¾¾æ•°æ®æ¥æ”¶æ¨¡å—" # æ¨¡å—æè¿°

type_variables:
  INPUT_TYPE: "const RawDataPacket&"    # è¾“å…¥ç±»å‹
  OUTPUT_TYPE: "ProcessedData"          # è¾“å‡ºç±»å‹
  CONFIG_PARAM_1: "buffer_size"         # é…ç½®å‚æ•°1
  CONFIG_PARAM_2: "timeout_ms"          # é…ç½®å‚æ•°2
  DEFAULT_VALUE_1: "1024"               # é»˜è®¤å€¼1
  DEFAULT_VALUE_2: "5000"               # é»˜è®¤å€¼2

build_variables:
  MODULE_USES_CUDA: "false"             # æ˜¯å¦ä½¿ç”¨CUDA
  MODULE_SPECIFIC_LIBS: ""              # ç‰¹å®šé“¾æ¥åº“
  PERFORMANCE_THRESHOLD_US: "1000"     # æ€§èƒ½é˜ˆå€¼(å¾®ç§’)
  GENERATION_DATE: "2025-09-10"        # ç”Ÿæˆæ—¥æœŸ
```

#### é«˜çº§é…ç½®
```yaml
advanced_options:
  interface_inheritance: "ModuleInterface"    # åŸºæ¥å£ç±»
  error_handling_style: "error_codes"        # é”™è¯¯å¤„ç†æ–¹å¼
  logging_level: "INFO"                      # æ—¥å¿—çº§åˆ«
  thread_safety: "single_threaded"          # çº¿ç¨‹å®‰å…¨çº§åˆ«
  memory_management: "smart_pointers"       # å†…å­˜ç®¡ç†æ–¹å¼
```

---

## AIä½¿ç”¨æŒ‡å—

### ğŸ¤– æ¨¡æ¿ä½¿ç”¨æµç¨‹

#### AIè‡ªåŠ¨åŒ–æ­¥éª¤
1. **æ¥æ”¶æ¨¡å—éœ€æ±‚**: ç”¨æˆ·æŒ‡å®šæ¨¡å—åç§°å’ŒåŸºæœ¬åŠŸèƒ½
2. **å˜é‡æ›¿æ¢**: æ ¹æ®æ¨¡å—ä¿¡æ¯è‡ªåŠ¨æ›¿æ¢æ¨¡æ¿å˜é‡
3. **ç±»å‹æ¨å¯¼**: æ ¹æ®åŠŸèƒ½è‡ªåŠ¨æ¨å¯¼è¾“å…¥è¾“å‡ºç±»å‹
4. **ä¾èµ–åˆ†æ**: ç¡®å®šæ‰€éœ€çš„é“¾æ¥åº“å’Œå¤´æ–‡ä»¶
5. **ç”Ÿæˆæ–‡ä»¶**: åŸºäºæ¨¡æ¿ç”Ÿæˆå®Œæ•´çš„æ¨¡å—æ–‡ä»¶

#### æ¨¡æ¿å®šåˆ¶åŒ–
```cpp
// AIéœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è°ƒæ•´çš„éƒ¨åˆ†
namespace radar::{MODULE_NAMESPACE} {  // æ ¹æ®æ¨¡å—ç±»å‹ç¡®å®šå‘½åç©ºé—´

class {MODULE_NAME}Interface {
    // æ ¹æ®æ¨¡å—åŠŸèƒ½å®šä¹‰æ ¸å¿ƒæ¥å£
    virtual ErrorCode process({INPUT_TYPE} input, {OUTPUT_TYPE}& output) = 0;

    // æ ¹æ®éœ€è¦æ·»åŠ ç‰¹å®šæ¥å£
    virtual ErrorCode configure({SPECIFIC_CONFIG_TYPE}& config) = 0;
};

} // namespace
```

#### è´¨é‡æ£€æŸ¥ç‚¹
- [ ] æ¨¡æ¿å˜é‡å®Œå…¨æ›¿æ¢
- [ ] å‘½åç©ºé—´æ­£ç¡®è®¾ç½®
- [ ] å¤´æ–‡ä»¶åŒ…å«å®Œæ•´
- [ ] é”™è¯¯å¤„ç†é€»è¾‘å®Œæ•´
- [ ] æµ‹è¯•ç”¨ä¾‹è¦†ç›–ä¸»è¦åŠŸèƒ½
- [ ] CMakeé…ç½®æ­£ç¡®
- [ ] æ–‡æ¡£æ³¨é‡Šå®Œæ•´

---

## å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ       | ä¿®æ”¹äºº | å˜æ›´æ‘˜è¦             |
| :--- | :--------- | :----- | :------------------- |
| v1.0 | 2025-09-10 | Kelin  | åˆ›å»ºæ¨¡å—æ¨¡æ¿è®¾è®¡æ–¹æ¡ˆ |
