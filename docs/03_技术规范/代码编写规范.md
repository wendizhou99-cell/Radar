# 代码编写规范

- **标题**: 项目代码编写规范
- **当前版本**: v1.0
- **最后更新**: 2025-09-10
- **负责人**: Kelin

---

## 1. 引言

### 目的
本规范旨在统一项目中对外接口的编写标准，确保模块间的交互清晰、可靠，同时保持代码的可读性和可维护性。

### 范围
主要针对 `include/` 目录下的接口头文件和模块间共享的数据结构，不强制要求内部实现代码的风格统一。

---

## 2. 接口头文件规范

### 2.1 命名约定

#### 2.1.1 文件和类命名
- **接口类**: 纯虚基类，以 `I` 为前缀，使用 `PascalCase`
  ```cpp
  // 文件: include/interfaces/IDataProcessor.h
  class IDataProcessor {
      // ...
  };
  ```

- **实现类**: 具体实现类，使用 `PascalCase`，可添加描述性后缀
  ```cpp
  // 文件: include/processor/CPUProcessor.h
  class CPUProcessor : public IDataProcessor {
      // ...
  };

  // 文件: include/processor/GPUProcessor.h
  class GPUProcessor : public IDataProcessor {
      // ...
  };
  ```

- **数据结构**: 模块间共享的结构体/类，使用 `PascalCase`
  ```cpp
  // 文件: include/data/RadarPacket.h
  struct RadarPacket {
      // ...
  };
  ```

#### 2.1.2 方法和函数命名
- **公共方法**: 统一使用 `camelCase`
  ```cpp
  virtual bool processData(const RawPacket& input, ProcessedData& output) = 0;
  virtual void initialize(const Config& config) = 0;
  virtual StatusCode getProcessingStatus() const = 0;
  ```

### 2.2 头文件结构

#### 2.2.1 防护声明 (必须)
所有头文件必须使用 `#pragma once` 防止重复包含：
```cpp
#pragma once

#include <memory>
#include <vector>
// ... 其他包含
```

#### 2.2.2 禁止命名空间污染 (必须)
严禁在头文件全局作用域使用 `using namespace` 指令：
```cpp
// ❌ 错误 - 不要在头文件中这样做
using namespace std;

// ✅ 正确 - 使用完整的命名空间或局部using声明
std::vector<int> data;
// 或在函数内部使用局部声明
```

---

## 3. 接口设计与注释规范

### 3.1 Doxygen 风格注释 (必须)

#### 3.1.1 文件头注释
每个接口头文件必须包含文件级注释：
```cpp
/**
 * @file IDataProcessor.h
 * @brief 定义数据处理模块的统一接口，所有具体的数据处理器都应继承此类
 * @author [作者名]
 * @version 1.0
 * @date 2025-09-10
 */
```

#### 3.1.2 类/结构体注释
```cpp
/**
 * @brief 定义了从雷达前端接收到的原始数据包结构
 *
 * 该结构包含了雷达采样的原始I/Q数据以及相关的元信息，
 * 用于在DataReceiver和DataProcessor之间传递数据。
 */
struct RawDataPacket {
    uint64_t timestamp;     ///< 数据包时间戳 (微秒)
    uint32_t sequenceId;    ///< 数据包序列号
    std::vector<float> iData;  ///< I路采样数据
    std::vector<float> qData;  ///< Q路采样数据
};
```

#### 3.1.3 方法注释 (详细版)
```cpp
/**
 * @brief 对单个原始数据包执行处理算法
 *
 * 此方法接收原始雷达数据，执行必要的数字信号处理算法
 * (如脉冲压缩、多普勒处理等)，并输出处理后的结果。
 *
 * @param rawPacket [in] 待处理的原始数据包，函数不会修改此对象
 * @param processedData [out] 用于存储处理结果的对象引用
 * @param processingOptions [in] 可选的处理参数配置
 * @return ProcessingStatus 处理状态码
 * @retval SUCCESS 处理成功完成
 * @retval INVALID_INPUT 输入数据格式错误
 * @retval PROCESSING_ERROR 处理过程中发生错误
 *
 * @note 此方法的线程安全性取决于具体实现类
 * @warning 大数据量处理可能耗时较长，建议在工作线程中调用
 *
 * @see ProcessingStatus
 * @see RawDataPacket
 */
virtual ProcessingStatus process(
    const RawDataPacket& rawPacket,
    ProcessedData& processedData,
    const ProcessingOptions& processingOptions = ProcessingOptions{}
) = 0;
```

### 3.2 const 正确性 (必须)

#### 3.2.1 参数const化
- 只读输入参数使用 `const` 引用或指针
- 输出参数使用非const引用或指针
- 可选参数提供const默认值

```cpp
// ✅ 正确的const使用
bool processData(
    const RawPacket& input,        // 只读输入
    ProcessedData& output,         // 输出参数
    const Config* config = nullptr // 可选只读参数
) const;

// ❌ 错误 - 缺少必要的const
bool processData(RawPacket& input, ProcessedData& output);
```

#### 3.2.2 成员方法const化
不修改对象状态的方法必须声明为const：
```cpp
class IDataProcessor {
public:
    virtual bool isInitialized() const = 0;  // 查询方法应该是const
    virtual int getProcessorId() const = 0;   // 获取属性应该是const
    virtual void process(const Data& input) = 0;  // 处理方法通常非const
};
```

### 3.3 资源管理 (必须)

#### 3.3.1 智能指针优先
接口设计中优先使用智能指针管理资源：
```cpp
// ✅ 推荐 - 使用智能指针
class IDataManager {
public:
    virtual std::unique_ptr<DataBuffer> createBuffer(size_t size) = 0;
    virtual std::shared_ptr<ProcessingResult> getResult(int id) const = 0;
};

// ❌ 避免 - 裸指针容易造成内存泄漏
class IDataManager {
public:
    virtual DataBuffer* createBuffer(size_t size) = 0;  // 谁负责释放？
};
```

#### 3.3.2 异常安全
接口方法应该提供基本的异常安全保证：
```cpp
/**
 * @brief 初始化处理器
 * @param config 配置参数
 * @throws std::invalid_argument 配置参数无效时抛出
 * @throws std::runtime_error 初始化失败时抛出
 * @note 如果初始化失败，对象状态不会改变
 */
virtual void initialize(const Config& config) = 0;
```

---

## 4. 数据结构设计指南

### 4.1 基本原则
- 使用标准库容器 (`std::vector`, `std::string` 等)
- 明确数据的生命周期和所有权
- 提供合理的默认值和构造函数

### 4.2 示例结构
```cpp
/**
 * @brief 处理后的雷达数据结构
 */
struct ProcessedData {
    uint64_t timestamp{0};                    ///< 处理完成时间戳
    uint32_t originalSequenceId{0};           ///< 原始数据包ID
    std::vector<float> magnitudeData;         ///< 幅度数据
    std::vector<float> phaseData;             ///< 相位数据
    ProcessingMetadata metadata;              ///< 处理元信息

    /// 默认构造函数
    ProcessedData() = default;

    /// 带容量预分配的构造函数
    explicit ProcessedData(size_t expectedSize) {
        magnitudeData.reserve(expectedSize);
        phaseData.reserve(expectedSize);
    }

    /// 检查数据是否有效
    bool isValid() const {
        return !magnitudeData.empty() &&
               magnitudeData.size() == phaseData.size();
    }
};
```

---

## 5. 代码示例模板

### 5.1 接口类模板
```cpp
#pragma once

#include <memory>
#include <vector>
#include "data/CommonTypes.h"

/**
 * @file IModuleName.h
 * @brief [模块功能简述]
 * @author [作者]
 * @version 1.0
 * @date 2025-09-10
 */

/**
 * @brief [类功能详细描述]
 */
class IModuleName {
public:
    virtual ~IModuleName() = default;

    /**
     * @brief [方法功能描述]
     * @param param1 [参数1描述]
     * @return [返回值描述]
     */
    virtual bool methodName(const InputType& param1) = 0;

    /**
     * @brief [查询方法描述]
     * @return [返回值描述]
     */
    virtual StatusType getStatus() const = 0;
};
```

### 5.2 数据结构模板
```cpp
#pragma once

#include <vector>
#include <string>
#include <cstdint>

/**
 * @brief [数据结构用途描述]
 */
struct DataStructureName {
    uint64_t id{0};                    ///< [字段描述]
    std::string name;                  ///< [字段描述]
    std::vector<float> values;         ///< [字段描述]

    /// 默认构造函数
    DataStructureName() = default;

    /// 验证数据有效性
    bool isValid() const;
};
```

---

## 6. 编码建议

### 6.1 保持简洁
- 接口应该简单明了，避免过度设计
- 一个接口类专注于一个职责
- 方法参数不要过多，考虑使用配置对象

### 6.2 考虑扩展性
- 使用虚函数确保多态性
- 预留扩展接口，但不要过度预测未来需求
- 合理使用前向声明减少编译依赖

### 6.3 团队协作
- 定期检查接口设计是否满足实际需求
- 及时更新注释，保持文档与代码同步
- 在修改公共接口前，与团队成员沟通

---

## 变更记录

| 版本 | 日期       | 修改人 | 变更摘要             |
| :--- | :--------- | :----- | :------------------- |
| v1.0 | 2025-09-10 | Kelin  | 创建代码编写规范初稿 |
