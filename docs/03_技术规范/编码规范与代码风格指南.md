# 编码规范与代码风格指南

- **标题**: Radar MVP 编码规范与代码风格指南
- **当前版本**: v2.0
- **最后更新**: 2025-09-14
- **目标读者**: 项目开发团队
- **适用范围**: 所有C++源代码、CUDA代码、CMake脚本

---

## 📋 快速导航

| 章节                              | 用途                         | 阅读时间 |
| --------------------------------- | ---------------------------- | -------- |
| [基础编码规范](# 🎯 基础编码规范)    | 强制性编码标准               | 15分钟   |
| [命名约定](# 🏷️ 命名约定)    | 变量、函数、类命名规则       | 20分钟   |
| [代码风格](# 🎨 代码风格)    | 格式化、布局、注释标准       | 15分钟   |
| [现代C++特性](# 🚀 现代C++特性使用) | C++17特性的正确使用方式      | 25分钟   |
| [项目特定规范](# ⚙️ 项目特定规范)     | 雷达项目的特殊要求           | 20分钟   |
| [代码审查要点](# 🔍 代码审查要点) | 审查清单和常见问题           | 10分钟   |
| [自动化工具配置](# 🛠️ 自动化工具配置) | clang-format、clang-tidy配置 | 10分钟   |

---

## 🎯 基础编码规范

### 文件组织

#### 头文件结构
```cpp
#pragma once

// 1. 系统头文件
#include <memory>
#include <vector>
#include <string>

// 2. 第三方库头文件
#include <yaml-cpp/yaml.h>
#include <spdlog/spdlog.h>

// 3. 项目内部头文件
#include "common/types.h"
#include "common/interfaces.h"

namespace radar {
namespace modules {

/**
 * @brief 数据处理器接口
 * @details 定义了雷达数据处理的标准接口
 */
class IDataProcessor {
public:
    virtual ~IDataProcessor() = default;

    /**
     * @brief 处理雷达数据
     * @param input_data 输入的原始雷达数据
     * @param output_data 处理后的数据输出
     * @return ErrorCode 处理结果状态码
     */
    virtual ErrorCode processData(const RawRadarData& input_data,
                                  ProcessedRadarData& output_data) = 0;
};

} // namespace modules
} // namespace radar
```

#### 实现文件结构
```cpp
#include "modules/data_processor.h"

// 系统头文件
#include <algorithm>
#include <chrono>

// 项目头文件
#include "common/logger.h"
#include "common/error_codes.h"

namespace radar {
namespace modules {

DataProcessor::DataProcessor(const Config& config)
    : config_(config)
    , buffer_size_(config.buffer_size)
    , processing_thread_(&DataProcessor::processingLoop, this) {
    RADAR_INFO("DataProcessor initialized with buffer size: {}", buffer_size_);
}

ErrorCode DataProcessor::processData(const RawRadarData& input_data,
                                     ProcessedRadarData& output_data) {
    // 参数验证
    if (input_data.empty()) {
        RADAR_ERROR("Input data is empty");
        return ErrorCode::INVALID_INPUT;
    }

    // 实现核心逻辑
    try {
        auto start_time = std::chrono::high_resolution_clock::now();

        // 数据处理逻辑
        processSignal(input_data, output_data);

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end_time - start_time);

        RADAR_DEBUG("Data processing completed in {} μs", duration.count());
        return ErrorCode::SUCCESS;

    } catch (const std::exception& e) {
        RADAR_ERROR("Processing failed: {}", e.what());
        return ErrorCode::PROCESSING_ERROR;
    }
}

} // namespace modules
} // namespace radar
```

### 基本编码原则

#### 1. 接口设计原则
- 所有接口类必须以 `I` 开头：`IDataProcessor`、`IModule`
- 使用纯虚函数定义接口：`virtual ReturnType methodName() = 0;`
- 提供虚析构函数：`virtual ~InterfaceName() = 0;`

#### 2. 错误处理
- 使用项目定义的 `ErrorCode` 枚举而非异常（性能关键路径）
- 在非性能关键代码中可以使用异常
- 所有公共方法都应该有明确的错误返回

#### 3. 资源管理
- 优先使用智能指针：`std::unique_ptr`、`std::shared_ptr`
- RAII 原则：资源获取即初始化
- 避免裸指针所有权转移

---

## 🏷️ 命名约定

### 基本命名规则

| 类型        | 规则               | 示例                      |
| ----------- | ------------------ | ------------------------- |
| 类名        | PascalCase         | `DataProcessor`           |
| 接口名      | I + PascalCase     | `IDataProcessor`          |
| 函数/方法名 | camelCase          | `processData()`           |
| 变量名      | snake_case         | `buffer_size`             |
| 成员变量    | snake_case + 后缀_ | `buffer_size_`, `config_` |
| 常量        | UPPER_CASE         | `MAX_BUFFER_SIZE`         |
| 枚举值      | UPPER_CASE         | `ErrorCode::SUCCESS`      |
| 命名空间    | lower_case         | `radar::modules`          |
| 文件名      | snake_case         | `data_processor.cpp`      |

### 特殊命名规范

#### 1. 线程相关
```cpp
class DataProcessor {
private:
    std::atomic<bool> running_;           // 原子变量：描述性 + 下划线
    std::atomic<bool> should_stop_;       // 布尔原子变量：should_ 前缀
    std::mutex buffer_mutex_;             // 互斥锁：描述 + Mutex后缀
    std::condition_variable data_ready_cv_; // 条件变量：描述 + _cv后缀
    std::thread processing_thread_;       // 线程：描述 + Thread后缀
};
```

#### 2. GPU/CUDA 相关
```cpp
// CUDA 内核函数
__global__ void fftKernel(float* input, float* output, int size);

// CUDA 相关变量
cudaStream_t processing_stream_;     // CUDA流
float* d_input_buffer_;              // 设备内存：d_ 前缀
float* h_output_buffer_;             // 主机内存：h_ 前缀
```

#### 3. 配置和常量
```cpp
namespace config {
    // 配置常量
    constexpr size_t DEFAULT_BUFFER_SIZE = 4096;
    constexpr int MAX_PROCESSING_THREADS = 8;
    constexpr double SAMPLING_FREQUENCY_HZ = 1e6;
}

// 枚举类
enum class ProcessingMode {
    REAL_TIME,
    BATCH,
    SIMULATION
};
```

---

## 🎨 代码风格

### 格式化规范

#### 1. 缩进和空格
- 使用4个空格缩进，不使用Tab
- 行长度限制：120字符
- 操作符前后加空格：`a = b + c;`
- 逗号后加空格：`func(a, b, c);`

#### 2. 括号风格
```cpp
// ✅ 正确的括号风格
class DataProcessor {
public:
    DataProcessor() {
        // 构造函数实现
    }

    void processData() {
        if (condition) {
            // 处理逻辑
        } else {
            // 其他逻辑
        }
    }
};

// 函数调用
auto result = processComplexData(
    input_buffer,
    output_buffer,
    processing_config,
    callback_function
);
```

#### 3. 包含文件排序
```cpp
// 1. 对应的头文件（.cpp文件中）
#include "data_processor.h"

// 2. C系统头文件
#include <cmath>
#include <cstring>

// 3. C++标准库头文件
#include <algorithm>
#include <memory>
#include <vector>

// 4. 第三方库头文件
#include <cuda_runtime.h>
#include <spdlog/spdlog.h>

// 5. 项目内头文件
#include "common/types.h"
#include "modules/interfaces.h"
```

### 注释规范

#### 1. Doxygen 文档注释
```cpp
/**
 * @brief GPU加速的FFT处理器
 * @details 使用CUDA实现的快速傅里叶变换处理器，支持实时雷达信号处理
 *
 * 该类提供以下功能：
 * - 单精度复数FFT计算
 * - 批量数据处理
 * - 异步GPU计算
 *
 * @warning 使用前必须确保CUDA环境已正确初始化
 * @note 线程安全，支持多线程调用
 *
 * @author Radar Dev Team
 * @date 2025-09-14
 * @version 1.0
 */
class GpuFftProcessor : public IDataProcessor {
public:
    /**
     * @brief 构造函数
     * @param fft_size FFT点数，必须是2的幂
     * @param device_id CUDA设备ID，默认为0
     * @throw std::invalid_argument 如果fft_size不是2的幂
     * @throw std::runtime_error 如果CUDA设备初始化失败
     */
    explicit GpuFftProcessor(size_t fft_size, int device_id = 0);

    /**
     * @brief 执行FFT变换
     * @param[in] input 输入的复数数据
     * @param[out] output 输出的FFT结果
     * @param[in] batch_size 批处理大小
     * @return ErrorCode::SUCCESS 成功，其他值表示错误
     * @retval ErrorCode::INVALID_INPUT 输入数据无效
     * @retval ErrorCode::GPU_ERROR CUDA执行错误
     *
     * @pre input和output必须已分配足够内存
     * @post output包含input的FFT变换结果
     *
     * @par 性能特性:
     * - 时间复杂度: O(N log N)
     * - 空间复杂度: O(N)
     * - GPU内存使用: 2 * batch_size * fft_size * sizeof(ComplexFloat)
     *
     * @par 示例:
     * @code
     * GpuFftProcessor processor(1024);
     * std::vector<ComplexFloat> input(1024);
     * std::vector<ComplexFloat> output(1024);
     *
     * auto result = processor.computeFFT(input.data(), output.data(), 1);
     * if (result == ErrorCode::SUCCESS) {
     *     // 处理FFT结果
     * }
     * @endcode
     */
    ErrorCode computeFFT(const ComplexFloat* input,
                         ComplexFloat* output,
                         size_t batch_size);
};
```

#### 2. 行内注释
```cpp
void DataProcessor::processSignal(const RawData& input, ProcessedData& output) {
    // 第一阶段：预处理和滤波
    auto filtered_data = applyAntiAliasingFilter(input);  // 防混叠滤波

    // 第二阶段：FFT变换
    auto fft_result = computeFFT(filtered_data);  // 频域变换

    // 第三阶段：特征提取
    extractTargetFeatures(fft_result, output);  // 目标检测算法

    // TODO: 添加多普勒频移校正 (Issue #123)
    // FIXME: 在高采样率下可能出现内存溢出 (Issue #456)
    // NOTE: 该算法基于论文 "Advanced Radar Signal Processing" 第3章
}
```

---

## 🚀 现代C++特性使用

### auto 关键字使用
```cpp
// ✅ 推荐使用auto的场景
auto iterator = container.begin();  // 复杂迭代器类型
auto lambda = [](int x) { return x * 2; };  // lambda表达式
auto result = std::make_unique<DataProcessor>();  // 智能指针

// ❌ 避免使用auto的场景
int count = 42;           // 不要写成 auto count = 42;
double frequency = 1.5;   // 不要写成 auto frequency = 1.5;
bool is_ready = true;     // 不要写成 auto is_ready = true;

// ✅ 函数返回值可以使用auto
auto calculateDistance(double x, double y) -> double {
    return std::sqrt(x * x + y * y);
}
```

### 智能指针使用
```cpp
class DataProcessor {
private:
    // ✅ 独占所有权
    std::unique_ptr<FftEngine> fft_engine_;

    // ✅ 共享所有权
    std::shared_ptr<ConfigManager> config_manager_;

    // ✅ 观察者模式（不拥有所有权）
    std::weak_ptr<Logger> logger_;

public:
    // ✅ 工厂方法返回智能指针
    static std::unique_ptr<DataProcessor> create(const Config& config) {
        return std::make_unique<DataProcessor>(config);
    }

    // ✅ 接口参数使用原始指针或引用
    void setLogger(std::shared_ptr<Logger> logger) {
        logger_ = logger;  // 存储为weak_ptr
    }

    void processData(const RawData& input, ProcessedData& output) {
        if (auto logger = logger_.lock()) {  // 安全访问weak_ptr
            logger->info("Processing data...");
        }
        // 处理逻辑
    }
};
```

### 移动语义和完美转发
```cpp
class DataBuffer {
private:
    std::vector<float> data_;

public:
    // ✅ 移动构造函数
    DataBuffer(std::vector<float>&& data) : data_(std::move(data)) {}

    // ✅ 通用引用和完美转发
    template<typename... Args>
    void emplaceData(Args&&... args) {
        data_.emplace_back(std::forward<Args>(args)...);
    }

    // ✅ 移动赋值
    DataBuffer& operator=(DataBuffer&& other) noexcept {
        if (this != &other) {
            data_ = std::move(other.data_);
        }
        return *this;
    }
};

// ✅ 使用移动语义避免拷贝
std::vector<float> createLargeDataSet() {
    std::vector<float> data(1000000);
    // 填充数据...
    return data;  // 编译器会自动使用移动语义
}
```

---

## ⚙️ 项目特定规范

### 雷达系统命名约定
```cpp
// 信号处理相关
class PulseCompressionFilter;    // 脉冲压缩滤波器
class DopplerAnalyzer;          // 多普勒分析器
class RangeGateProcessor;       // 距离门处理器

// 数据类型
struct RadarPulse;              // 雷达脉冲
struct TargetDetection;         // 目标检测结果
struct ClutterMap;              // 杂波图

// 常量定义
namespace radar_constants {
    constexpr double LIGHT_SPEED_MS = 299792458.0;     // 光速 m/s
    constexpr double PI = 3.14159265358979323846;      // 圆周率
    constexpr size_t DEFAULT_FFT_SIZE = 1024;          // 默认FFT点数
}
```

### 性能关键代码规范
```cpp
// ✅ 实时处理函数：避免动态内存分配
class RealTimeProcessor {
private:
    // 预分配缓冲区
    AlignedVector<ComplexFloat> fft_buffer_;
    AlignedVector<float> magnitude_buffer_;

public:
    ErrorCode processRealTime(const RawData& input, ProcessedData& output) noexcept {
        // 使用预分配的内存，避免new/malloc
        if (input.size() > fft_buffer_.size()) {
            return ErrorCode::BUFFER_OVERFLOW;
        }

        // 性能关键路径：使用restrict提示编译器优化
        const float* __restrict__ input_ptr = input.data();
        float* __restrict__ output_ptr = output.data();

        // 向量化友好的循环
        #pragma omp simd
        for (size_t i = 0; i < input.size(); ++i) {
            output_ptr[i] = std::abs(input_ptr[i]);
        }

        return ErrorCode::SUCCESS;
    }
};
```

### CUDA 代码规范
```cpp
// CUDA内核函数命名
__global__ void radarFftKernel(const ComplexFloat* input,
                               ComplexFloat* output,
                               int fft_size);

__global__ void pulseCompressionKernel(const float* pulse_data,
                                       const float* reference_pulse,
                                       float* compressed_output,
                                       int pulse_length);

// CUDA错误检查宏
#define CUDA_CHECK(call) \
    do { \
        cudaError_t error = call; \
        if (error != cudaSuccess) { \
            RADAR_ERROR("CUDA error at {}:{}: {}", __FILE__, __LINE__, \
                       cudaGetErrorString(error)); \
            return ErrorCode::GPU_ERROR; \
        } \
    } while(0)

// CUDA内存管理
class GpuMemoryManager {
public:
    template<typename T>
    ErrorCode allocateDevice(T** ptr, size_t count) {
        CUDA_CHECK(cudaMalloc(ptr, count * sizeof(T)));
        return ErrorCode::SUCCESS;
    }

    template<typename T>
    void deallocateDevice(T* ptr) {
        if (ptr) {
            cudaFree(ptr);  // cudaFree 可以安全处理nullptr
        }
    }
};
```

---

## 🔍 代码审查要点

### 审查清单

#### ✅ 基础检查项
- [ ] 所有函数都有适当的错误处理
- [ ] 资源管理遵循RAII原则
- [ ] 没有内存泄漏（使用智能指针）
- [ ] 线程安全性已考虑（如需要）
- [ ] 性能关键路径避免不必要的内存分配

#### ✅ 接口设计检查
- [ ] 接口类以 `I` 开头
- [ ] 公共方法使用 camelCase
- [ ] 参数验证充分
- [ ] 返回值语义明确

#### ✅ 文档检查
- [ ] 公共接口有完整的Doxygen注释
- [ ] 复杂算法有解释注释
- [ ] TODO/FIXME有对应的Issue编号

#### ✅ 现代C++检查
- [ ] 使用 `auto` 适当
- [ ] 智能指针使用正确
- [ ] 移动语义使用恰当
- [ ] 避免不必要的拷贝

### 常见问题和解决方案

#### 1. 性能问题
```cpp
// ❌ 问题：频繁的动态内存分配
void processData(const std::vector<float>& input) {
    for (const auto& value : input) {
        std::vector<float> temp_buffer(1024);  // 每次循环都分配！
        // 处理逻辑...
    }
}

// ✅ 解决：预分配或复用内存
class DataProcessor {
private:
    std::vector<float> reusable_buffer_;  // 复用缓冲区

public:
    DataProcessor() : reusable_buffer_(1024) {}

    void processData(const std::vector<float>& input) {
        for (const auto& value : input) {
            // 复用预分配的缓冲区
            std::fill(reusable_buffer_.begin(), reusable_buffer_.end(), 0);
            // 处理逻辑...
        }
    }
};
```

#### 2. 线程安全问题
```cpp
// ❌ 问题：没有保护共享资源
class DataBuffer {
private:
    std::vector<float> buffer_;

public:
    void addData(float value) {
        buffer_.push_back(value);  // 多线程访问不安全！
    }
};

// ✅ 解决：使用互斥锁保护
class ThreadSafeDataBuffer {
private:
    std::vector<float> buffer_;
    mutable std::mutex buffer_mutex_;

public:
    void addData(float value) {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        buffer_.push_back(value);
    }

    size_t size() const {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        return buffer_.size();
    }
};
```

---

## 🛠️ 自动化工具配置

### clang-format 配置
项目已配置 `.clang-format` 文件，基于Google风格：
- 4空格缩进
- 120字符行宽
- 自动排序include文件
- 统一的括号和空格风格

### clang-tidy 配置
项目已配置 `.clang-tidy` 文件，启用关键检查：
- 性能检查
- 现代化C++建议
- 潜在bug检测
- 可读性改进

### 使用方法
```powershell
# 检查代码格式
Get-ChildItem -Recurse -Include "*.cpp","*.h" | ForEach-Object {
    clang-format --dry-run --Werror $_.FullName
}

# 自动修复格式
Get-ChildItem -Recurse -Include "*.cpp","*.h" | ForEach-Object {
    clang-format -i $_.FullName
}

# 运行静态分析
clang-tidy src/**/*.cpp -- -I include/
```

---

## 📚 参考资源

### 官方指南
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/)
- [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
- [CUDA C++ Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/)

---

**记住：好的代码不仅要能工作，还要易于理解、维护和扩展。遵循这些规范将帮助我们构建高质量的雷达处理系统。**
