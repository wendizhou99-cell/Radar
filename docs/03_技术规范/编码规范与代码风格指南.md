# ç¼–ç è§„èŒƒä¸ä»£ç é£æ ¼æŒ‡å—

- **æ ‡é¢˜**: Radar MVP ç¼–ç è§„èŒƒä¸ä»£ç é£æ ¼æŒ‡å—
- **å½“å‰ç‰ˆæœ¬**: v2.0
- **æœ€åæ›´æ–°**: 2025-09-14
- **ç›®æ ‡è¯»è€…**: é¡¹ç›®å¼€å‘å›¢é˜Ÿ
- **é€‚ç”¨èŒƒå›´**: æ‰€æœ‰C++æºä»£ç ã€CUDAä»£ç ã€CMakeè„šæœ¬

---

## ğŸ“‹ å¿«é€Ÿå¯¼èˆª

| ç« èŠ‚                              | ç”¨é€”                         | é˜…è¯»æ—¶é—´ |
| --------------------------------- | ---------------------------- | -------- |
| [åŸºç¡€ç¼–ç è§„èŒƒ](# ğŸ¯ åŸºç¡€ç¼–ç è§„èŒƒ)    | å¼ºåˆ¶æ€§ç¼–ç æ ‡å‡†               | 15åˆ†é’Ÿ   |
| [å‘½åçº¦å®š](# ğŸ·ï¸ å‘½åçº¦å®š)    | å˜é‡ã€å‡½æ•°ã€ç±»å‘½åè§„åˆ™       | 20åˆ†é’Ÿ   |
| [ä»£ç é£æ ¼](# ğŸ¨ ä»£ç é£æ ¼)    | æ ¼å¼åŒ–ã€å¸ƒå±€ã€æ³¨é‡Šæ ‡å‡†       | 15åˆ†é’Ÿ   |
| [ç°ä»£C++ç‰¹æ€§](# ğŸš€ ç°ä»£C++ç‰¹æ€§ä½¿ç”¨) | C++17ç‰¹æ€§çš„æ­£ç¡®ä½¿ç”¨æ–¹å¼      | 25åˆ†é’Ÿ   |
| [é¡¹ç›®ç‰¹å®šè§„èŒƒ](# âš™ï¸ é¡¹ç›®ç‰¹å®šè§„èŒƒ)     | é›·è¾¾é¡¹ç›®çš„ç‰¹æ®Šè¦æ±‚           | 20åˆ†é’Ÿ   |
| [ä»£ç å®¡æŸ¥è¦ç‚¹](# ğŸ” ä»£ç å®¡æŸ¥è¦ç‚¹) | å®¡æŸ¥æ¸…å•å’Œå¸¸è§é—®é¢˜           | 10åˆ†é’Ÿ   |
| [è‡ªåŠ¨åŒ–å·¥å…·é…ç½®](# ğŸ› ï¸ è‡ªåŠ¨åŒ–å·¥å…·é…ç½®) | clang-formatã€clang-tidyé…ç½® | 10åˆ†é’Ÿ   |

---

## ğŸ¯ åŸºç¡€ç¼–ç è§„èŒƒ

### æ–‡ä»¶ç»„ç»‡

#### å¤´æ–‡ä»¶ç»“æ„
```cpp
#pragma once

// 1. ç³»ç»Ÿå¤´æ–‡ä»¶
#include <memory>
#include <vector>
#include <string>

// 2. ç¬¬ä¸‰æ–¹åº“å¤´æ–‡ä»¶
#include <yaml-cpp/yaml.h>
#include <spdlog/spdlog.h>

// 3. é¡¹ç›®å†…éƒ¨å¤´æ–‡ä»¶
#include "common/types.h"
#include "common/interfaces.h"

namespace radar {
namespace modules {

/**
 * @brief æ•°æ®å¤„ç†å™¨æ¥å£
 * @details å®šä¹‰äº†é›·è¾¾æ•°æ®å¤„ç†çš„æ ‡å‡†æ¥å£
 */
class IDataProcessor {
public:
    virtual ~IDataProcessor() = default;

    /**
     * @brief å¤„ç†é›·è¾¾æ•°æ®
     * @param input_data è¾“å…¥çš„åŸå§‹é›·è¾¾æ•°æ®
     * @param output_data å¤„ç†åçš„æ•°æ®è¾“å‡º
     * @return ErrorCode å¤„ç†ç»“æœçŠ¶æ€ç 
     */
    virtual ErrorCode processData(const RawRadarData& input_data,
                                  ProcessedRadarData& output_data) = 0;
};

} // namespace modules
} // namespace radar
```

#### å®ç°æ–‡ä»¶ç»“æ„
```cpp
#include "modules/data_processor.h"

// ç³»ç»Ÿå¤´æ–‡ä»¶
#include <algorithm>
#include <chrono>

// é¡¹ç›®å¤´æ–‡ä»¶
#include "common/logger.h"
#include "common/error_codes.h"

namespace radar {
namespace modules {

DataProcessor::DataProcessor(const Config& config)
    : config_(config)
    , buffer_size_(config.buffer_size)
    , processing_thread_(&DataProcessor::processingLoop, this) {
    RADAR_INFO("DataProcessor initialized with buffer size: {}", buffer_size_);
}

ErrorCode DataProcessor::processData(const RawRadarData& input_data,
                                     ProcessedRadarData& output_data) {
    // å‚æ•°éªŒè¯
    if (input_data.empty()) {
        RADAR_ERROR("Input data is empty");
        return ErrorCode::INVALID_INPUT;
    }

    // å®ç°æ ¸å¿ƒé€»è¾‘
    try {
        auto start_time = std::chrono::high_resolution_clock::now();

        // æ•°æ®å¤„ç†é€»è¾‘
        processSignal(input_data, output_data);

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end_time - start_time);

        RADAR_DEBUG("Data processing completed in {} Î¼s", duration.count());
        return ErrorCode::SUCCESS;

    } catch (const std::exception& e) {
        RADAR_ERROR("Processing failed: {}", e.what());
        return ErrorCode::PROCESSING_ERROR;
    }
}

} // namespace modules
} // namespace radar
```

### åŸºæœ¬ç¼–ç åŸåˆ™

#### 1. æ¥å£è®¾è®¡åŸåˆ™
- æ‰€æœ‰æ¥å£ç±»å¿…é¡»ä»¥ `I` å¼€å¤´ï¼š`IDataProcessor`ã€`IModule`
- ä½¿ç”¨çº¯è™šå‡½æ•°å®šä¹‰æ¥å£ï¼š`virtual ReturnType methodName() = 0;`
- æä¾›è™šææ„å‡½æ•°ï¼š`virtual ~InterfaceName() = 0;`

#### 2. é”™è¯¯å¤„ç†
- ä½¿ç”¨é¡¹ç›®å®šä¹‰çš„ `ErrorCode` æšä¸¾è€Œéå¼‚å¸¸ï¼ˆæ€§èƒ½å…³é”®è·¯å¾„ï¼‰
- åœ¨éæ€§èƒ½å…³é”®ä»£ç ä¸­å¯ä»¥ä½¿ç”¨å¼‚å¸¸
- æ‰€æœ‰å…¬å…±æ–¹æ³•éƒ½åº”è¯¥æœ‰æ˜ç¡®çš„é”™è¯¯è¿”å›

#### 3. èµ„æºç®¡ç†
- ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼š`std::unique_ptr`ã€`std::shared_ptr`
- RAII åŸåˆ™ï¼šèµ„æºè·å–å³åˆå§‹åŒ–
- é¿å…è£¸æŒ‡é’ˆæ‰€æœ‰æƒè½¬ç§»

---

## ğŸ·ï¸ å‘½åçº¦å®š

### åŸºæœ¬å‘½åè§„åˆ™

| ç±»å‹        | è§„åˆ™               | ç¤ºä¾‹                      |
| ----------- | ------------------ | ------------------------- |
| ç±»å        | PascalCase         | `DataProcessor`           |
| æ¥å£å      | I + PascalCase     | `IDataProcessor`          |
| å‡½æ•°/æ–¹æ³•å | camelCase          | `processData()`           |
| å˜é‡å      | snake_case         | `buffer_size`             |
| æˆå‘˜å˜é‡    | snake_case + åç¼€_ | `buffer_size_`, `config_` |
| å¸¸é‡        | UPPER_CASE         | `MAX_BUFFER_SIZE`         |
| æšä¸¾å€¼      | UPPER_CASE         | `ErrorCode::SUCCESS`      |
| å‘½åç©ºé—´    | lower_case         | `radar::modules`          |
| æ–‡ä»¶å      | snake_case         | `data_processor.cpp`      |

### ç‰¹æ®Šå‘½åè§„èŒƒ

#### 1. çº¿ç¨‹ç›¸å…³
```cpp
class DataProcessor {
private:
    std::atomic<bool> running_;           // åŸå­å˜é‡ï¼šæè¿°æ€§ + ä¸‹åˆ’çº¿
    std::atomic<bool> should_stop_;       // å¸ƒå°”åŸå­å˜é‡ï¼šshould_ å‰ç¼€
    std::mutex buffer_mutex_;             // äº’æ–¥é”ï¼šæè¿° + Mutexåç¼€
    std::condition_variable data_ready_cv_; // æ¡ä»¶å˜é‡ï¼šæè¿° + _cvåç¼€
    std::thread processing_thread_;       // çº¿ç¨‹ï¼šæè¿° + Threadåç¼€
};
```

#### 2. GPU/CUDA ç›¸å…³
```cpp
// CUDA å†…æ ¸å‡½æ•°
__global__ void fftKernel(float* input, float* output, int size);

// CUDA ç›¸å…³å˜é‡
cudaStream_t processing_stream_;     // CUDAæµ
float* d_input_buffer_;              // è®¾å¤‡å†…å­˜ï¼šd_ å‰ç¼€
float* h_output_buffer_;             // ä¸»æœºå†…å­˜ï¼šh_ å‰ç¼€
```

#### 3. é…ç½®å’Œå¸¸é‡
```cpp
namespace config {
    // é…ç½®å¸¸é‡
    constexpr size_t DEFAULT_BUFFER_SIZE = 4096;
    constexpr int MAX_PROCESSING_THREADS = 8;
    constexpr double SAMPLING_FREQUENCY_HZ = 1e6;
}

// æšä¸¾ç±»
enum class ProcessingMode {
    REAL_TIME,
    BATCH,
    SIMULATION
};
```

---

## ğŸ¨ ä»£ç é£æ ¼

### æ ¼å¼åŒ–è§„èŒƒ

#### 1. ç¼©è¿›å’Œç©ºæ ¼
- ä½¿ç”¨4ä¸ªç©ºæ ¼ç¼©è¿›ï¼Œä¸ä½¿ç”¨Tab
- è¡Œé•¿åº¦é™åˆ¶ï¼š120å­—ç¬¦
- æ“ä½œç¬¦å‰ååŠ ç©ºæ ¼ï¼š`a = b + c;`
- é€—å·ååŠ ç©ºæ ¼ï¼š`func(a, b, c);`

#### 2. æ‹¬å·é£æ ¼
```cpp
// âœ… æ­£ç¡®çš„æ‹¬å·é£æ ¼
class DataProcessor {
public:
    DataProcessor() {
        // æ„é€ å‡½æ•°å®ç°
    }

    void processData() {
        if (condition) {
            // å¤„ç†é€»è¾‘
        } else {
            // å…¶ä»–é€»è¾‘
        }
    }
};

// å‡½æ•°è°ƒç”¨
auto result = processComplexData(
    input_buffer,
    output_buffer,
    processing_config,
    callback_function
);
```

#### 3. åŒ…å«æ–‡ä»¶æ’åº
```cpp
// 1. å¯¹åº”çš„å¤´æ–‡ä»¶ï¼ˆ.cppæ–‡ä»¶ä¸­ï¼‰
#include "data_processor.h"

// 2. Cç³»ç»Ÿå¤´æ–‡ä»¶
#include <cmath>
#include <cstring>

// 3. C++æ ‡å‡†åº“å¤´æ–‡ä»¶
#include <algorithm>
#include <memory>
#include <vector>

// 4. ç¬¬ä¸‰æ–¹åº“å¤´æ–‡ä»¶
#include <cuda_runtime.h>
#include <spdlog/spdlog.h>

// 5. é¡¹ç›®å†…å¤´æ–‡ä»¶
#include "common/types.h"
#include "modules/interfaces.h"
```

### æ³¨é‡Šè§„èŒƒ

#### 1. Doxygen æ–‡æ¡£æ³¨é‡Š
```cpp
/**
 * @brief GPUåŠ é€Ÿçš„FFTå¤„ç†å™¨
 * @details ä½¿ç”¨CUDAå®ç°çš„å¿«é€Ÿå‚…é‡Œå¶å˜æ¢å¤„ç†å™¨ï¼Œæ”¯æŒå®æ—¶é›·è¾¾ä¿¡å·å¤„ç†
 *
 * è¯¥ç±»æä¾›ä»¥ä¸‹åŠŸèƒ½ï¼š
 * - å•ç²¾åº¦å¤æ•°FFTè®¡ç®—
 * - æ‰¹é‡æ•°æ®å¤„ç†
 * - å¼‚æ­¥GPUè®¡ç®—
 *
 * @warning ä½¿ç”¨å‰å¿…é¡»ç¡®ä¿CUDAç¯å¢ƒå·²æ­£ç¡®åˆå§‹åŒ–
 * @note çº¿ç¨‹å®‰å…¨ï¼Œæ”¯æŒå¤šçº¿ç¨‹è°ƒç”¨
 *
 * @author Radar Dev Team
 * @date 2025-09-14
 * @version 1.0
 */
class GpuFftProcessor : public IDataProcessor {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param fft_size FFTç‚¹æ•°ï¼Œå¿…é¡»æ˜¯2çš„å¹‚
     * @param device_id CUDAè®¾å¤‡IDï¼Œé»˜è®¤ä¸º0
     * @throw std::invalid_argument å¦‚æœfft_sizeä¸æ˜¯2çš„å¹‚
     * @throw std::runtime_error å¦‚æœCUDAè®¾å¤‡åˆå§‹åŒ–å¤±è´¥
     */
    explicit GpuFftProcessor(size_t fft_size, int device_id = 0);

    /**
     * @brief æ‰§è¡ŒFFTå˜æ¢
     * @param[in] input è¾“å…¥çš„å¤æ•°æ•°æ®
     * @param[out] output è¾“å‡ºçš„FFTç»“æœ
     * @param[in] batch_size æ‰¹å¤„ç†å¤§å°
     * @return ErrorCode::SUCCESS æˆåŠŸï¼Œå…¶ä»–å€¼è¡¨ç¤ºé”™è¯¯
     * @retval ErrorCode::INVALID_INPUT è¾“å…¥æ•°æ®æ— æ•ˆ
     * @retval ErrorCode::GPU_ERROR CUDAæ‰§è¡Œé”™è¯¯
     *
     * @pre inputå’Œoutputå¿…é¡»å·²åˆ†é…è¶³å¤Ÿå†…å­˜
     * @post outputåŒ…å«inputçš„FFTå˜æ¢ç»“æœ
     *
     * @par æ€§èƒ½ç‰¹æ€§:
     * - æ—¶é—´å¤æ‚åº¦: O(N log N)
     * - ç©ºé—´å¤æ‚åº¦: O(N)
     * - GPUå†…å­˜ä½¿ç”¨: 2 * batch_size * fft_size * sizeof(ComplexFloat)
     *
     * @par ç¤ºä¾‹:
     * @code
     * GpuFftProcessor processor(1024);
     * std::vector<ComplexFloat> input(1024);
     * std::vector<ComplexFloat> output(1024);
     *
     * auto result = processor.computeFFT(input.data(), output.data(), 1);
     * if (result == ErrorCode::SUCCESS) {
     *     // å¤„ç†FFTç»“æœ
     * }
     * @endcode
     */
    ErrorCode computeFFT(const ComplexFloat* input,
                         ComplexFloat* output,
                         size_t batch_size);
};
```

#### 2. è¡Œå†…æ³¨é‡Š
```cpp
void DataProcessor::processSignal(const RawData& input, ProcessedData& output) {
    // ç¬¬ä¸€é˜¶æ®µï¼šé¢„å¤„ç†å’Œæ»¤æ³¢
    auto filtered_data = applyAntiAliasingFilter(input);  // é˜²æ··å æ»¤æ³¢

    // ç¬¬äºŒé˜¶æ®µï¼šFFTå˜æ¢
    auto fft_result = computeFFT(filtered_data);  // é¢‘åŸŸå˜æ¢

    // ç¬¬ä¸‰é˜¶æ®µï¼šç‰¹å¾æå–
    extractTargetFeatures(fft_result, output);  // ç›®æ ‡æ£€æµ‹ç®—æ³•

    // TODO: æ·»åŠ å¤šæ™®å‹’é¢‘ç§»æ ¡æ­£ (Issue #123)
    // FIXME: åœ¨é«˜é‡‡æ ·ç‡ä¸‹å¯èƒ½å‡ºç°å†…å­˜æº¢å‡º (Issue #456)
    // NOTE: è¯¥ç®—æ³•åŸºäºè®ºæ–‡ "Advanced Radar Signal Processing" ç¬¬3ç« 
}
```

---

## ğŸš€ ç°ä»£C++ç‰¹æ€§ä½¿ç”¨

### auto å…³é”®å­—ä½¿ç”¨
```cpp
// âœ… æ¨èä½¿ç”¨autoçš„åœºæ™¯
auto iterator = container.begin();  // å¤æ‚è¿­ä»£å™¨ç±»å‹
auto lambda = [](int x) { return x * 2; };  // lambdaè¡¨è¾¾å¼
auto result = std::make_unique<DataProcessor>();  // æ™ºèƒ½æŒ‡é’ˆ

// âŒ é¿å…ä½¿ç”¨autoçš„åœºæ™¯
int count = 42;           // ä¸è¦å†™æˆ auto count = 42;
double frequency = 1.5;   // ä¸è¦å†™æˆ auto frequency = 1.5;
bool is_ready = true;     // ä¸è¦å†™æˆ auto is_ready = true;

// âœ… å‡½æ•°è¿”å›å€¼å¯ä»¥ä½¿ç”¨auto
auto calculateDistance(double x, double y) -> double {
    return std::sqrt(x * x + y * y);
}
```

### æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨
```cpp
class DataProcessor {
private:
    // âœ… ç‹¬å æ‰€æœ‰æƒ
    std::unique_ptr<FftEngine> fft_engine_;

    // âœ… å…±äº«æ‰€æœ‰æƒ
    std::shared_ptr<ConfigManager> config_manager_;

    // âœ… è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆä¸æ‹¥æœ‰æ‰€æœ‰æƒï¼‰
    std::weak_ptr<Logger> logger_;

public:
    // âœ… å·¥å‚æ–¹æ³•è¿”å›æ™ºèƒ½æŒ‡é’ˆ
    static std::unique_ptr<DataProcessor> create(const Config& config) {
        return std::make_unique<DataProcessor>(config);
    }

    // âœ… æ¥å£å‚æ•°ä½¿ç”¨åŸå§‹æŒ‡é’ˆæˆ–å¼•ç”¨
    void setLogger(std::shared_ptr<Logger> logger) {
        logger_ = logger;  // å­˜å‚¨ä¸ºweak_ptr
    }

    void processData(const RawData& input, ProcessedData& output) {
        if (auto logger = logger_.lock()) {  // å®‰å…¨è®¿é—®weak_ptr
            logger->info("Processing data...");
        }
        // å¤„ç†é€»è¾‘
    }
};
```

### ç§»åŠ¨è¯­ä¹‰å’Œå®Œç¾è½¬å‘
```cpp
class DataBuffer {
private:
    std::vector<float> data_;

public:
    // âœ… ç§»åŠ¨æ„é€ å‡½æ•°
    DataBuffer(std::vector<float>&& data) : data_(std::move(data)) {}

    // âœ… é€šç”¨å¼•ç”¨å’Œå®Œç¾è½¬å‘
    template<typename... Args>
    void emplaceData(Args&&... args) {
        data_.emplace_back(std::forward<Args>(args)...);
    }

    // âœ… ç§»åŠ¨èµ‹å€¼
    DataBuffer& operator=(DataBuffer&& other) noexcept {
        if (this != &other) {
            data_ = std::move(other.data_);
        }
        return *this;
    }
};

// âœ… ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰é¿å…æ‹·è´
std::vector<float> createLargeDataSet() {
    std::vector<float> data(1000000);
    // å¡«å……æ•°æ®...
    return data;  // ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰
}
```

---

## âš™ï¸ é¡¹ç›®ç‰¹å®šè§„èŒƒ

### é›·è¾¾ç³»ç»Ÿå‘½åçº¦å®š
```cpp
// ä¿¡å·å¤„ç†ç›¸å…³
class PulseCompressionFilter;    // è„‰å†²å‹ç¼©æ»¤æ³¢å™¨
class DopplerAnalyzer;          // å¤šæ™®å‹’åˆ†æå™¨
class RangeGateProcessor;       // è·ç¦»é—¨å¤„ç†å™¨

// æ•°æ®ç±»å‹
struct RadarPulse;              // é›·è¾¾è„‰å†²
struct TargetDetection;         // ç›®æ ‡æ£€æµ‹ç»“æœ
struct ClutterMap;              // æ‚æ³¢å›¾

// å¸¸é‡å®šä¹‰
namespace radar_constants {
    constexpr double LIGHT_SPEED_MS = 299792458.0;     // å…‰é€Ÿ m/s
    constexpr double PI = 3.14159265358979323846;      // åœ†å‘¨ç‡
    constexpr size_t DEFAULT_FFT_SIZE = 1024;          // é»˜è®¤FFTç‚¹æ•°
}
```

### æ€§èƒ½å…³é”®ä»£ç è§„èŒƒ
```cpp
// âœ… å®æ—¶å¤„ç†å‡½æ•°ï¼šé¿å…åŠ¨æ€å†…å­˜åˆ†é…
class RealTimeProcessor {
private:
    // é¢„åˆ†é…ç¼“å†²åŒº
    AlignedVector<ComplexFloat> fft_buffer_;
    AlignedVector<float> magnitude_buffer_;

public:
    ErrorCode processRealTime(const RawData& input, ProcessedData& output) noexcept {
        // ä½¿ç”¨é¢„åˆ†é…çš„å†…å­˜ï¼Œé¿å…new/malloc
        if (input.size() > fft_buffer_.size()) {
            return ErrorCode::BUFFER_OVERFLOW;
        }

        // æ€§èƒ½å…³é”®è·¯å¾„ï¼šä½¿ç”¨restrictæç¤ºç¼–è¯‘å™¨ä¼˜åŒ–
        const float* __restrict__ input_ptr = input.data();
        float* __restrict__ output_ptr = output.data();

        // å‘é‡åŒ–å‹å¥½çš„å¾ªç¯
        #pragma omp simd
        for (size_t i = 0; i < input.size(); ++i) {
            output_ptr[i] = std::abs(input_ptr[i]);
        }

        return ErrorCode::SUCCESS;
    }
};
```

### CUDA ä»£ç è§„èŒƒ
```cpp
// CUDAå†…æ ¸å‡½æ•°å‘½å
__global__ void radarFftKernel(const ComplexFloat* input,
                               ComplexFloat* output,
                               int fft_size);

__global__ void pulseCompressionKernel(const float* pulse_data,
                                       const float* reference_pulse,
                                       float* compressed_output,
                                       int pulse_length);

// CUDAé”™è¯¯æ£€æŸ¥å®
#define CUDA_CHECK(call) \
    do { \
        cudaError_t error = call; \
        if (error != cudaSuccess) { \
            RADAR_ERROR("CUDA error at {}:{}: {}", __FILE__, __LINE__, \
                       cudaGetErrorString(error)); \
            return ErrorCode::GPU_ERROR; \
        } \
    } while(0)

// CUDAå†…å­˜ç®¡ç†
class GpuMemoryManager {
public:
    template<typename T>
    ErrorCode allocateDevice(T** ptr, size_t count) {
        CUDA_CHECK(cudaMalloc(ptr, count * sizeof(T)));
        return ErrorCode::SUCCESS;
    }

    template<typename T>
    void deallocateDevice(T* ptr) {
        if (ptr) {
            cudaFree(ptr);  // cudaFree å¯ä»¥å®‰å…¨å¤„ç†nullptr
        }
    }
};
```

---

## ğŸ” ä»£ç å®¡æŸ¥è¦ç‚¹

### å®¡æŸ¥æ¸…å•

#### âœ… åŸºç¡€æ£€æŸ¥é¡¹
- [ ] æ‰€æœ‰å‡½æ•°éƒ½æœ‰é€‚å½“çš„é”™è¯¯å¤„ç†
- [ ] èµ„æºç®¡ç†éµå¾ªRAIIåŸåˆ™
- [ ] æ²¡æœ‰å†…å­˜æ³„æ¼ï¼ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼‰
- [ ] çº¿ç¨‹å®‰å…¨æ€§å·²è€ƒè™‘ï¼ˆå¦‚éœ€è¦ï¼‰
- [ ] æ€§èƒ½å…³é”®è·¯å¾„é¿å…ä¸å¿…è¦çš„å†…å­˜åˆ†é…

#### âœ… æ¥å£è®¾è®¡æ£€æŸ¥
- [ ] æ¥å£ç±»ä»¥ `I` å¼€å¤´
- [ ] å…¬å…±æ–¹æ³•ä½¿ç”¨ camelCase
- [ ] å‚æ•°éªŒè¯å……åˆ†
- [ ] è¿”å›å€¼è¯­ä¹‰æ˜ç¡®

#### âœ… æ–‡æ¡£æ£€æŸ¥
- [ ] å…¬å…±æ¥å£æœ‰å®Œæ•´çš„Doxygenæ³¨é‡Š
- [ ] å¤æ‚ç®—æ³•æœ‰è§£é‡Šæ³¨é‡Š
- [ ] TODO/FIXMEæœ‰å¯¹åº”çš„Issueç¼–å·

#### âœ… ç°ä»£C++æ£€æŸ¥
- [ ] ä½¿ç”¨ `auto` é€‚å½“
- [ ] æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨æ­£ç¡®
- [ ] ç§»åŠ¨è¯­ä¹‰ä½¿ç”¨æ°å½“
- [ ] é¿å…ä¸å¿…è¦çš„æ‹·è´

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

#### 1. æ€§èƒ½é—®é¢˜
```cpp
// âŒ é—®é¢˜ï¼šé¢‘ç¹çš„åŠ¨æ€å†…å­˜åˆ†é…
void processData(const std::vector<float>& input) {
    for (const auto& value : input) {
        std::vector<float> temp_buffer(1024);  // æ¯æ¬¡å¾ªç¯éƒ½åˆ†é…ï¼
        // å¤„ç†é€»è¾‘...
    }
}

// âœ… è§£å†³ï¼šé¢„åˆ†é…æˆ–å¤ç”¨å†…å­˜
class DataProcessor {
private:
    std::vector<float> reusable_buffer_;  // å¤ç”¨ç¼“å†²åŒº

public:
    DataProcessor() : reusable_buffer_(1024) {}

    void processData(const std::vector<float>& input) {
        for (const auto& value : input) {
            // å¤ç”¨é¢„åˆ†é…çš„ç¼“å†²åŒº
            std::fill(reusable_buffer_.begin(), reusable_buffer_.end(), 0);
            // å¤„ç†é€»è¾‘...
        }
    }
};
```

#### 2. çº¿ç¨‹å®‰å…¨é—®é¢˜
```cpp
// âŒ é—®é¢˜ï¼šæ²¡æœ‰ä¿æŠ¤å…±äº«èµ„æº
class DataBuffer {
private:
    std::vector<float> buffer_;

public:
    void addData(float value) {
        buffer_.push_back(value);  // å¤šçº¿ç¨‹è®¿é—®ä¸å®‰å…¨ï¼
    }
};

// âœ… è§£å†³ï¼šä½¿ç”¨äº’æ–¥é”ä¿æŠ¤
class ThreadSafeDataBuffer {
private:
    std::vector<float> buffer_;
    mutable std::mutex buffer_mutex_;

public:
    void addData(float value) {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        buffer_.push_back(value);
    }

    size_t size() const {
        std::lock_guard<std::mutex> lock(buffer_mutex_);
        return buffer_.size();
    }
};
```

---

## ğŸ› ï¸ è‡ªåŠ¨åŒ–å·¥å…·é…ç½®

### clang-format é…ç½®
é¡¹ç›®å·²é…ç½® `.clang-format` æ–‡ä»¶ï¼ŒåŸºäºGoogleé£æ ¼ï¼š
- 4ç©ºæ ¼ç¼©è¿›
- 120å­—ç¬¦è¡Œå®½
- è‡ªåŠ¨æ’åºincludeæ–‡ä»¶
- ç»Ÿä¸€çš„æ‹¬å·å’Œç©ºæ ¼é£æ ¼

### clang-tidy é…ç½®
é¡¹ç›®å·²é…ç½® `.clang-tidy` æ–‡ä»¶ï¼Œå¯ç”¨å…³é”®æ£€æŸ¥ï¼š
- æ€§èƒ½æ£€æŸ¥
- ç°ä»£åŒ–C++å»ºè®®
- æ½œåœ¨bugæ£€æµ‹
- å¯è¯»æ€§æ”¹è¿›

### ä½¿ç”¨æ–¹æ³•
```powershell
# æ£€æŸ¥ä»£ç æ ¼å¼
Get-ChildItem -Recurse -Include "*.cpp","*.h" | ForEach-Object {
    clang-format --dry-run --Werror $_.FullName
}

# è‡ªåŠ¨ä¿®å¤æ ¼å¼
Get-ChildItem -Recurse -Include "*.cpp","*.h" | ForEach-Object {
    clang-format -i $_.FullName
}

# è¿è¡Œé™æ€åˆ†æ
clang-tidy src/**/*.cpp -- -I include/
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æŒ‡å—
- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/)
- [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
- [CUDA C++ Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/)

---

**è®°ä½ï¼šå¥½çš„ä»£ç ä¸ä»…è¦èƒ½å·¥ä½œï¼Œè¿˜è¦æ˜“äºç†è§£ã€ç»´æŠ¤å’Œæ‰©å±•ã€‚éµå¾ªè¿™äº›è§„èŒƒå°†å¸®åŠ©æˆ‘ä»¬æ„å»ºé«˜è´¨é‡çš„é›·è¾¾å¤„ç†ç³»ç»Ÿã€‚**
