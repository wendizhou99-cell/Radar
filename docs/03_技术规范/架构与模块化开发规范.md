# 架构与模块化开发规范

- **标题**: Radar MVP 架构与模块化开发规范
- **当前版本**: v2.0
- **最后更新**: 2025-09-14
- **目标读者**: 系统架构师、模块开发人员
- **适用范围**: 模块设计、接口定义、系统集成

---

## 📋 快速导航

| 章节                                  | 用途                 | 阅读时间 |
| ------------------------------------- | -------------------- | -------- |
| [模块化开发原则](#模块化开发原则)     | 模块设计基础原则     | 15分钟   |
| [接口设计规范](#接口设计规范)         | 统一接口标准         | 20分钟   |
| [模块集成策略](#模块集成策略)         | 模块间协作和集成     | 25分钟   |
| [接口同步解决方案](#接口同步解决方案) | 接口版本管理和兼容性 | 20分钟   |
| [系统架构设计](#系统架构设计)         | 整体架构和设计模式   | 30分钟   |

---

## 模块化开发原则

### 核心设计原则

#### 1. 单一职责原则 (SRP)
每个模块只负责一个明确的功能领域：

```cpp
// ✅ 正确：职责单一的模块
class DataReceiver {
    // 只负责数据接收和缓冲
public:
    ErrorCode receiveData(RawRadarData& data);
    ErrorCode configureReceiver(const ReceiverConfig& config);
    bool isDataAvailable() const;
};

class DataProcessor {
    // 只负责数据处理和分析
public:
    ErrorCode processData(const RawRadarData& input, ProcessedRadarData& output);
    ErrorCode setProcessingParameters(const ProcessingConfig& config);
};

// ❌ 错误：职责混乱的模块
class RadarController {
    // 混合了接收、处理、显示多种职责
public:
    ErrorCode receiveAndProcessAndDisplay();  // 职责过多
    ErrorCode configureEverything();          // 职责不明确
};
```

#### 2. 开闭原则 (OCP)
模块对扩展开放，对修改封闭：

```cpp
// ✅ 使用策略模式支持扩展
class IProcessingStrategy {
public:
    virtual ~IProcessingStrategy() = default;
    virtual ErrorCode process(const RawData& input, ProcessedData& output) = 0;
    virtual std::string getStrategyName() const = 0;
};

class DataProcessor {
private:
    std::unique_ptr<IProcessingStrategy> strategy_;

public:
    // 可以在运行时切换策略，无需修改现有代码
    void setStrategy(std::unique_ptr<IProcessingStrategy> strategy) {
        strategy_ = std::move(strategy);
    }

    ErrorCode processData(const RawData& input, ProcessedData& output) {
        if (!strategy_) {
            return ErrorCode::STRATEGY_NOT_SET;
        }
        return strategy_->process(input, output);
    }
};

// 扩展：添加新的处理策略
class GpuFftStrategy : public IProcessingStrategy {
public:
    ErrorCode process(const RawData& input, ProcessedData& output) override {
        // GPU FFT实现
        return ErrorCode::SUCCESS;
    }

    std::string getStrategyName() const override {
        return "GPU_FFT_STRATEGY";
    }
};
```

#### 3. 依赖倒置原则 (DIP)
高层模块不应依赖低层模块，两者都应依赖抽象：

```cpp
// ✅ 依赖抽象接口
class RadarApplication {
private:
    std::unique_ptr<IDataReceiver> receiver_;
    std::unique_ptr<IDataProcessor> processor_;
    std::unique_ptr<IDisplayController> display_;

public:
    RadarApplication(std::unique_ptr<IDataReceiver> receiver,
                     std::unique_ptr<IDataProcessor> processor,
                     std::unique_ptr<IDisplayController> display)
        : receiver_(std::move(receiver))
        , processor_(std::move(processor))
        , display_(std::move(display)) {}

    ErrorCode run() {
        // 应用逻辑只依赖接口，不依赖具体实现
        RawRadarData raw_data;
        ProcessedRadarData processed_data;

        RETURN_IF_ERROR(receiver_->receiveData(raw_data));
        RETURN_IF_ERROR(processor_->processData(raw_data, processed_data));
        RETURN_IF_ERROR(display_->displayData(processed_data));

        return ErrorCode::SUCCESS;
    }
};
```

### 模块边界定义

#### 模块分层架构
```
┌─────────────────────────────────────────┐
│            应用层 (Application)          │  ← 业务逻辑编排
├─────────────────────────────────────────┤
│          服务层 (Service Layer)          │  ← 核心业务逻辑
├─────────────────────────────────────────┤
│         模块层 (Module Layer)            │  ← 功能模块实现
├─────────────────────────────────────────┤
│       基础设施层 (Infrastructure)        │  ← 通用基础服务
└─────────────────────────────────────────┘
```

#### 具体模块划分
```cpp
namespace radar {
    // 应用层
    namespace application {
        class RadarApplication;
        class ConfigurationManager;
    }

    // 服务层
    namespace services {
        class DataProcessingService;
        class TargetTrackingService;
        class SignalAnalysisService;
    }

    // 模块层
    namespace modules {
        class DataReceiver;
        class DataProcessor;
        class DisplayController;
        class TaskScheduler;
    }

    // 基础设施层
    namespace infrastructure {
        class Logger;
        class MetricsCollector;
        class ConfigManager;
        class ThreadPool;
    }

    // 通用组件
    namespace common {
        class ErrorCode;
        class Types;
        class Interfaces;
        class Utilities;
    }
}
```

---

## 接口设计规范

### 接口定义标准

#### 接口命名和结构
```cpp
/**
 * @brief 数据处理器接口
 * @details 定义雷达数据处理的标准接口，支持多种处理策略
 */
class IDataProcessor {
public:
    virtual ~IDataProcessor() = default;

    /**
     * @brief 初始化处理器
     * @param config 处理器配置参数
     * @return ErrorCode 初始化结果
     */
    virtual ErrorCode initialize(const ProcessorConfig& config) = 0;

    /**
     * @brief 处理雷达数据
     * @param input 输入的原始数据
     * @param output 输出的处理结果
     * @return ErrorCode 处理结果状态
     */
    virtual ErrorCode processData(const RawRadarData& input,
                                  ProcessedRadarData& output) = 0;

    /**
     * @brief 获取处理器状态
     * @return ProcessorStatus 当前状态信息
     */
    virtual ProcessorStatus getStatus() const = 0;

    /**
     * @brief 关闭处理器
     * @return ErrorCode 关闭操作结果
     */
    virtual ErrorCode shutdown() = 0;

    /**
     * @brief 获取处理器能力描述
     * @return ProcessorCapabilities 处理器能力信息
     */
    virtual ProcessorCapabilities getCapabilities() const = 0;
};
```

#### 数据传递规范
```cpp
// ✅ 使用明确的数据类型
struct RawRadarData {
    AlignedComplexVector signal_data;    // 信号数据
    Timestamp acquisition_time;          // 采集时间
    double sampling_frequency;           // 采样频率
    RadarParameters radar_params;        // 雷达参数

    // 数据有效性检查
    bool isValid() const {
        return !signal_data.empty() &&
               sampling_frequency > 0 &&
               acquisition_time.isValid();
    }
};

struct ProcessedRadarData {
    std::vector<TargetDetection> targets;  // 检测到的目标
    SpectrumData frequency_spectrum;       // 频谱数据
    ProcessingMetrics metrics;             // 处理指标
    Timestamp processing_time;             // 处理时间

    void clear() {
        targets.clear();
        frequency_spectrum.clear();
        metrics.reset();
    }
};

// ✅ 接口参数设计原则
class IDataProcessor {
public:
    // 输入参数使用const引用，避免拷贝
    // 输出参数使用非const引用，明确输出意图
    virtual ErrorCode processData(const RawRadarData& input,     // 输入
                                  ProcessedRadarData& output     // 输出
                                 ) = 0;

    // 配置参数使用const引用
    virtual ErrorCode configure(const ProcessorConfig& config) = 0;

    // 简单类型可以按值传递
    virtual ErrorCode setThreadCount(int thread_count) = 0;

    // 返回复杂对象时考虑使用移动语义
    virtual std::unique_ptr<ProcessingReport> generateReport() = 0;
};
```

### 接口版本管理

#### 版本兼容性策略
```cpp
// 接口版本定义
namespace radar::interfaces {
    constexpr uint32_t CURRENT_VERSION = 0x010200;  // v1.2.0

    // 版本检查函数
    inline bool isCompatibleVersion(uint32_t client_version) {
        uint32_t major_mask = 0xFF0000;
        uint32_t current_major = (CURRENT_VERSION & major_mask) >> 16;
        uint32_t client_major = (client_version & major_mask) >> 16;

        // 主版本号必须匹配
        return current_major == client_major;
    }
}

// 向后兼容的接口扩展
class IDataProcessorV2 : public IDataProcessor {
public:
    /**
     * @brief 批量处理数据（v2.0新增）
     * @param inputs 输入数据批次
     * @param outputs 输出数据批次
     * @return ErrorCode 处理结果
     */
    virtual ErrorCode processBatch(const std::vector<RawRadarData>& inputs,
                                   std::vector<ProcessedRadarData>& outputs) = 0;

    /**
     * @brief 异步处理数据（v2.0新增）
     * @param input 输入数据
     * @param callback 完成回调
     * @return std::future<ErrorCode> 异步结果
     */
    virtual std::future<ErrorCode> processDataAsync(
        const RawRadarData& input,
        std::function<void(const ProcessedRadarData&)> callback) = 0;
};
```

---

## 模块集成策略

### 工厂模式集成

#### 模块工厂设计
```cpp
/**
 * @brief 数据处理器工厂
 */
class DataProcessorFactory {
public:
    enum class ProcessorType {
        CPU_STANDARD,
        GPU_ACCELERATED,
        HYBRID_PROCESSING
    };

    /**
     * @brief 创建数据处理器
     * @param type 处理器类型
     * @param config 配置参数
     * @return 处理器实例
     */
    static std::unique_ptr<IDataProcessor> create(
        ProcessorType type,
        const ProcessorConfig& config) {

        switch (type) {
            case ProcessorType::CPU_STANDARD:
                return std::make_unique<CpuDataProcessor>(config);

            case ProcessorType::GPU_ACCELERATED:
                return std::make_unique<GpuDataProcessor>(config);

            case ProcessorType::HYBRID_PROCESSING:
                return std::make_unique<HybridDataProcessor>(config);

            default:
                RADAR_ERROR("Unknown processor type: {}", static_cast<int>(type));
                return nullptr;
        }
    }

    /**
     * @brief 获取可用的处理器类型
     * @return 支持的处理器类型列表
     */
    static std::vector<ProcessorType> getAvailableTypes() {
        std::vector<ProcessorType> types;

        // CPU处理器总是可用
        types.push_back(ProcessorType::CPU_STANDARD);

        // 检查GPU可用性
        if (CudaEnvironment::isAvailable()) {
            types.push_back(ProcessorType::GPU_ACCELERATED);
            types.push_back(ProcessorType::HYBRID_PROCESSING);
        }

        return types;
    }
};
```

#### 依赖注入容器
```cpp
/**
 * @brief 简单的依赖注入容器
 */
class ServiceContainer {
private:
    std::unordered_map<std::string, std::function<std::any()>> factories_;
    std::unordered_map<std::string, std::any> singletons_;

public:
    template<typename T>
    void registerFactory(const std::string& name, std::function<std::unique_ptr<T>()> factory) {
        factories_[name] = [factory]() -> std::any {
            return factory();
        };
    }

    template<typename T>
    void registerSingleton(const std::string& name, std::unique_ptr<T> instance) {
        singletons_[name] = std::move(instance);
    }

    template<typename T>
    std::unique_ptr<T> resolve(const std::string& name) {
        // 首先检查是否为单例
        auto singleton_it = singletons_.find(name);
        if (singleton_it != singletons_.end()) {
            auto& singleton_any = singleton_it->second;
            if (auto* ptr = std::any_cast<std::unique_ptr<T>>(&singleton_any)) {
                // 返回单例的引用包装
                return std::make_unique<T>(*ptr->get());
            }
        }

        // 使用工厂创建新实例
        auto factory_it = factories_.find(name);
        if (factory_it != factories_.end()) {
            std::any result = factory_it->second();
            return std::any_cast<std::unique_ptr<T>>(result);
        }

        RADAR_ERROR("Service not found: {}", name);
        return nullptr;
    }
};
```

### 事件驱动集成

#### 事件系统设计
```cpp
/**
 * @brief 事件基类
 */
class Event {
public:
    virtual ~Event() = default;
    virtual std::string getEventType() const = 0;
    virtual Timestamp getTimestamp() const = 0;
};

/**
 * @brief 数据接收事件
 */
class DataReceivedEvent : public Event {
private:
    RawRadarData data_;
    Timestamp timestamp_;

public:
    explicit DataReceivedEvent(RawRadarData data)
        : data_(std::move(data)), timestamp_(Clock::now()) {}

    std::string getEventType() const override { return "DataReceived"; }
    Timestamp getTimestamp() const override { return timestamp_; }
    const RawRadarData& getData() const { return data_; }
};

/**
 * @brief 事件总线
 */
class EventBus {
private:
    std::unordered_map<std::string, std::vector<std::function<void(const Event&)>>> handlers_;
    std::mutex handlers_mutex_;

public:
    template<typename EventType>
    void subscribe(std::function<void(const EventType&)> handler) {
        std::lock_guard<std::mutex> lock(handlers_mutex_);
        std::string event_type = EventType{}.getEventType();  // 临时对象获取类型

        handlers_[event_type].emplace_back([handler](const Event& event) {
            if (const auto* typed_event = dynamic_cast<const EventType*>(&event)) {
                handler(*typed_event);
            }
        });
    }

    void publish(std::unique_ptr<Event> event) {
        std::string event_type = event->getEventType();
        std::vector<std::function<void(const Event&)>> event_handlers;

        {
            std::lock_guard<std::mutex> lock(handlers_mutex_);
            auto it = handlers_.find(event_type);
            if (it != handlers_.end()) {
                event_handlers = it->second;
            }
        }

        // 在锁外执行处理函数，避免死锁
        for (const auto& handler : event_handlers) {
            try {
                handler(*event);
            } catch (const std::exception& e) {
                RADAR_ERROR("Event handler failed: {}", e.what());
            }
        }
    }
};
```

---

## 接口同步解决方案

### 接口变更管理

#### 版本化接口策略
```cpp
// 版本1：原始接口
namespace radar::v1 {
    class IDataProcessor {
    public:
        virtual ErrorCode processData(const RawData& input, ProcessedData& output) = 0;
    };
}

// 版本2：扩展接口（向后兼容）
namespace radar::v2 {
    class IDataProcessor : public radar::v1::IDataProcessor {
    public:
        // 继承v1的所有方法

        // v2新增方法
        virtual ErrorCode processBatch(const std::vector<RawData>& inputs,
                                       std::vector<ProcessedData>& outputs) = 0;
    };
}

// 版本适配器
class DataProcessorV1ToV2Adapter : public radar::v2::IDataProcessor {
private:
    std::unique_ptr<radar::v1::IDataProcessor> v1_processor_;

public:
    explicit DataProcessorV1ToV2Adapter(std::unique_ptr<radar::v1::IDataProcessor> processor)
        : v1_processor_(std::move(processor)) {}

    ErrorCode processData(const RawData& input, ProcessedData& output) override {
        return v1_processor_->processData(input, output);
    }

    ErrorCode processBatch(const std::vector<RawData>& inputs,
                          std::vector<ProcessedData>& outputs) override {
        // 使用v1接口模拟批处理
        outputs.resize(inputs.size());
        for (size_t i = 0; i < inputs.size(); ++i) {
            auto result = v1_processor_->processData(inputs[i], outputs[i]);
            if (result != ErrorCode::SUCCESS) {
                return result;
            }
        }
        return ErrorCode::SUCCESS;
    }
};
```

#### 接口迁移策略
```cpp
/**
 * @brief 接口迁移管理器
 */
class InterfaceMigrationManager {
private:
    std::unordered_map<std::string, uint32_t> component_versions_;

public:
    /**
     * @brief 注册组件版本
     */
    void registerComponent(const std::string& name, uint32_t version) {
        component_versions_[name] = version;
        RADAR_INFO("Registered component {} with version {}", name, version);
    }

    /**
     * @brief 检查兼容性
     */
    bool checkCompatibility(const std::string& component, uint32_t required_version) {
        auto it = component_versions_.find(component);
        if (it == component_versions_.end()) {
            RADAR_WARN("Component {} not found", component);
            return false;
        }

        uint32_t current_version = it->second;
        bool compatible = isVersionCompatible(current_version, required_version);

        if (!compatible) {
            RADAR_ERROR("Version incompatibility: {} current={}, required={}",
                       component, current_version, required_version);
        }

        return compatible;
    }

private:
    bool isVersionCompatible(uint32_t current, uint32_t required) {
        // 主版本号必须匹配，次版本号可以向后兼容
        uint32_t current_major = (current >> 16) & 0xFF;
        uint32_t current_minor = (current >> 8) & 0xFF;
        uint32_t required_major = (required >> 16) & 0xFF;
        uint32_t required_minor = (required >> 8) & 0xFF;

        return (current_major == required_major) && (current_minor >= required_minor);
    }
};
```

---

## 系统架构设计

### 分层架构实现

#### 应用层设计
```cpp
/**
 * @brief 雷达应用程序主类
 */
class RadarApplication {
private:
    // 核心服务
    std::unique_ptr<IDataReceiver> data_receiver_;
    std::unique_ptr<IDataProcessor> data_processor_;
    std::unique_ptr<IDisplayController> display_controller_;
    std::unique_ptr<ITaskScheduler> task_scheduler_;

    // 基础设施
    std::shared_ptr<ConfigManager> config_manager_;
    std::shared_ptr<Logger> logger_;
    std::unique_ptr<EventBus> event_bus_;

    // 应用状态
    std::atomic<ApplicationState> state_;
    std::atomic<bool> should_stop_;

public:
    /**
     * @brief 初始化应用程序
     */
    ErrorCode initialize(const std::string& config_file) {
        try {
            // 1. 加载配置
            config_manager_ = std::make_shared<ConfigManager>();
            RETURN_IF_ERROR(config_manager_->loadFromFile(config_file));

            // 2. 初始化日志系统
            logger_ = Logger::create(config_manager_->getLogConfig());
            RADAR_INFO("RadarApplication initializing...");

            // 3. 创建事件总线
            event_bus_ = std::make_unique<EventBus>();

            // 4. 创建核心模块
            RETURN_IF_ERROR(createModules());

            // 5. 初始化模块
            RETURN_IF_ERROR(initializeModules());

            // 6. 设置事件处理
            setupEventHandlers();

            state_ = ApplicationState::INITIALIZED;
            RADAR_INFO("RadarApplication initialized successfully");

            return ErrorCode::SUCCESS;

        } catch (const std::exception& e) {
            RADAR_ERROR("Initialization failed: {}", e.what());
            return ErrorCode::INITIALIZATION_FAILED;
        }
    }

    /**
     * @brief 运行应用程序
     */
    ErrorCode run() {
        if (state_ != ApplicationState::INITIALIZED) {
            return ErrorCode::INVALID_STATE;
        }

        state_ = ApplicationState::RUNNING;
        RADAR_INFO("RadarApplication starting...");

        // 启动任务调度器
        RETURN_IF_ERROR(task_scheduler_->start());

        // 主运行循环
        while (!should_stop_.load()) {
            RETURN_IF_ERROR(processOneCycle());
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }

        RADAR_INFO("RadarApplication stopped");
        return ErrorCode::SUCCESS;
    }

private:
    ErrorCode createModules() {
        auto processor_config = config_manager_->getProcessorConfig();
        auto receiver_config = config_manager_->getReceiverConfig();
        auto display_config = config_manager_->getDisplayConfig();
        auto scheduler_config = config_manager_->getSchedulerConfig();

        // 使用工厂创建模块
        data_processor_ = DataProcessorFactory::create(
            processor_config.type, processor_config);
        data_receiver_ = DataReceiverFactory::create(
            receiver_config.type, receiver_config);
        display_controller_ = DisplayControllerFactory::create(
            display_config.type, display_config);
        task_scheduler_ = TaskSchedulerFactory::create(
            scheduler_config.type, scheduler_config);

        return ErrorCode::SUCCESS;
    }

    void setupEventHandlers() {
        // 数据接收事件处理
        event_bus_->subscribe<DataReceivedEvent>([this](const DataReceivedEvent& event) {
            handleDataReceived(event.getData());
        });

        // 处理完成事件处理
        event_bus_->subscribe<ProcessingCompletedEvent>([this](const ProcessingCompletedEvent& event) {
            handleProcessingCompleted(event.getResult());
        });
    }
};
```

### 模块通信机制

#### 消息队列设计
```cpp
/**
 * @brief 线程安全消息队列
 */
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    mutable std::mutex mutex_;
    std::condition_variable condition_;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(item));
        condition_.notify_one();
    }

    bool tryPop(T& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return false;
        }
        item = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    void waitAndPop(T& item) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (queue_.empty()) {
            condition_.wait(lock);
        }
        item = std::move(queue_.front());
        queue_.pop();
    }

    bool empty() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }
};

/**
 * @brief 模块间消息传递
 */
class ModuleCommunication {
private:
    std::unordered_map<std::string, ThreadSafeQueue<std::unique_ptr<Message>>> queues_;

public:
    void sendMessage(const std::string& target_module, std::unique_ptr<Message> message) {
        auto& queue = queues_[target_module];
        queue.push(std::move(message));
    }

    std::unique_ptr<Message> receiveMessage(const std::string& module_name) {
        auto& queue = queues_[module_name];
        std::unique_ptr<Message> message;
        if (queue.tryPop(message)) {
            return message;
        }
        return nullptr;
    }
};
```

---

**总结：遵循这些架构与模块化原则，我们能够构建出可维护、可扩展、高质量的雷达处理系统。每个模块都有明确的职责边界，通过标准化的接口进行通信，支持灵活的配置和扩展。**
