# æ¶æ„ä¸æ¨¡å—åŒ–å¼€å‘è§„èŒƒ

- **æ ‡é¢˜**: Radar MVP æ¶æ„ä¸æ¨¡å—åŒ–å¼€å‘è§„èŒƒ
- **å½“å‰ç‰ˆæœ¬**: v2.0
- **æœ€åæ›´æ–°**: 2025-09-14
- **ç›®æ ‡è¯»è€…**: ç³»ç»Ÿæ¶æ„å¸ˆã€æ¨¡å—å¼€å‘äººå‘˜
- **é€‚ç”¨èŒƒå›´**: æ¨¡å—è®¾è®¡ã€æ¥å£å®šä¹‰ã€ç³»ç»Ÿé›†æˆ

---

## ğŸ“‹ å¿«é€Ÿå¯¼èˆª

| ç« èŠ‚                                  | ç”¨é€”                 | é˜…è¯»æ—¶é—´ |
| ------------------------------------- | -------------------- | -------- |
| [æ¨¡å—åŒ–å¼€å‘åŸåˆ™](#æ¨¡å—åŒ–å¼€å‘åŸåˆ™)     | æ¨¡å—è®¾è®¡åŸºç¡€åŸåˆ™     | 15åˆ†é’Ÿ   |
| [æ¥å£è®¾è®¡è§„èŒƒ](#æ¥å£è®¾è®¡è§„èŒƒ)         | ç»Ÿä¸€æ¥å£æ ‡å‡†         | 20åˆ†é’Ÿ   |
| [æ¨¡å—é›†æˆç­–ç•¥](#æ¨¡å—é›†æˆç­–ç•¥)         | æ¨¡å—é—´åä½œå’Œé›†æˆ     | 25åˆ†é’Ÿ   |
| [æ¥å£åŒæ­¥è§£å†³æ–¹æ¡ˆ](#æ¥å£åŒæ­¥è§£å†³æ–¹æ¡ˆ) | æ¥å£ç‰ˆæœ¬ç®¡ç†å’Œå…¼å®¹æ€§ | 20åˆ†é’Ÿ   |
| [ç³»ç»Ÿæ¶æ„è®¾è®¡](#ç³»ç»Ÿæ¶æ„è®¾è®¡)         | æ•´ä½“æ¶æ„å’Œè®¾è®¡æ¨¡å¼   | 30åˆ†é’Ÿ   |

---

## æ¨¡å—åŒ–å¼€å‘åŸåˆ™

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

#### 1. å•ä¸€èŒè´£åŸåˆ™ (SRP)
æ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½é¢†åŸŸï¼š

```cpp
// âœ… æ­£ç¡®ï¼šèŒè´£å•ä¸€çš„æ¨¡å—
class DataReceiver {
    // åªè´Ÿè´£æ•°æ®æ¥æ”¶å’Œç¼“å†²
public:
    ErrorCode receiveData(RawRadarData& data);
    ErrorCode configureReceiver(const ReceiverConfig& config);
    bool isDataAvailable() const;
};

class DataProcessor {
    // åªè´Ÿè´£æ•°æ®å¤„ç†å’Œåˆ†æ
public:
    ErrorCode processData(const RawRadarData& input, ProcessedRadarData& output);
    ErrorCode setProcessingParameters(const ProcessingConfig& config);
};

// âŒ é”™è¯¯ï¼šèŒè´£æ··ä¹±çš„æ¨¡å—
class RadarController {
    // æ··åˆäº†æ¥æ”¶ã€å¤„ç†ã€æ˜¾ç¤ºå¤šç§èŒè´£
public:
    ErrorCode receiveAndProcessAndDisplay();  // èŒè´£è¿‡å¤š
    ErrorCode configureEverything();          // èŒè´£ä¸æ˜ç¡®
};
```

#### 2. å¼€é—­åŸåˆ™ (OCP)
æ¨¡å—å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­ï¼š

```cpp
// âœ… ä½¿ç”¨ç­–ç•¥æ¨¡å¼æ”¯æŒæ‰©å±•
class IProcessingStrategy {
public:
    virtual ~IProcessingStrategy() = default;
    virtual ErrorCode process(const RawData& input, ProcessedData& output) = 0;
    virtual std::string getStrategyName() const = 0;
};

class DataProcessor {
private:
    std::unique_ptr<IProcessingStrategy> strategy_;

public:
    // å¯ä»¥åœ¨è¿è¡Œæ—¶åˆ‡æ¢ç­–ç•¥ï¼Œæ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
    void setStrategy(std::unique_ptr<IProcessingStrategy> strategy) {
        strategy_ = std::move(strategy);
    }

    ErrorCode processData(const RawData& input, ProcessedData& output) {
        if (!strategy_) {
            return ErrorCode::STRATEGY_NOT_SET;
        }
        return strategy_->process(input, output);
    }
};

// æ‰©å±•ï¼šæ·»åŠ æ–°çš„å¤„ç†ç­–ç•¥
class GpuFftStrategy : public IProcessingStrategy {
public:
    ErrorCode process(const RawData& input, ProcessedData& output) override {
        // GPU FFTå®ç°
        return ErrorCode::SUCCESS;
    }

    std::string getStrategyName() const override {
        return "GPU_FFT_STRATEGY";
    }
};
```

#### 3. ä¾èµ–å€’ç½®åŸåˆ™ (DIP)
é«˜å±‚æ¨¡å—ä¸åº”ä¾èµ–ä½å±‚æ¨¡å—ï¼Œä¸¤è€…éƒ½åº”ä¾èµ–æŠ½è±¡ï¼š

```cpp
// âœ… ä¾èµ–æŠ½è±¡æ¥å£
class RadarApplication {
private:
    std::unique_ptr<IDataReceiver> receiver_;
    std::unique_ptr<IDataProcessor> processor_;
    std::unique_ptr<IDisplayController> display_;

public:
    RadarApplication(std::unique_ptr<IDataReceiver> receiver,
                     std::unique_ptr<IDataProcessor> processor,
                     std::unique_ptr<IDisplayController> display)
        : receiver_(std::move(receiver))
        , processor_(std::move(processor))
        , display_(std::move(display)) {}

    ErrorCode run() {
        // åº”ç”¨é€»è¾‘åªä¾èµ–æ¥å£ï¼Œä¸ä¾èµ–å…·ä½“å®ç°
        RawRadarData raw_data;
        ProcessedRadarData processed_data;

        RETURN_IF_ERROR(receiver_->receiveData(raw_data));
        RETURN_IF_ERROR(processor_->processData(raw_data, processed_data));
        RETURN_IF_ERROR(display_->displayData(processed_data));

        return ErrorCode::SUCCESS;
    }
};
```

### æ¨¡å—è¾¹ç•Œå®šä¹‰

#### æ¨¡å—åˆ†å±‚æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            åº”ç”¨å±‚ (Application)          â”‚  â† ä¸šåŠ¡é€»è¾‘ç¼–æ’
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          æœåŠ¡å±‚ (Service Layer)          â”‚  â† æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         æ¨¡å—å±‚ (Module Layer)            â”‚  â† åŠŸèƒ½æ¨¡å—å®ç°
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       åŸºç¡€è®¾æ–½å±‚ (Infrastructure)        â”‚  â† é€šç”¨åŸºç¡€æœåŠ¡
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å…·ä½“æ¨¡å—åˆ’åˆ†
```cpp
namespace radar {
    // åº”ç”¨å±‚
    namespace application {
        class RadarApplication;
        class ConfigurationManager;
    }

    // æœåŠ¡å±‚
    namespace services {
        class DataProcessingService;
        class TargetTrackingService;
        class SignalAnalysisService;
    }

    // æ¨¡å—å±‚
    namespace modules {
        class DataReceiver;
        class DataProcessor;
        class DisplayController;
        class TaskScheduler;
    }

    // åŸºç¡€è®¾æ–½å±‚
    namespace infrastructure {
        class Logger;
        class MetricsCollector;
        class ConfigManager;
        class ThreadPool;
    }

    // é€šç”¨ç»„ä»¶
    namespace common {
        class ErrorCode;
        class Types;
        class Interfaces;
        class Utilities;
    }
}
```

---

## æ¥å£è®¾è®¡è§„èŒƒ

### æ¥å£å®šä¹‰æ ‡å‡†

#### æ¥å£å‘½åå’Œç»“æ„
```cpp
/**
 * @brief æ•°æ®å¤„ç†å™¨æ¥å£
 * @details å®šä¹‰é›·è¾¾æ•°æ®å¤„ç†çš„æ ‡å‡†æ¥å£ï¼Œæ”¯æŒå¤šç§å¤„ç†ç­–ç•¥
 */
class IDataProcessor {
public:
    virtual ~IDataProcessor() = default;

    /**
     * @brief åˆå§‹åŒ–å¤„ç†å™¨
     * @param config å¤„ç†å™¨é…ç½®å‚æ•°
     * @return ErrorCode åˆå§‹åŒ–ç»“æœ
     */
    virtual ErrorCode initialize(const ProcessorConfig& config) = 0;

    /**
     * @brief å¤„ç†é›·è¾¾æ•°æ®
     * @param input è¾“å…¥çš„åŸå§‹æ•°æ®
     * @param output è¾“å‡ºçš„å¤„ç†ç»“æœ
     * @return ErrorCode å¤„ç†ç»“æœçŠ¶æ€
     */
    virtual ErrorCode processData(const RawRadarData& input,
                                  ProcessedRadarData& output) = 0;

    /**
     * @brief è·å–å¤„ç†å™¨çŠ¶æ€
     * @return ProcessorStatus å½“å‰çŠ¶æ€ä¿¡æ¯
     */
    virtual ProcessorStatus getStatus() const = 0;

    /**
     * @brief å…³é—­å¤„ç†å™¨
     * @return ErrorCode å…³é—­æ“ä½œç»“æœ
     */
    virtual ErrorCode shutdown() = 0;

    /**
     * @brief è·å–å¤„ç†å™¨èƒ½åŠ›æè¿°
     * @return ProcessorCapabilities å¤„ç†å™¨èƒ½åŠ›ä¿¡æ¯
     */
    virtual ProcessorCapabilities getCapabilities() const = 0;
};
```

#### æ•°æ®ä¼ é€’è§„èŒƒ
```cpp
// âœ… ä½¿ç”¨æ˜ç¡®çš„æ•°æ®ç±»å‹
struct RawRadarData {
    AlignedComplexVector signal_data;    // ä¿¡å·æ•°æ®
    Timestamp acquisition_time;          // é‡‡é›†æ—¶é—´
    double sampling_frequency;           // é‡‡æ ·é¢‘ç‡
    RadarParameters radar_params;        // é›·è¾¾å‚æ•°

    // æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
    bool isValid() const {
        return !signal_data.empty() &&
               sampling_frequency > 0 &&
               acquisition_time.isValid();
    }
};

struct ProcessedRadarData {
    std::vector<TargetDetection> targets;  // æ£€æµ‹åˆ°çš„ç›®æ ‡
    SpectrumData frequency_spectrum;       // é¢‘è°±æ•°æ®
    ProcessingMetrics metrics;             // å¤„ç†æŒ‡æ ‡
    Timestamp processing_time;             // å¤„ç†æ—¶é—´

    void clear() {
        targets.clear();
        frequency_spectrum.clear();
        metrics.reset();
    }
};

// âœ… æ¥å£å‚æ•°è®¾è®¡åŸåˆ™
class IDataProcessor {
public:
    // è¾“å…¥å‚æ•°ä½¿ç”¨constå¼•ç”¨ï¼Œé¿å…æ‹·è´
    // è¾“å‡ºå‚æ•°ä½¿ç”¨éconstå¼•ç”¨ï¼Œæ˜ç¡®è¾“å‡ºæ„å›¾
    virtual ErrorCode processData(const RawRadarData& input,     // è¾“å…¥
                                  ProcessedRadarData& output     // è¾“å‡º
                                 ) = 0;

    // é…ç½®å‚æ•°ä½¿ç”¨constå¼•ç”¨
    virtual ErrorCode configure(const ProcessorConfig& config) = 0;

    // ç®€å•ç±»å‹å¯ä»¥æŒ‰å€¼ä¼ é€’
    virtual ErrorCode setThreadCount(int thread_count) = 0;

    // è¿”å›å¤æ‚å¯¹è±¡æ—¶è€ƒè™‘ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰
    virtual std::unique_ptr<ProcessingReport> generateReport() = 0;
};
```

### æ¥å£ç‰ˆæœ¬ç®¡ç†

#### ç‰ˆæœ¬å…¼å®¹æ€§ç­–ç•¥
```cpp
// æ¥å£ç‰ˆæœ¬å®šä¹‰
namespace radar::interfaces {
    constexpr uint32_t CURRENT_VERSION = 0x010200;  // v1.2.0

    // ç‰ˆæœ¬æ£€æŸ¥å‡½æ•°
    inline bool isCompatibleVersion(uint32_t client_version) {
        uint32_t major_mask = 0xFF0000;
        uint32_t current_major = (CURRENT_VERSION & major_mask) >> 16;
        uint32_t client_major = (client_version & major_mask) >> 16;

        // ä¸»ç‰ˆæœ¬å·å¿…é¡»åŒ¹é…
        return current_major == client_major;
    }
}

// å‘åå…¼å®¹çš„æ¥å£æ‰©å±•
class IDataProcessorV2 : public IDataProcessor {
public:
    /**
     * @brief æ‰¹é‡å¤„ç†æ•°æ®ï¼ˆv2.0æ–°å¢ï¼‰
     * @param inputs è¾“å…¥æ•°æ®æ‰¹æ¬¡
     * @param outputs è¾“å‡ºæ•°æ®æ‰¹æ¬¡
     * @return ErrorCode å¤„ç†ç»“æœ
     */
    virtual ErrorCode processBatch(const std::vector<RawRadarData>& inputs,
                                   std::vector<ProcessedRadarData>& outputs) = 0;

    /**
     * @brief å¼‚æ­¥å¤„ç†æ•°æ®ï¼ˆv2.0æ–°å¢ï¼‰
     * @param input è¾“å…¥æ•°æ®
     * @param callback å®Œæˆå›è°ƒ
     * @return std::future<ErrorCode> å¼‚æ­¥ç»“æœ
     */
    virtual std::future<ErrorCode> processDataAsync(
        const RawRadarData& input,
        std::function<void(const ProcessedRadarData&)> callback) = 0;
};
```

---

## æ¨¡å—é›†æˆç­–ç•¥

### å·¥å‚æ¨¡å¼é›†æˆ

#### æ¨¡å—å·¥å‚è®¾è®¡
```cpp
/**
 * @brief æ•°æ®å¤„ç†å™¨å·¥å‚
 */
class DataProcessorFactory {
public:
    enum class ProcessorType {
        CPU_STANDARD,
        GPU_ACCELERATED,
        HYBRID_PROCESSING
    };

    /**
     * @brief åˆ›å»ºæ•°æ®å¤„ç†å™¨
     * @param type å¤„ç†å™¨ç±»å‹
     * @param config é…ç½®å‚æ•°
     * @return å¤„ç†å™¨å®ä¾‹
     */
    static std::unique_ptr<IDataProcessor> create(
        ProcessorType type,
        const ProcessorConfig& config) {

        switch (type) {
            case ProcessorType::CPU_STANDARD:
                return std::make_unique<CpuDataProcessor>(config);

            case ProcessorType::GPU_ACCELERATED:
                return std::make_unique<GpuDataProcessor>(config);

            case ProcessorType::HYBRID_PROCESSING:
                return std::make_unique<HybridDataProcessor>(config);

            default:
                RADAR_ERROR("Unknown processor type: {}", static_cast<int>(type));
                return nullptr;
        }
    }

    /**
     * @brief è·å–å¯ç”¨çš„å¤„ç†å™¨ç±»å‹
     * @return æ”¯æŒçš„å¤„ç†å™¨ç±»å‹åˆ—è¡¨
     */
    static std::vector<ProcessorType> getAvailableTypes() {
        std::vector<ProcessorType> types;

        // CPUå¤„ç†å™¨æ€»æ˜¯å¯ç”¨
        types.push_back(ProcessorType::CPU_STANDARD);

        // æ£€æŸ¥GPUå¯ç”¨æ€§
        if (CudaEnvironment::isAvailable()) {
            types.push_back(ProcessorType::GPU_ACCELERATED);
            types.push_back(ProcessorType::HYBRID_PROCESSING);
        }

        return types;
    }
};
```

#### ä¾èµ–æ³¨å…¥å®¹å™¨
```cpp
/**
 * @brief ç®€å•çš„ä¾èµ–æ³¨å…¥å®¹å™¨
 */
class ServiceContainer {
private:
    std::unordered_map<std::string, std::function<std::any()>> factories_;
    std::unordered_map<std::string, std::any> singletons_;

public:
    template<typename T>
    void registerFactory(const std::string& name, std::function<std::unique_ptr<T>()> factory) {
        factories_[name] = [factory]() -> std::any {
            return factory();
        };
    }

    template<typename T>
    void registerSingleton(const std::string& name, std::unique_ptr<T> instance) {
        singletons_[name] = std::move(instance);
    }

    template<typename T>
    std::unique_ptr<T> resolve(const std::string& name) {
        // é¦–å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºå•ä¾‹
        auto singleton_it = singletons_.find(name);
        if (singleton_it != singletons_.end()) {
            auto& singleton_any = singleton_it->second;
            if (auto* ptr = std::any_cast<std::unique_ptr<T>>(&singleton_any)) {
                // è¿”å›å•ä¾‹çš„å¼•ç”¨åŒ…è£…
                return std::make_unique<T>(*ptr->get());
            }
        }

        // ä½¿ç”¨å·¥å‚åˆ›å»ºæ–°å®ä¾‹
        auto factory_it = factories_.find(name);
        if (factory_it != factories_.end()) {
            std::any result = factory_it->second();
            return std::any_cast<std::unique_ptr<T>>(result);
        }

        RADAR_ERROR("Service not found: {}", name);
        return nullptr;
    }
};
```

### äº‹ä»¶é©±åŠ¨é›†æˆ

#### äº‹ä»¶ç³»ç»Ÿè®¾è®¡
```cpp
/**
 * @brief äº‹ä»¶åŸºç±»
 */
class Event {
public:
    virtual ~Event() = default;
    virtual std::string getEventType() const = 0;
    virtual Timestamp getTimestamp() const = 0;
};

/**
 * @brief æ•°æ®æ¥æ”¶äº‹ä»¶
 */
class DataReceivedEvent : public Event {
private:
    RawRadarData data_;
    Timestamp timestamp_;

public:
    explicit DataReceivedEvent(RawRadarData data)
        : data_(std::move(data)), timestamp_(Clock::now()) {}

    std::string getEventType() const override { return "DataReceived"; }
    Timestamp getTimestamp() const override { return timestamp_; }
    const RawRadarData& getData() const { return data_; }
};

/**
 * @brief äº‹ä»¶æ€»çº¿
 */
class EventBus {
private:
    std::unordered_map<std::string, std::vector<std::function<void(const Event&)>>> handlers_;
    std::mutex handlers_mutex_;

public:
    template<typename EventType>
    void subscribe(std::function<void(const EventType&)> handler) {
        std::lock_guard<std::mutex> lock(handlers_mutex_);
        std::string event_type = EventType{}.getEventType();  // ä¸´æ—¶å¯¹è±¡è·å–ç±»å‹

        handlers_[event_type].emplace_back([handler](const Event& event) {
            if (const auto* typed_event = dynamic_cast<const EventType*>(&event)) {
                handler(*typed_event);
            }
        });
    }

    void publish(std::unique_ptr<Event> event) {
        std::string event_type = event->getEventType();
        std::vector<std::function<void(const Event&)>> event_handlers;

        {
            std::lock_guard<std::mutex> lock(handlers_mutex_);
            auto it = handlers_.find(event_type);
            if (it != handlers_.end()) {
                event_handlers = it->second;
            }
        }

        // åœ¨é”å¤–æ‰§è¡Œå¤„ç†å‡½æ•°ï¼Œé¿å…æ­»é”
        for (const auto& handler : event_handlers) {
            try {
                handler(*event);
            } catch (const std::exception& e) {
                RADAR_ERROR("Event handler failed: {}", e.what());
            }
        }
    }
};
```

---

## æ¥å£åŒæ­¥è§£å†³æ–¹æ¡ˆ

### æ¥å£å˜æ›´ç®¡ç†

#### ç‰ˆæœ¬åŒ–æ¥å£ç­–ç•¥
```cpp
// ç‰ˆæœ¬1ï¼šåŸå§‹æ¥å£
namespace radar::v1 {
    class IDataProcessor {
    public:
        virtual ErrorCode processData(const RawData& input, ProcessedData& output) = 0;
    };
}

// ç‰ˆæœ¬2ï¼šæ‰©å±•æ¥å£ï¼ˆå‘åå…¼å®¹ï¼‰
namespace radar::v2 {
    class IDataProcessor : public radar::v1::IDataProcessor {
    public:
        // ç»§æ‰¿v1çš„æ‰€æœ‰æ–¹æ³•

        // v2æ–°å¢æ–¹æ³•
        virtual ErrorCode processBatch(const std::vector<RawData>& inputs,
                                       std::vector<ProcessedData>& outputs) = 0;
    };
}

// ç‰ˆæœ¬é€‚é…å™¨
class DataProcessorV1ToV2Adapter : public radar::v2::IDataProcessor {
private:
    std::unique_ptr<radar::v1::IDataProcessor> v1_processor_;

public:
    explicit DataProcessorV1ToV2Adapter(std::unique_ptr<radar::v1::IDataProcessor> processor)
        : v1_processor_(std::move(processor)) {}

    ErrorCode processData(const RawData& input, ProcessedData& output) override {
        return v1_processor_->processData(input, output);
    }

    ErrorCode processBatch(const std::vector<RawData>& inputs,
                          std::vector<ProcessedData>& outputs) override {
        // ä½¿ç”¨v1æ¥å£æ¨¡æ‹Ÿæ‰¹å¤„ç†
        outputs.resize(inputs.size());
        for (size_t i = 0; i < inputs.size(); ++i) {
            auto result = v1_processor_->processData(inputs[i], outputs[i]);
            if (result != ErrorCode::SUCCESS) {
                return result;
            }
        }
        return ErrorCode::SUCCESS;
    }
};
```

#### æ¥å£è¿ç§»ç­–ç•¥
```cpp
/**
 * @brief æ¥å£è¿ç§»ç®¡ç†å™¨
 */
class InterfaceMigrationManager {
private:
    std::unordered_map<std::string, uint32_t> component_versions_;

public:
    /**
     * @brief æ³¨å†Œç»„ä»¶ç‰ˆæœ¬
     */
    void registerComponent(const std::string& name, uint32_t version) {
        component_versions_[name] = version;
        RADAR_INFO("Registered component {} with version {}", name, version);
    }

    /**
     * @brief æ£€æŸ¥å…¼å®¹æ€§
     */
    bool checkCompatibility(const std::string& component, uint32_t required_version) {
        auto it = component_versions_.find(component);
        if (it == component_versions_.end()) {
            RADAR_WARN("Component {} not found", component);
            return false;
        }

        uint32_t current_version = it->second;
        bool compatible = isVersionCompatible(current_version, required_version);

        if (!compatible) {
            RADAR_ERROR("Version incompatibility: {} current={}, required={}",
                       component, current_version, required_version);
        }

        return compatible;
    }

private:
    bool isVersionCompatible(uint32_t current, uint32_t required) {
        // ä¸»ç‰ˆæœ¬å·å¿…é¡»åŒ¹é…ï¼Œæ¬¡ç‰ˆæœ¬å·å¯ä»¥å‘åå…¼å®¹
        uint32_t current_major = (current >> 16) & 0xFF;
        uint32_t current_minor = (current >> 8) & 0xFF;
        uint32_t required_major = (required >> 16) & 0xFF;
        uint32_t required_minor = (required >> 8) & 0xFF;

        return (current_major == required_major) && (current_minor >= required_minor);
    }
};
```

---

## ç³»ç»Ÿæ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„å®ç°

#### åº”ç”¨å±‚è®¾è®¡
```cpp
/**
 * @brief é›·è¾¾åº”ç”¨ç¨‹åºä¸»ç±»
 */
class RadarApplication {
private:
    // æ ¸å¿ƒæœåŠ¡
    std::unique_ptr<IDataReceiver> data_receiver_;
    std::unique_ptr<IDataProcessor> data_processor_;
    std::unique_ptr<IDisplayController> display_controller_;
    std::unique_ptr<ITaskScheduler> task_scheduler_;

    // åŸºç¡€è®¾æ–½
    std::shared_ptr<ConfigManager> config_manager_;
    std::shared_ptr<Logger> logger_;
    std::unique_ptr<EventBus> event_bus_;

    // åº”ç”¨çŠ¶æ€
    std::atomic<ApplicationState> state_;
    std::atomic<bool> should_stop_;

public:
    /**
     * @brief åˆå§‹åŒ–åº”ç”¨ç¨‹åº
     */
    ErrorCode initialize(const std::string& config_file) {
        try {
            // 1. åŠ è½½é…ç½®
            config_manager_ = std::make_shared<ConfigManager>();
            RETURN_IF_ERROR(config_manager_->loadFromFile(config_file));

            // 2. åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
            logger_ = Logger::create(config_manager_->getLogConfig());
            RADAR_INFO("RadarApplication initializing...");

            // 3. åˆ›å»ºäº‹ä»¶æ€»çº¿
            event_bus_ = std::make_unique<EventBus>();

            // 4. åˆ›å»ºæ ¸å¿ƒæ¨¡å—
            RETURN_IF_ERROR(createModules());

            // 5. åˆå§‹åŒ–æ¨¡å—
            RETURN_IF_ERROR(initializeModules());

            // 6. è®¾ç½®äº‹ä»¶å¤„ç†
            setupEventHandlers();

            state_ = ApplicationState::INITIALIZED;
            RADAR_INFO("RadarApplication initialized successfully");

            return ErrorCode::SUCCESS;

        } catch (const std::exception& e) {
            RADAR_ERROR("Initialization failed: {}", e.what());
            return ErrorCode::INITIALIZATION_FAILED;
        }
    }

    /**
     * @brief è¿è¡Œåº”ç”¨ç¨‹åº
     */
    ErrorCode run() {
        if (state_ != ApplicationState::INITIALIZED) {
            return ErrorCode::INVALID_STATE;
        }

        state_ = ApplicationState::RUNNING;
        RADAR_INFO("RadarApplication starting...");

        // å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨
        RETURN_IF_ERROR(task_scheduler_->start());

        // ä¸»è¿è¡Œå¾ªç¯
        while (!should_stop_.load()) {
            RETURN_IF_ERROR(processOneCycle());
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }

        RADAR_INFO("RadarApplication stopped");
        return ErrorCode::SUCCESS;
    }

private:
    ErrorCode createModules() {
        auto processor_config = config_manager_->getProcessorConfig();
        auto receiver_config = config_manager_->getReceiverConfig();
        auto display_config = config_manager_->getDisplayConfig();
        auto scheduler_config = config_manager_->getSchedulerConfig();

        // ä½¿ç”¨å·¥å‚åˆ›å»ºæ¨¡å—
        data_processor_ = DataProcessorFactory::create(
            processor_config.type, processor_config);
        data_receiver_ = DataReceiverFactory::create(
            receiver_config.type, receiver_config);
        display_controller_ = DisplayControllerFactory::create(
            display_config.type, display_config);
        task_scheduler_ = TaskSchedulerFactory::create(
            scheduler_config.type, scheduler_config);

        return ErrorCode::SUCCESS;
    }

    void setupEventHandlers() {
        // æ•°æ®æ¥æ”¶äº‹ä»¶å¤„ç†
        event_bus_->subscribe<DataReceivedEvent>([this](const DataReceivedEvent& event) {
            handleDataReceived(event.getData());
        });

        // å¤„ç†å®Œæˆäº‹ä»¶å¤„ç†
        event_bus_->subscribe<ProcessingCompletedEvent>([this](const ProcessingCompletedEvent& event) {
            handleProcessingCompleted(event.getResult());
        });
    }
};
```

### æ¨¡å—é€šä¿¡æœºåˆ¶

#### æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡
```cpp
/**
 * @brief çº¿ç¨‹å®‰å…¨æ¶ˆæ¯é˜Ÿåˆ—
 */
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    mutable std::mutex mutex_;
    std::condition_variable condition_;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(item));
        condition_.notify_one();
    }

    bool tryPop(T& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return false;
        }
        item = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    void waitAndPop(T& item) {
        std::unique_lock<std::mutex> lock(mutex_);
        while (queue_.empty()) {
            condition_.wait(lock);
        }
        item = std::move(queue_.front());
        queue_.pop();
    }

    bool empty() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }
};

/**
 * @brief æ¨¡å—é—´æ¶ˆæ¯ä¼ é€’
 */
class ModuleCommunication {
private:
    std::unordered_map<std::string, ThreadSafeQueue<std::unique_ptr<Message>>> queues_;

public:
    void sendMessage(const std::string& target_module, std::unique_ptr<Message> message) {
        auto& queue = queues_[target_module];
        queue.push(std::move(message));
    }

    std::unique_ptr<Message> receiveMessage(const std::string& module_name) {
        auto& queue = queues_[module_name];
        std::unique_ptr<Message> message;
        if (queue.tryPop(message)) {
            return message;
        }
        return nullptr;
    }
};
```

---

**æ€»ç»“ï¼šéµå¾ªè¿™äº›æ¶æ„ä¸æ¨¡å—åŒ–åŸåˆ™ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºå¯ç»´æŠ¤ã€å¯æ‰©å±•ã€é«˜è´¨é‡çš„é›·è¾¾å¤„ç†ç³»ç»Ÿã€‚æ¯ä¸ªæ¨¡å—éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œï¼Œé€šè¿‡æ ‡å‡†åŒ–çš„æ¥å£è¿›è¡Œé€šä¿¡ï¼Œæ”¯æŒçµæ´»çš„é…ç½®å’Œæ‰©å±•ã€‚**
