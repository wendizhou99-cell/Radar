# 核心数据结构

  - **当前版本**: v1.0.0
  - **最后更新**: 2025-10-15
  - **负责人**: Klein

-----

## 概述

  - **概要**: 本文件是系统数据架构的**核心实体定义**。它作为“单一事实来源”，精确定义了在核心处理服务器内部数据面（Data Plane）流转的所有核心数据传输对象（DTOs）的C++内存结构、布局及其背后的设计原则。本文档旨在提供一份工程上可直接参考、但又与具体实现细节解耦的稳定契约。

-----

## 目录

- [核心数据结构](#核心数据结构)
  - [概述](#概述)
  - [目录](#目录)
  - [1 文档职责](#1-文档职责)
    - [1.1 文档目标](#11-文档目标)
    - [1.2 核心原则对齐](#12-核心原则对齐)
  - [2 统一数据包装器：DataPacket\<T\>](#2-统一数据包装器datapackett)
    - [2.1 接口职责](#21-接口职责)
    - [2.2 C++ 结构体定义](#22-c-结构体定义)
    - [2.3 核心数据类型别名](#23-核心数据类型别名)
  - [3 核心数据传输对象 (DTOs)](#3-核心数据传输对象-dtos)
    - [3.1 DataObject (原始数据)](#31-dataobject-原始数据)
      - [3.1.1 职责与角色](#311-职责与角色)
      - [3.1.2 C++ 结构体定义](#312-c-结构体定义)
      - [3.1.3 设计原则对齐](#313-设计原则对齐)
    - [3.2 DetectionResult (检测结果)](#32-detectionresult-检测结果)
      - [3.2.1 职责与角色](#321-职责与角色)
      - [3.2.2 C++ 结构体定义](#322-c-结构体定义)
      - [3.2.3 设计原则对齐](#323-设计原则对齐)
    - [3.3 TrackData (航迹数据)](#33-trackdata-航迹数据)
      - [3.3.1 职责与角色](#331-职责与角色)
      - [3.3.2 C++ 结构体定义](#332-c-结构体定义)
      - [3.3.3 设计原则对齐](#333-设计原则对齐)
  - [4 序列化边界与数据契约](#4-序列化边界与数据契约)
    - [4.1 序列化边界点](#41-序列化边界点)
    - [4.2 数据契约：TrackDataBatch.proto](#42-数据契约trackdatabatchproto)
  - [5 术语表](#5-术语表)
  - [6 相关文档](#6-相关文档)
  - [7 变更历史](#7-变更历史)

-----

## 1 文档职责

  - **概要**: 本章定义了本文档自身的“使命”，明确其目标、范围以及设计所遵循的核心架构原则，确保本设计与系统整体架构保持一致。

### 1.1 文档目标

  - **概要**: 本节旨在清晰界定本文档要讲什么、不讲什么，为读者设定正确的预期。
      - **目标**:
          - 定义`DataPacket<T>`统一包装器的结构与契约。
          - 提供`DataObject`, `DetectionResult`, `TrackData`等核心DTO的**公共模式 (Public Schema)**。
          - 阐明每个数据结构的设计如何与《00\_数据架构总览与原则》中的核心原则（特别是**第五原则：面向性能的内存布局**）对齐。

### 1.2 核心原则对齐

  - **概要**: 本节是设计的基石，旨在确保本文档中所有数据结构的设计决策都与项目已确立的架构原则完全对齐。

| 核心原则                       | 在本设计中的具体体现                                                                                                                  |
| :----------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
| **端到端零拷贝**               | `DataObject`通过持有指向共享内存池的智能指针，而非数据本身，构成了零拷贝数据流的起点。                                                |
| **清晰的所有权与生命周期管理** | 所有`DataPacket`的`payload`都通过`std::unique_ptr`结合自定义删除器进行管理，确保了资源的单一所有权和自动回收。                        |
| **强制的全链路可追踪性**       | `DataPacket`的`Header`强制包含`TraceID`字段，确保任何数据在处理流水线中的每一步都是可追溯的。                                         |
| **数据不可变性**               | DTOs被设计为纯数据容器，鼓励模块采用“变换转发”模式，即根据输入DTO创建新的输出DTO，而非在原地修改输入，以简化并发。                    |
| **面向性能的内存布局**         | `DetectionResult`等结构体通过`alignas`指令进行内存对齐，以最大化CPU的SIMD计算性能；`DataObject`指向的页锁定内存则为GPU的DMA操作优化。 |

-----

## 2 统一数据包装器：DataPacket\<T\>

  - **概要**: `DataPacket<T>`是系统中所有在数据管道中流转的数据的统一“集装箱”。它并非一个简单的数据容器，而是一份强制性的技术契约，通过为业务负载（Payload）提供标准化的元数据头部（Header），确保了数据在任何处理阶段都具有可追溯性、标准化和清晰的所有权语义。本节将详细定义其结构，并阐明其在实现全链路追踪和所有权管理中的核心作用。

### 2.1 接口职责

  - **概要**: `DataPacket<T>`的设计职责是作为数据面（Data Plane）的基石，它确保了流经系统的每一份数据都严格遵守核心的数据架构原则。
      - **强制全链路可追踪性**: 通过在`Header`中强制包含`TraceID`字段，`DataPacket<T>`确保了任何数据块自诞生起就携带一个唯一的身份标识。这使得我们可以将一个数据流在整个复杂异步系统中的处理足迹串联起来，是实现端到端调试和性能分析的根本保障。
      - **保障清晰的所有权与生命周期**: 通过其`payload`字段的设计（通常为`std::unique_ptr`），`DataPacket<T>`成为了所有权在模块间安全转移的载体。它明确了数据在任何时刻都只有一个所有者，并通过C++的RAII机制实现了资源的自动回收。
      - **提供标准化的上下文**: `Header`中的`Timestamp`、`sequence_id`和`source_module`等元数据为每个处理阶段提供了丰富的、标准化的上下文信息，避免了通过带外（out-of-band）方式传递这些信息的复杂性和不确定性。

### 2.2 C++ 结构体定义

  - **概要**: 提供`DataPacket<T>`的C++概念性定义。此定义是模块间数据交换的实现依据，它通过模板参数`PayloadType`实现了对不同业务数据的通用封装能力。

    ```cpp
    // 概念性定义，非完整头文件，详见
    template<typename PayloadType>
    struct DataPacket {
        /**
         * @brief 数据包头部，包含所有元数据。
         */
        struct Header {
            /// @brief 数据生成或捕获的高精度时间戳。
            Timestamp timestamp;

            /// @brief 序列号，用于检测丢包或乱序，尤其在数据离开系统时。
            uint64_t sequence_id;

            /**
             * @brief 全链路追踪ID (强制性)。
             * @details 从生成此数据的操作继承而来，确保数据处理的每一步都可追溯。
             * 这是实现第三数据架构原则的核心。
             */
            TraceId trace_id;

            /// @brief 数据源模块的名称。
            std::string source_module;

            /// @brief 负载的实际大小（以字节为单位）。
            uint32_t payload_size_bytes;

        } header;

        /**
         * @brief 数据负载。
         * @details 为实现零拷贝和清晰所有权，这通常是一个管理着资源生命周期的
         * 智能指针，如 std::unique_ptr<T, CustomDeleter>。
         * 这是实现第二数据架构原则的核心。
         */
        PayloadType payload;
    };
    ```

### 2.3 核心数据类型别名

  - **概要**: 为了增强代码的可读性并固化数据流各阶段的类型契约，系统为几个关键的数据处理阶段定义了`DataPacket`的类型别名。这些别名在`01_模块接口规范.md`中被正式定义，并在所有相关模块中统一使用。
      - **`RawDataPacket`**: `DataPacket<std::unique_ptr<DataObject, CustomDeleter>>`
          - **描述**: 用于承载由`数据接收模块`产出的原始I/Q数据块。其`payload`是一个指向页锁定内存池中内存块的`unique_ptr`。
      - **`DetectionResultPacket`**: `DataPacket<std::vector<DetectionResult>>`
          - **描述**: 用于承载由`信号处理模块`产出的一批目标检测结果。由于`DetectionResult`是轻量级POD结构，通常以`std::vector`的形式进行批量处理。
      - **`TrackDataPacket`**: `DataPacket<std::vector<TrackData>>`
          - **描述**: 用于承载由`数据处理模块`产出的一批航迹数据。这是系统向外输出的核心业务数据。

-----

## 3 核心数据传输对象 (DTOs)

  - **概要**: 本章详细定义了数据处理流水线中三个关键阶段的数据结构，即数据传输对象（DTOs）。每个定义都包含了其在数据流中的职责、C++结构体的“工程性概念设计”及其背后的设计原则对齐说明。这些结构体是系统数据面（Data Plane）信息承载的实体，其设计的优劣直接决定了系统的性能与可维护性。

### 3.1 DataObject (原始数据)

#### 3.1.1 职责与角色

  - **概要**: `DataObject`是零拷贝数据流的起点，它不直接持有庞大的原始I/Q数据，而是封装了指向`数据接收模块`管理的共享**页锁定内存池**中某个内存块的智能指针。它的核心角色是作为原始信号数据的轻量级句柄，在进入`信号处理模块`进行GPU计算前，安全、高效地管理其底层内存的生命周期。

#### 3.1.2 C++ 结构体定义

  - **概要**: `DataObject`的定义体现了资源句柄与元数据的分离。其核心是一个带有自定义删除器的`std::unique_ptr`，这是实现所有权自动管理和零拷贝的关键。

    ```cpp
    // 概念性定义，非完整头文件
    #include <memory>
    #include <cstdint>

    // 前向声明自定义删除器，其实现与内存池紧密相关
    struct MemoryPoolDeleter;

    struct DataObject {
        // - 描述原始数据的元数据
        uint32_t num_samples;   // 采样点数
        uint32_t num_channels;  // 通道数
        // ... 其他雷达参数

        /**
         * @brief 指向原始I/Q数据的智能指针。
         * @details 这个指针指向一块从共享内存池（通常是页锁定内存）分配的内存，
         * 是实现第一原则（零拷贝）和第二原则（清晰所有权）的核心。
         *
         */
        std::unique_ptr<uint8_t[], MemoryPoolDeleter> raw_data;

        // 设计说明：MemoryPoolDeleter 实现机制
        // MemoryPoolDeleter 是一个轻量级函数对象（functor），其内部通常只包含
        // 一个指向其所属 MemoryPool 实例的指针。这使得 std::unique_ptr 成为
        // 一个'胖指针'（大小为两个指针），但在归还内存时能准确地调用正确的
        // 内存池实例的 release() 方法。
    };
    ```

#### 3.1.3 设计原则对齐

  - **概要**: `DataObject`的设计是核心数据架构原则的集中体现，特别是在高性能内存管理方面。

| 设计决策                               | 关联原则                                            | 理由                                                                                                                                                                                           |
| :------------------------------------- | :-------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 使用`std::unique_ptr`与`CustomDeleter` | **第二原则：清晰的所有权**                          | 确保了内存块所有权的唯一性。当`DataObject`生命周期结束时，自定义删除器`CustomDeleter`会被自动调用，将内存块安全地“归还”给内存池，从而实现了自动化资源管理（RAII），从设计上杜绝了内存泄漏。    |
| 指向**页锁定内存 (Pinned Memory)**     | **第一原则：零拷贝** & **第五原则：面向性能的布局** | 该内存区域不会被操作系统交换到磁盘，允许GPU通过直接内存访问（DMA）进行高效、异步的数据传输。这为下游`信号处理模块`消除了至少一次昂贵的CPU到GPU的同步内存拷贝，是实现端到端高性能数据流的基础。 |

### 3.2 DetectionResult (检测结果)

#### 3.2.1 职责与角色

  - **概要**: `DetectionResult`是由`信号处理模块`产出的结构化点迹信息。它代表了从原始信号中成功检测出的一个潜在目标的基本物理属性，是连接物理信号处理与逻辑目标跟踪的桥梁，也是`数据处理模块`算法流水线的直接输入。

#### 3.2.2 C++ 结构体定义

  - **概要**: `DetectionResult`被设计为一个POD（Plain Old Data）类型，其内存布局经过精心设计以优化后续的批量计算性能。

    ```cpp
    // 概念性定义，非完整头文件
    /**
     * @brief 单个目标检测点的结果。
     * @details 为了在高性能场景中优化SIMD操作，强制要求16字节内存对齐。
     *
     */
    struct alignas(16) DetectionResult {
        double range;       // 距离 (米)
        double velocity;    // 速度 (米/秒)
        double azimuth;     // 方位角 (度)
        double elevation;   // 俯仰角 (度)
        double snr;         // 信噪比 (dB)
        // ... 其他检测属性
    };
    ```

#### 3.2.3 设计原则对齐

  - **概要**: `DetectionResult`的设计重点体现了面向性能的内存布局原则，旨在最大化CPU的计算效率。

| 设计决策      | 关联原则                     | 理由                                                                                                                                                                                                                               |
| :------------ | :--------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `alignas(16)` | **第五原则：面向性能的布局** | 确保结构体实例的起始地址对齐到16字节边界。这使得编译器能够为`数据处理模块`中的批量计算（如坐标变换、距离计算）生成高效的SIMD（单指令多数据）指令（如SSE/AVX），通过向量化并行处理多个`DetectionResult`实例，从而显著提升算法性能。 |

### 3.3 TrackData (航迹数据)

#### 3.3.1 职责与角色

  - **概要**: `TrackData`是由`数据处理模块`产出的高价值业务数据。它不再是离散的点迹，而是对一个被持续跟踪的目标的完整状态估计，包含了身份标识、运动学信息和生命周期状态。它是系统态势感知的最终产物，也是`数据网关模块`对外发布的核心信息。

#### 3.3.2 C++ 结构体定义

  - **概要**: `TrackData`封装了一个目标的动态状态和身份信息，其结构设计兼顾了业务表达的完整性和潜在的性能优化需求。

    ```cpp
    // 概念性定义，非完整头文件
    #include <vector>
    #include <cstdint>

    /**
     * @brief 描述单个目标航迹的完整信息。
     * @details 建议32字节对齐，为未来使用AVX2/AVX-512指令集进行
     * 批量航迹预测或协方差计算预留优化空间。
     */
    struct alignas(32) TrackData {
        /// @brief 唯一的航迹ID。
        uint64_t track_id;

        /// @brief 航迹的生命周期状态。
        enum class TrackStatus { TENTATIVE, CONFIRMED, COAST };
        TrackStatus status; //

        /// @brief 状态向量 [x, y, z, vx, vy, vz, ...]
        std::vector<double> state_vector;

        /// @brief 状态协方差矩阵，表示状态估计的不确定性。
        std::vector<double> covariance_matrix;

        // ... 其他航迹属性，如航迹质量、目标分类等
    };
    ```

#### 3.3.3 设计原则对齐

  - **概要**: `TrackData`的设计在满足当前业务需求的同时，为未来的性能扩展预留了空间。

| 设计决策          | 关联原则                     | 理由                                                                                                                                                                                                                    |
| :---------------- | :--------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `alignas(32)`     | **第五原则：面向性能的布局** | 为未来可能在`数据处理模块`中对航迹列表进行的批量滤波预测或矩阵运算，预留了使用更宽的SIMD指令集（如AVX2/AVX-512）进行优化的空间，这是一种前瞻性的性能设计。                                                              |
| 使用`std::vector` | 灵活性与封装                 | 虽然`std::vector`涉及动态内存分配，但在航迹数量远少于原始点迹数量的场景下，其带来的灵活性（支持不同维度的状态向量和协方差矩阵，适应不同滤波模型）和易用性，优于使用固定大小数组的静态设计。性能开销在此阶段是可接受的。 |

-----

## 4 序列化边界与数据契约

  - **概要**: 本章定义了内部原生C++数据结构如何跨越进程或网络边界，转换为外部系统可以理解的标准格式。它明确了系统中的**序列化边界点**，并提供了服务器与客户端之间进行数据交换的**正式数据契约**。

### 4.1 序列化边界点

  - **概要**: 序列化是将内存中的C++对象转换为网络字节流的CPU密集型过程。为最大化内部性能，本系统严格定义了序列化边界：**序列化只发生在核心处理服务器数据处理流水线的出口**。在此之前，所有数据均以高性能的原生C++对象（通过零拷贝指针）的形式在内部流转。
  - **边界点**:
      - **执行者**: `数据网关模块 (DisplayController)`。
      - **职责**: 该模块作为数据面的终点，负责将内部的 `TrackDataPacket` 消费，并将其`payload`（即 `std::vector<TrackData>`）序列化后，通过网络发送给外部客户端，如`显控终端`。

### 4.2 数据契约：TrackDataBatch.proto

  - **概要**: 本节定义了`数据网关模块`与`显控终端`之间通过网络传输的数据契约。该契约使用 **Protocol Buffers (Protobuf)** 格式定义，是服务器与客户端之间数据一致性的保证。

    ```protobuf
    // File: track_data.proto
    syntax = "proto3";

    package radar.ipc;

    // 用于网络传输的单个航迹对象
    message TrackDataMessage {
      // 核心标识符
      uint64 track_id = 1;

      // 全链路追踪ID，必须传递以实现端到端可观测性
      string trace_id = 2;

      // 航迹状态
      enum TrackStatus {
        TENTATIVE = 0;
        CONFIRMED = 1;
        COAST = 2;
      }
      TrackStatus status = 3;

      // 运动学信息
      message Position {
        double x = 1; // X坐标 (米)
        double y = 2; // Y坐标 (米)
        double z = 3; // Z坐标 (米)
      }
      Position position = 4;

      message Velocity {
        double vx = 1; // X方向速度 (米/秒)
        double vy = 2; // Y方向速度 (米/秒)
        double vz = 3; // Z方向速度 (米/秒)
      }
      Velocity velocity = 5;

      // ... 预留字段，用于未来扩展 ...
    }

    // UDP数据包中包含的航迹批次
    message TrackDataBatch {
      // 批次序列号，用于客户端检测UDP丢包
      uint64 batch_sequence_id = 1;

      // 批次生成时间戳 (纳秒, UTC)
      uint64 timestamp_ns = 2;

      // 包含零个或多个航迹
      repeated TrackDataMessage tracks = 3;
    }
    ```

  - **设计原则对齐**:
    | 设计决策                    | 关联原则                           | 理由                                                                                                                                                                                       |
    | :-------------------------- | :--------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | **使用Protobuf**            | **接口驱动开发** & **可扩展性**    | Protobuf提供了一种与语言无关、平台无关、可扩展的机制来序列化结构化数据。`.proto`文件本身就是一份精确的、机器可读的接口契约，确保了服务器与客户端可以独立演进，只要双方都遵守这份契约。     |
    | **包含`trace_id`**          | **第三原则：强制的全链路可追踪性** | `trace_id`被显式包含在每个`TrackDataMessage`中。这确保了即使数据跨越了网络边界，其可追踪性也不会丢失，使得在`显控终端`可以将在UI上显示的数据与服务器端的处理日志完全关联起来。             |
    | **包含`batch_sequence_id`** | **数据完整性** & **鲁棒性**        | UDP是一种不可靠的传输协议，可能会发生丢包或乱序。`batch_sequence_id`为`显控终端`提供了一种应用层的机制来检测数据包的丢失，从而可以在UI上向操作员提示数据流可能不完整，增强了系统的鲁棒性。 |
-----

## 5 术语表

| 术语                            | 定义与说明                                                                                                                                |
| :------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------- |
| **数据传输对象 (DTO)**          | 一种简单的、只包含数据和访问器方法的对象，用于在不同层或模块之间传递数据。本设计中的`DataObject`, `DetectionResult`, `TrackData`均为DTO。 |
| **POD**                         | “纯旧数据”，指C++中与C语言兼容的、不含虚函数、构造/析构函数等复杂特性的简单`struct`或`class`。POD类型易于进行内存拷贝和跨语言交互。       |
| **内存对齐 (Memory Alignment)** | 指示编译器将一个变量或结构体的起始内存地址安排在某个特定值的倍数上。这对于触发SIMD指令、避免CPU性能惩罚和满足特定硬件要求至关重要。       |

-----

## 6 相关文档

  - **数据架构系列**:
      - `00_数据架构总览与原则.md`
      - `01_数据流设计.md`
      - `03_内存管理与所有权.md`
      - `04_序列化与网络协议.md`
  - **核心模块**:
      - `01_数据接收模块设计.md`
      - `02_信号处理模块设计.md`
      - `03_数据处理模块设计.md`
      - `04_数据网关模块设计.md`
  - **核心接口**:
      - `01_模块接口规范.md`

-----

## 7 变更历史

| 版本号 | 日期       | 作者  | 变更描述                                                                                                                                                          |
| :----- | :--------- | :---- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| v1.0.0 | 2025-10-15 | Klein | **初始版本创建**：基于“工程性概念设计”原则，定义了`DataPacket`包装器和`DataObject`, `DetectionResult`, `TrackData`等核心DTO的公共模式，并阐明了其背后的设计原理。 |
