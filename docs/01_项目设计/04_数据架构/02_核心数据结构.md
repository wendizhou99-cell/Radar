# 02_数据结构定义

- **当前版本**: v1.0.0
- **最后更新**: 2025-09-29

-----

## 1\. 错误码（ErrorCode）

- **定义方式**：全局契约与模块化分布。
- **目标**：确保每个模块的错误码唯一且易于定位。

### 1.1 全局契约

1. 全局契约：ErrorCode 结构体 (The Base)
所有模块函数都将返回这个统一的结构体。它包含判断成功与否的状态，以及一个唯一的数值 ID。

```c++
// File: common/ErrorCode.h (或定义在数据结构定义文件中)

namespace System {

    // 核心结构体：所有函数返回的类型
    struct ErrorCode {
        // 核心字段 1: 错误码的唯一数值 ID
        int value = 0;

        // 核心字段 2: 供人类阅读的详细错误信息
        std::string message = "";

        // 核心行为：检查是否成功
        bool isSuccess() const { return value == 0; }
    };

    // 预定义 SUCCESS 对象
    const ErrorCode SUCCESS {0, "Operation completed successfully."};
}
```

### 1.2 模块化分布

为了实现 **“全局 + 分布”**，我们为每个核心模块分配了一个唯一的数值范围。

| 错误类别        | 编号范围        | 典型模块                            | 错误举例                                                         |
| :-------------- | :-------------- | :---------------------------------- | :--------------------------------------------------------------- |
| **系统级/通用** | `0` - `999`     | 全局基础服务、未处理异常、`SUCCESS` | `RESOURCE_ALLOCATION_FAILED` (通用)                              |
| **数据接收**    | `1000` - `1999` | `DataReceiver`                      | `NET_BIND_ERROR` (1001), `PACKET_CHECKSUM_FAILED` (1002)         |
| **信号处理**    | `2000` - `2999` | `SignalProcessor`                   | `GPU_MEMORY_FAILED` (2001), `CUDA_TIMEOUT` (2002)                |  
| **数据处理**    | `3000` - `3999` | `DataProcessor`                     | `TRACK_ASSOCIATION_FAILED` (3001), `FILTER_DIVERGENCE` (3002)    |
| **服务协调**    | `5000` - `5999` | `TaskScheduler`, `ConfigManager`    | `CONFIG_VALIDATION_FAILED` (5001), `CIRCUIT_BREAKER_OPEN` (5002) |

-----

### 1.3 实践：如何定义和使用模块级错误

模块开发者不应该直接使用数字，而应该使用 **强类型枚举 (`enum class`)** 来提高可读性。

#### A. 模块错误定义示例 (`DataReceiver`)

```cpp
// File: DataReceiverErrors.h

namespace DataReceiverErrors {
    // 强类型枚举，其底层值从 1000 开始
    enum class Code : int {
        // DataReceiver 的错误应该在这个范围内
        NET_BIND_ERROR         = 1001,
        PACKET_CHECKSUM_FAILED = 1002,
        BUFFER_FULL            = 1003,
        // ...
    };

    // 辅助函数：将枚举转换为全局 ErrorCode 结构体
    inline System::ErrorCode create(Code c, const std::string& msg) {
        return { (int)c, (int)c, "DataReceiver Error: " + msg };
    }
}
```

#### B. 模块函数中的使用方式

当您的 `DataReceiver` 模块的 `initialize` 函数需要报告端口绑定失败时，代码会变得非常清晰：

```cpp
// DataReceiver.cpp

System::ErrorCode DataReceiver::initialize() {
    if (port_bind_failed) {
        // 使用模块特定的错误码和全局 ErrorCode 结构体
        return DataReceiverErrors::create(
            DataReceiverErrors::Code::NET_BIND_ERROR,
            "UDP Port 8888 already in use."
        );
    }

    // 成功时返回全局 SUCCESS
    return System::SUCCESS;
}
```

-----








-----

## 2\. 定义全链路追踪 ID（TraceId）

你对分布式文件系统中使用 UUID 的经验非常宝贵。你的项目文档确实将 **`TraceId`** 定义为实现**全链路可观测性**的核心，这和分布式系统中的要求是完全一致的。

### 核心机制：UUID v7 和类型别名

我们采用 **UUID v7** 规范（高性能且时间有序）来生成 ID，但在 C++ 代码中，我们通常用 `std::string` 或 `uint64_t` 来承载它。

#### C++ 代码结构（`common/Trace.h`）

```cpp
#pragma once
#include <string>
#include <cstdint>

/**
 * @brief 全链路追踪ID (TraceId)
 * @details 采用类型别名，确保在日志和事件中以统一的字符串格式传递。
 */
namespace Trace {
    // 强制使用 std::string 来表示 Trace ID，以适应 UUID v4/v7 或其他字符串格式
    using TraceId = std::string;

    // UUID v7: 结合了时间戳和随机性，碰撞率极低，且查询效率高（时间有序）
    const std::string TRACE_ID_FORMAT = "UUID v7 (36 chars)";

    // 无效的Trace ID，用于没有追踪上下文的后台任务
    const TraceId INVALID_TRACE_ID = "N/A";

    // 核心函数：用于在 DataReceiver 模块生成 Trace ID
    TraceId generateNew(); // 实际实现中会调用一个高性能的 UUID 生成器
}
```

-----

## 3\. 定义原始数据结构（RawIQData）

关于雷达原理，你不必深入了解。你只需要关注 **C++ 语言如何高效地表示它**即可。

### 核心机制：`std::complex` 和 `alignas`

1.  **复数类型**：I/Q 数据是复数，C++ 标准库中提供了 `std::complex<T>`。对于高性能计算，我们通常使用**单精度浮点数**（`float`）来平衡精度和性能。
2.  **GPU/SIMD 优化**：为了让你的数据结构能被 CPU 的 SIMD 指令集（如 AVX/SSE）和 GPU 高效处理，你需要确保它遵守**内存对齐**规则。

#### C++ 代码结构（`common/DataTypes.h`）

```cpp
#pragma once
#include <complex>
#include <cstdint>

/**
 * @brief 核心复数数据类型 (IQ Data)
 * @details 采用单精度浮点数，平衡精度和性能。
 */
using ComplexFloat = std::complex<float>;

/**
 * @brief 原始雷达数据结构
 * @details 封装了从网络接收到的原始 IQ 数据和必要的元数据
 * @note 必须确保内存对齐，以支持 SIMD 和 GPU 传输
 */
struct alignas(32) RawIQData {
    // 头部元数据
    uint64_t sequence_number; // 序列号
    uint32_t num_samples;     // 样本点数量
    uint32_t num_channels;    // 阵元/通道数量
    float sampling_rate_mhz;  // 采样率

    // 数据负载 (指针或智能指针，用于零拷贝)
    // 零拷贝实现时，这里通常是一个智能指针，指向实际的内存块
    ComplexFloat* data_ptr = nullptr;

    // 用于零拷贝的自定义类型，这里只是占位符
    // std::unique_ptr<ComplexFloat[], MemoryPoolDeleter> payload;
};
```

你现在已经完成了第一周清单中关于 **核心数据结构** 的任务！你成功地将分布式系统的经验（UUID、分层错误码）映射到了 C++ 的语法和项目架构中。

我们接下来继续推进第一周清单的剩余部分。
