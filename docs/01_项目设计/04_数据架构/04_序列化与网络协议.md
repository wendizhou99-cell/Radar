# 序列化与网络协议

  - **当前版本**: v1.0.0
  - **最后更新**: 2025-10-15
  - **负责人**: Klein

-----

## 概述

  - **概要**: 本文件是系统**内部世界**与**外部世界**之间的“**外交条约**”和“**通信密码本**”。它的核心职责是精确、无歧义地定义核心处理服务器如何将其内部高价值的数据（`TrackData`）打包，并通过网络发送给外部客户端（如`显控终端`）。本文档是`数据网关模块` 与`显控终端应用` 之间数据面（Data Plane）通信的唯一权威技术规范。

-----

## 目录

- [序列化与网络协议](#序列化与网络协议)
  - [概述](#概述)
  - [目录](#目录)
  - [1 文档职责](#1-文档职责)
    - [1.1 文档目标](#11-文档目标)
    - [1.2 核心原则对齐](#12-核心原则对齐)
  - [2 序列化格式：Protocol Buffers](#2-序列化格式protocol-buffers)
    - [2.1 技术选型理由](#21-技术选型理由)
    - [2.2 数据契约 (`track_data.proto`)](#22-数据契约-track_dataproto)
  - [3 网络传输协议：UDP](#3-网络传输协议udp)
    - [3.1 技术选型理由](#31-技术选型理由)
    - [3.2 UDP数据报结构](#32-udp数据报结构)
  - [4 实现与错误处理指南](#4-实现与错误处理指南)
    - [4.1 服务器端实现 (`DisplayController`)](#41-服务器端实现-displaycontroller)
    - [4.2 客户端实现 (`ClientApp`)](#42-客户端实现-clientapp)
    - [4.3 错误处理（反序列化失败）](#43-错误处理反序列化失败)
  - [5 术语表](#5-术语表)
  - [6 相关文档](#6-相关文档)
  - [7 变更历史](#7-变更历史)

-----

## 1 文档职责

  - **概要**: 本章定义了本文档自身的“使命”，明确其目标、范围以及设计所遵循的核心架构原则，确保本设计与系统整体架构保持一致。

### 1.1 文档目标

  - **概要**: 本节旨在清晰界定本文档要讲什么、不讲什么，为读者设定正确的预期。
      - **目标**:
          - 明确选择 **Protocol Buffers (Protobuf)** 作为跨进程/跨语言的序列化格式，并阐明其选型理由。
          - 提供作为服务器与客户端之间核心数据契约的 **`.proto` 文件**的完整定义。
          - 详细规定基于 **UDP** 的网络传输协议，包括数据报的负载结构。
          - 为服务器端和客户端提供关键的**实现步骤**和**错误处理**指南，确保对接的准确性。

### 1.2 核心原则对齐

  - **概要**: 本节旨在确保本文档所有设计决策都与项目已确立的架构原则完全对齐。

| 核心原则 | 在本设计中的具体体现 |
| :--- | :--- |
| **数据与控制分离** | 本文档精确定义了**数据面 (Data Plane)** 的出口协议（Protobuf over UDP），与`外部接口设计`中定义的基于RESTful API的控制面完全分离。 |
| **接口驱动开发** | `.proto` 文件本身就是一份精确的、机器可读的**接口契约**。服务器与客户端的开发都以此为依据，实现了并行开发和关注点分离。 |
| **全链路可观测性** | 数据契约 `TrackDataMessage` 中**强制包含 `trace_id` 字段**，确保了追踪链能够跨越网络边界，从服务器一直延伸到客户端，是实现端到端问题定位的关键。 |

-----

## 2 序列化格式：Protocol Buffers

  - **概要**: 本章深入阐述作为跨系统通信“语言”的Protocol Buffers (Protobuf) 的设计决策与具体契约。Protobuf以其高性能、跨语言兼容性和强大的模式演进能力，被选定为本系统在`数据网关模块`与`显控终端`之间进行数据交换的唯一序列化格式。

### 2.1 技术选型理由

  - **概要**: 序列化格式的选择是影响分布式系统性能、可维护性和可扩展性的关键技术决策。本节通过对几种主流方案的量化与定性对比，阐明选择Protocol Buffers作为本系统数据契约语言的严谨性与前瞻性。

| 评估维度 | Google Protobuf (推荐方案) | JSON (JavaScript Object Notation) | 自定义二进制格式 (Custom Binary) |
| :--- | :--- | :--- | :--- |
| **性能/效率** | **极高**。采用二进制编码和变长整数（Varints），序列化后的数据体积极小，编解码速度快。 | **低**。基于文本，可读性好但冗余度高，数据体积通常是Protobuf的数倍，解析开销大。 | **理论最高**。可以为特定场景手工优化到极致，但通常难以兼顾通用性。 |
| **跨语言支持** | **优秀**。官方支持C++, Python, C\#, Java, Go等主流语言，生态系统成熟，能自动生成各语言的编解码代码。 | **极好**。作为Web事实标准，几乎所有编程语言都有内置或高质量的第三方库支持。 | **差**。需要为每一种需要集成的语言（例如，服务器端的C++和客户端的C\#）手写和维护独立的、易出错的解析器。 |
| **模式演进 (Schema)** | **优秀**。`.proto`文件定义了强类型的数据模式。支持向后兼容的字段增删，允许服务器和客户端以不同的速度进行版本迭代而互不影响。 | **一般**。本身无内置模式，依赖外部约定（如JSON Schema）或隐式契约，字段变更容易导致运行时解析错误。 | **差**。模式变更极其脆弱且成本高昂。任何字段的增删或顺序调整都可能导致所有客户端的解析逻辑失效，需要同步更新。 |
| **开发与维护成本** | **低**。`protoc`编译器自动生成类型安全的数据访问类，开发者只需关注业务逻辑。`.proto`文件本身就是清晰、自描述的文档。 | **极低**。语法简单，人类可读性强，调试直观。 | **极高**。需要投入大量精力编写、测试和维护复杂的、低层次的字节操作代码，极易引入Bug。 |

  - **设计决策**: 综合评估，**Protocol Buffers** 在性能、跨语言兼容性和模式演进能力上取得了最佳平衡，完美契合本系统对高性能、长期可维护性和未来可扩展性的核心需求。它将数据契约的管理从“人工约定”提升到了“代码生成”的工程化高度，显著降低了分布式系统开发的复杂性。

### 2.2 数据契约 (`track_data.proto`)

  - **概要**: 本节提供作为服务器与客户端之间核心数据契约的 `.proto` 文件完整定义。这份文件是所有跨进程数据交互的唯一事实来源，任何一方的实现都必须严格遵守。

    ```protobuf
    // File: track_data.proto
    // 该文件定义了从核心处理服务器发送到外部客户端的航迹数据的标准格式。
    syntax = "proto3";

    package radar.ipc;

    // 用于网络传输的单个航迹对象。
    // 它的字段是内部C++结构体 `TrackData` 的一个子集，只包含对外暴露的必要信息。
    message TrackDataMessage {
      // 核心标识符
      // 航迹的全局唯一ID。
      uint64 track_id = 1;

      // 全链路追踪ID。
      // 必须传递，用于将客户端的显示问题与服务器端的完整处理日志关联起来，
      // 是实现第三原则：强制的全链路可追踪性的关键。
      //
      string trace_id = 2;

      // 航迹的当前生命周期状态。
      enum TrackStatus {
        TENTATIVE = 0; // 试探性
        CONFIRMED = 1; // 已确认
        COAST = 2;     // 惯性外推
      }
      TrackStatus status = 3;

      // 运动学信息 - 位置
      message Position {
        double x = 1; // X坐标 (米)
        double y = 2; // Y坐标 (米)
        double z = 3; // Z坐标 (米)
      }
      Position position = 4;

      // 运动学信息 - 速度
      message Velocity {
        double vx = 1; // X方向速度 (米/秒)
        double vy = 2; // Y方向速度 (米/秒)
        double vz = 3; // Z方向速度 (米/秒)
      }
      Velocity velocity = 5;

      // ... 预留字段，用于未来扩展，例如目标分类、置信度等 ...
    }

    // UDP数据包中包含的航迹批次。
    // 这是UDP网络传输的基本单元。
    message TrackDataBatch {
      // 批次序列号，由服务器端单调递增。
      // 客户端必须使用此字段来检测UDP传输过程中的数据包丢失，
      // 是应用层数据完整性保障的关键机制。
      //
      uint64 batch_sequence_id = 1;

      // 批次在服务器端的生成时间戳 (纳秒, UTC)。
      // 可用于客户端计算端到端延迟。
      uint64 timestamp_ns = 2;

      // 一个批次中可以包含零个或多个航迹。
      repeated TrackDataMessage tracks = 3;
    }
    ```

-----

## 3 网络传输协议：UDP

  - **概要**: 本章深入阐述作为承载序列化数据的“信封”——UDP协议的设计决策与规范。它解释了为什么在实时数据传输场景下选择UDP，并精确定义了UDP数据报在线路上传输时的负载结构。

### 3.1 技术选型理由

  - **概要**: 本节阐明在TCP与UDP之间进行权衡后，选择UDP作为数据面（Data Plane）传输协议的核心理由，以体现架构决策的严谨性。

  - **核心权衡**: 在`显控终端`的实时态势显示场景下，数据的**时效性**和**低延迟**是首要目标。旧的数据（即使丢失）的价值远低于最新的数据。基于此，我们对TCP和UDP进行如下对比：

| 评估维度 | UDP (本方案选用) | TCP (Transmission Control Protocol) |
| :--- | :--- | :--- |
| **延迟 (Latency)** | **极低**。无连接握手，无内置重传延迟，数据包直接发送。 | **较高**。需要三次握手建立连接，并有确认（ACK）、超时重传和拥塞控制机制，这些都会引入不可预测的延迟。 |
| **可靠性 (Reliability)** | **不可靠**。尽力而为（Best-effort）的交付，不保证送达，不保证顺序。 | **可靠**。通过序列号、确认和重传机制，保证所有数据按序、无损地到达。 |
| **拥塞控制** | **无**。由应用层负责，若发送速率超过网络承载能力，易造成丢包。 | **内置**。复杂的拥塞控制算法（如慢启动、拥塞避免）会动态调整发送速率，但增加了延迟和协议复杂性。 |
| **适用场景** | 实时流媒体、在线游戏、VoIP以及本系统的**高频态势数据更新**。在这些场景中，一帧数据的丢失或乱序通常可以被容忍，而延迟是不可接受的。 | 文件传输、网页浏览、数据库连接等**要求数据绝对完整和正确**的场景。 |

  - **设计决策**:
    鉴于`显控终端`对数据实时性的严苛要求，**UDP**的低延迟和简单性是最佳选择。TCP的可靠性机制，特别是其严格的按序重传，可能会导致“队头阻塞（Head-of-Line Blocking）”问题——一个旧数据包的丢失会阻塞所有后续新数据包的交付，这对于态势显示是致命的。系统通过在应用层（`TrackDataBatch`中的`batch_sequence_id`）实现简单的丢包检测，来弥补UDP的不可靠性，达到了性能与可靠性之间的最佳平衡。

### 3.2 UDP数据报结构

  - **概要**: 本节清晰定义一个UDP数据包在线路上传输时的负载（Payload）结构，以确保客户端可以正确解析。
  - **负载结构**:
    一个UDP数据报的负载**就是且仅是**一个经过Protobuf序列化后的`TrackDataBatch`二进制字节流。系统**不**在UDP负载中添加任何额外的自定义应用层包头，所有必要的元数据（如序列号、时间戳、追踪ID）都已封装在`TrackDataBatch`消息内部，遵循**第二章**定义的`.proto`数据契约。

| UDP Header | Serialized `TrackDataBatch` Payload |
| :--- | :--- |
| (由操作系统和网络栈管理) | (由`DisplayController`生成，`ClientApp`解析) |

  - **设计收益**: 这种设计的优点是极致的**简洁与高效**。客户端无需进行复杂的多层解包，只需将收到的整个UDP负载直接送入Protobuf的反序列化解析器即可，极大地简化了客户端的实现逻辑并提升了解析性能。

-----

## 4 实现与错误处理指南

  - **概要**: 本章提供端到端的实现指导，旨在将上述设计规范转化为具体的、可操作的工程实践，以连接设计与代码，确保服务器与客户端的正确对接。

### 4.1 服务器端实现 (`DisplayController`)

  - **概要**: 本节简述`数据网关模块`在将内部`TrackData`发送到网络时需要遵循的核心步骤。
    - 1. **消费数据**: 从上游的`IDataQueue<TrackDataPacket>`中消费一个`TrackDataPacket`实例。
    - 2. **构建消息**: 创建一个`radar.ipc.TrackDataBatch` Protobuf消息对象。
      - 设置`timestamp_ns`为当前时间戳。
      - **原子地**递增并设置`batch_sequence_id`。
      - 遍历`TrackDataPacket`负载中的`std::vector<TrackData>`，为每个`TrackData`对象创建一个对应的`TrackDataMessage`，并填充其字段（`track_id`, `trace_id`, `status`等），然后将其添加到`TrackDataBatch`的`tracks`重复字段中。
    - 3. **序列化**: 调用`batch.SerializeToArray()`或`SerializeToString()`方法，将Protobuf消息对象转换为二进制字节流。
    - 4. **发送数据**: 通过`UdpTransmitter`组件，使用**非阻塞**的`sendto()`系统调用，将该二进制字节流作为单个UDP数据报的负载，发送到配置文件中指定的目标IP地址和端口。

### 4.2 客户端实现 (`ClientApp`)

  - **概要**: 本节简述`显控终端应用`在其网络服务中接收和处理航迹数据时需要遵循的核心步骤。
    - 1. **接收数据**: 在一个专用的后台网络线程中，通过`recvfrom()`系统调用监听配置的UDP端口，接收数据报。
    - 2. **反序列化**:
      - 创建一个空的`radar.ipc.TrackDataBatch` Protobuf消息对象。
      - 调用`batch.ParseFromArray()`或`ParseFromString()`方法，将接收到的UDP负载字节流解析到该对象中。
    - 3. **完整性检查**:
      - **必须**检查`batch_sequence_id`。将其与客户端维护的上一帧序列号进行比较。如果不连续，则认为发生了丢包，应更新内部状态以在UI上进行提示，并递增丢包计数器。
    - 4. **处理数据**:
      - 遍历`batch.tracks()`列表中的每个`TrackDataMessage`。
      - 提取`trace_id`并用于客户端的本地日志记录，以完成全链路追踪。
      - 将`TrackDataMessage`的内容转换为UI模型所需的数据结构，并通过线程安全的信号-槽机制或其他跨线程通信方式，通知主UI线程更新态势显示。

### 4.3 错误处理（反序列化失败）

  - **概要**: 本节明确规定当客户端接收到损坏或格式不符的数据包时，为保证系统鲁棒性必须遵循的标准处理流程。
  - **触发条件**: 客户端调用`batch.ParseFromArray()`或`ParseFromString()`方法返回`false`。
  - **处理策略**: 客户端**必须**执行以下操作：
    - 1. **记录错误**: 记录一条`ERROR`级别的日志。该日志**必须**包含尽可能多的上下文信息，特别是数据报的来源IP和端口，以便于网络故障排查。
    - 2. **递增计数器**: 原子地递增一个专用于监控的“反序列化失败包”性能计数器（例如 `deserialization_failures_total`）。
    - 3. **安全丢弃**: **必须**安全地丢弃这个损坏的数据包，并立即返回网络监听循环，准备接收和处理下一个数据包。客户端**严禁**因此类错误而崩溃、抛出未捕获的异常或进入阻塞状态。

-----

## 5 术语表

| 术语 / 英文全称 (缩写) | 定义与说明 |
| :--- | :--- |
| **序列化 (Serialization)** | 将内存中的数据结构（如C++对象）转换为可以存储或通过网络传输的字节流的过程。 |
| **反序列化 (Deserialization)** | 序列化的逆过程，将字节流还原为内存中的数据结构。 |
| **Protocol Buffers (Protobuf)** | Google开发的一种高效、平台无关、可扩展的数据序列化格式，用于在本系统中定义服务器与客户端之间的数据契约。 |
| **UDP (User Datagram Protocol)** | 用户数据报协议，一种无连接的、不可靠的传输层协议。因其低开销和低延迟特性，被选为本系统数据面的传输协议。 |
| **数据契约 (Data Contract)** | 在系统不同部分（如服务器与客户端）之间关于数据交换格式和结构的正式约定。在本设计中，`.proto`文件就是核心数据契约。 |

-----

## 6 相关文档

  - **核心模块**:
      - `04_数据网关模块设计.md`
      - `09_显控终端应用设计.md`
  - **数据架构系列**:
      - `00_数据架构总览与原则.md`
      - `02_核心数据结构.md`
  - **核心接口**:
      - `02_外部接口设计.md`

-----

## 7 变更历史

| 版本号 | 日期 | 作者 | 变更描述 |
| :--- | :--- | :--- | :--- |
| v1.0.0 | 2025-10-15 | Klein | **初始版本创建**: 确立了以Protobuf为序列化格式、UDP为传输协议的外部数据通信规范，并提供了核心的`.proto`数据契约和实现指南。 |
