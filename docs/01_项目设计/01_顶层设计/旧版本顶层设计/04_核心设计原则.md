# 核心设计原则

  - **当前版本**: v2.0.0
  - **最后更新**: 2025-10-13
  - **负责人**: Klein

-----

## 概述

  - **概要**: 本文件是雷达数据处理系统所有设计与开发的**最高指导纲领**。它不仅定义了项目的**四大架构基石**——即我们为实现系统目标所选择的、不可动摇的架构战术，还详细阐述了我们为追求卓越工程质量所遵循的**一系列核心设计原则**。本文档是确保系统在长期演进过程中保持技术一致性、架构健壮性和高度可维护性的“技术宪法”。

-----

## 目录

- [核心设计原则](#核心设计原则)
  - [概述](#概述)
  - [目录](#目录)
  - [1 项目架构基石](#1-项目架构基石)
    - [1.1 基石一：事件驱动，异步通信](#11-基石一事件驱动异步通信)
    - [1.2 基石二：接口注入，依赖倒置](#12-基石二接口注入依赖倒置)
    - [1.3 基石三：数据与控制分离](#13-基石三数据与控制分离)
    - [1.4 基石四：可观测性优先，追踪贯穿](#14-基石四可观测性优先追踪贯穿)
  - [2 架构设计原则](#2-架构设计原则)
    - [2.1 分层架构原则](#21-分层架构原则)
    - [2.2 并发设计原则](#22-并发设计原则)
    - [2.3 可扩展性原则](#23-可扩展性原则)
  - [3 质量保证原则](#3-质量保证原则)
    - [3.1 可靠性设计原则](#31-可靠性设计原则)
    - [3.2 可观测性原则](#32-可观测性原则)
    - [3.3 可维护性原则](#33-可维护性原则)
  - [4 核心实现原则](#4-核心实现原则)
    - [4.1 接口设计原则](#41-接口设计原则)
    - [4.2 模块化设计原则](#42-模块化设计原则)
    - [4.3 性能导向原则](#43-性能导向原则)
    - [4.4 文档驱动原则](#44-文档驱动原则)
  - [5 原则优先级](#5-原则优先级)
  - [6 术语表](#6-术语表)
  - [7 相关文档](#7-相关文档)
  - [8 变更历史](#8-变更历史)

-----

## 1 项目架构基石

-   **概要**: 本章定义了支撑整个系统架构的**四大基石**。它们是本项目区别于其他系统的核心技术哲学，是我们在面对复杂性、高性能和可维护性挑战时所做出的根本性架构决策。所有后续的设计原则都是围绕这四大基石展开的具体实践。

### 1.1 基石一：事件驱动，异步通信

-   **概要**: 模块间的**控制流**与**状态通知**必须通过异步事件总线（EventBus）进行。严禁模块间的直接方法调用，以实现生产者与消费者的完全解耦。这是保障系统**低耦合**和**高弹性**的核心。

-   **实践要点**:
    * 模块的生命周期（启停、暂停）由`TaskScheduler`通过发布命令事件来驱动。
    * 模块发生致命错误时，必须发布`ModuleFailedEvent`事件，而不是试图自己处理或直接通知其他模块。
    * 配置变更由`ConfigManager`发布`ConfigChangedEvent`事件，各模块订阅并自主响应。
    * 模块间的主要通信方式是通过异步事件。所有控制流、状态变更通知和错误上报都必须通过统一的`EventBus`进行解耦通信。
    * 数据处理流水线之间通过专用的、解耦的并发队列传递数据，而非事件。

### 1.2 基石二：接口注入，依赖倒置

-   **概要**: 所有模块对外部服务（如日志、配置、事件总线）的依赖，**必须**通过构造函数注入抽象接口（如 `std::shared_ptr<ILogger>`）来解决。严禁使用全局单例或服务定位器模式。这是保障系统**可测试性**和**灵活性**的核心。

-   **实践要点**:
    * 模块的构造函数签名应清晰地暴露其所有外部服务依赖。
    * 在`main`函数中显式创建所有服务实例，并按照依赖顺序完成注入和初始化。
    * 注入的依赖必须是抽象接口类型，而非具体实现类。
    * 这种设计使得单元测试极为方便，可以轻松注入模拟（Mock）的服务对象。

### 1.3 基石三：数据与控制分离

-   **概要**: 明确区分高性能的**数据流通道**（数据面）与高可靠的**控制/事件流通道**（控制面）。接口设计必须严格反映并维护这种分离，以允许为不同目标选择最优的技术实现。

-   **实践要点**:
    * **数据面**: 目标是极致性能、低延迟、高吞吐。通过共享内存池、并发无锁队列以及智能指针传递数据块引用（而非数据本身）来实现端到端零拷贝。数据接口（如 `IDataQueue<T>`）专注于高效的数据推送和获取，并包含明确的背压机制。
    * **控制面**: 目标是解耦、可靠性、可追踪性。通过 `EventBus` 传递轻量级的控制命令、状态通知和错误事件。事件负载应尽可能小，不应携带大的数据块。

### 1.4 基石四：可观测性优先，追踪贯穿

-   **概要**: **`TraceID` 是一等公民**。系统中的任何一次操作、一个数据流或一个事件链都必须能够被唯一标识和端到端追踪。这是保障系统在复杂分布式环境下**可调试、可诊断**的核心。

-   **实践要点**:
    * 所有在数据管道中流转的数据包（`DataPacket<T>`），其头部必须包含 `TraceID` 字段。
    * 所有经由事件总线传递的事件（`BaseEvent`），必须包含 `TraceID` 字段。
    * 在进行异步操作（如向线程池提交任务）时，必须将当前 `TraceID` 一并传递给工作线程。
    * 所有日志输出宏（`RADAR_INFO`等）都应自动记录当前上下文的 `TraceID`。
    * 每个进入系统的API请求，必须在网关层为其生成一个唯一的`TraceID`，并注入到后续所有内部事件和数据包中。

-----

## 2 架构设计原则

-   **概要**: 本章定义了系统在**宏观结构**层面必须遵循的准则。它们是“架构基石”的具体体现，共同塑造了系统的骨架，确保其在演进过程中保持形态的稳定与一致。

### 2.1 分层架构原则

-   **概要**: 系统在逻辑上必须划分为清晰的层次。层间依赖必须是单向的，且通信必须通过标准化的抽象接口进行，以实现关注点分离和降低系统复杂度。这不仅应用于系统宏观层面，也应用于模块内部设计。

-   **实践要点**:
    * **系统级分层**: 整个核心处理服务器在宏观上划分为三大层次，职责清晰，依赖单向。
        * **调度与服务层**: 系统的“大脑”，负责生命周期管理 (`TaskScheduler`) 和提供基础服务（`LoggingService`, `ConfigManager`）。
        * **数据处理流水线层**: 系统的“生产线”，包含了所有核心业务模块（`DataReceiver`, `SignalProcessor` 等），负责数据的高性能处理。
        * **通信与基础设施层**: 系统的“神经网络”，即 `EventBus`，负责所有模块的解耦通信。
    * **模块内分层**: 各核心模块（如`数据处理模块`）的内部架构也同样遵循分层思想，通常划分为职责明确的三层。
        * **执行层**: 负责驱动模块主循环和编排数据流 (`ExecutionEngine`)。
        * **算法策略层**: 包含所有可插拔的业务逻辑实现（如 `IAssociator`, `ITrackFilter`），体现了决策与执行的分离。
        * **资源/状态管理层**: 负责状态的持久化存储（如 `TrackManager`）和资源管理。

### 2.2 并发设计原则

-   **概要**: 并发设计必须在保证线程安全的前提下，最大化系统吞吐量。应优先选择无锁数据结构、异步处理模式，并遵循**基石一（事件驱动）**和**基石三（数据与控制分离）**来简化并发场景的复杂性。

-   **实践要点**:
    * **职责分离的线程模型**: 严格分离I/O密集型任务与CPU/GPU密集型任务。例如，`数据接收模块`采用专用的I/O线程负责网络收包，并通过无锁队列将计算任务派发给独立的工作线程池，避免了网络I/O被CPU计算阻塞。
    * **数据面的无锁化**: 在高性能的数据处理流水线（数据面）中，模块间的数据交换**必须**通过线程安全的无锁或少锁并发队列（`IDataQueue`）进行，以消除锁竞争，最大化吞吐量。
    * **控制面的事件化**: 在控制面，所有跨线程的通信和状态同步都通过`EventBus`的异步事件模型完成。订阅者的回调在`EventBus`的专用工作线程中执行，从而将复杂的线程同步问题转化为清晰的事件处理流程。
    * **GPU并行与重叠**: 计算密集型模块（如`信号处理模块`）必须利用多CUDA流（Streams）技术，实现数据传输（H2D）、核心计算（Kernel Execution）和结果回传（D2H）的流水线式重叠执行，最大化GPU利用率。

### 2.3 可扩展性原则

-   **概要**: 架构设计必须预留清晰的扩展点，以适应未来的功能增加和技术演进。必须广泛使用策略模式、配置驱动设计和接口隔离思想，允许在不修改核心代码的情况下增加新算法或行为。

-   **实践要点**:
    * **算法的策略化**: 所有核心算法（如信号处理中的FFT/CFAR，数据处理中的关联/滤波）都**必须**被抽象为策略接口（如 `IAlgorithm`, `IAssociator`）。具体实现作为可插拔的插件，通过算法工厂根据配置文件动态创建和组装。这使得新增一种滤波算法，仅需添加一个新的实现类，而无需改动`DataProcessor`的核心逻辑。
    * **行为的配置驱动**: 模块的行为逻辑应由外部配置驱动，而非硬编码。例如，`ConfigManager`不仅提供简单的参数值，还定义了`信号处理模块`中算法流水线的构成顺序和参数，使得调整处理流程无需重新编译代码。
    * **能力的接口化**: 遵循**接口隔离原则**，系统的能力被抽象为多个角色接口（`IPausable`, `IMonitorable`等）。当未来需要为系统引入一种全新的能力（例如，`IReloadable`，支持资源热重载）时，我们只需定义一个新的角色接口，并让需要的模块实现它即可，而无需修改所有模块都依赖的`ILifecycleManaged`基类，实现了能力的“按需插拔”。

-----

## 3 质量保证原则

  - **概要**: 本章将所有关乎系统健壮、可靠、易于维护的**非功能性设计准则**集中进行定义。它们是系统的“免疫系统”，确保系统在面对真实世界的混乱和变化时能够保持稳定，并且在整个生命周期内易于理解和演进。

### 3.1 可靠性设计原则

  - **概要**: 系统必须具备强大的错误处理和容错能力，能够从故障中优雅恢复。我们的设计哲学不是“期望不出错”，而是“假定一定会出错”，并为此构建一个有弹性的、可自愈的系统。

  - **实践要点**:

      * **分级错误处理**: 模块作为“执行者”，负责处理本地可恢复的错误（如丢弃格式错误的数据包），并将自身无法解决的致命错误（如资源绑定失败）封装成 `ModuleFailedEvent` 事件，上报给作为“决策者”的 `TaskScheduler`。`TaskScheduler` 接收到事件后，根据预设的系统级策略执行恢复操作（如重启模块、执行降级）。
      * **防御性设计**: 架构中必须预置多种容错机制，以应对不同的故障场景：
          * **熔断器 (Circuit Breaker)**: `TaskScheduler` 必须实现熔断机制，以防止对一个持续快速失败的模块进行无限次的重启尝试，避免“恢复风暴”消耗系统资源。
          * **背压机制 (Back-pressure)**: 在数据处理流水线中，模块间的有界并发队列（`IDataQueue`）必须能实现隐式的背压。当下游模块处理不过来导致队列满时，上游模块的写入操作会被自然阻塞，压力逐级向上传导，最终甚至暂停网络I/O，从而防止因内存耗尽而导致的数据丢失。
          * **超时处理 (Timeout Handling)**: 所有关键的阻塞操作，特别是模块的 `stop()` 方法，都必须有超时保护，防止单个模块无响应而卡死整个系统的关闭或恢复流程。
          * **智能重连 (Smart Reconnection)**: 外部客户端（如显控终端）在与后端服务器的网络连接中断时，必须采用指数退避（Exponential Backoff）策略进行重连尝试，避免在服务器故障时“轰击”API网关。

### 3.2 可观测性原则

  - **概要**: 系统的任何内部状态和行为都必须是可观测的。这是\*\*基石四（可观测性优先）\*\*的全面展开，旨在消除系统中的“黑盒”，确保任何问题都可以被快速定位和诊断。

  - **实践要点**:

      * **全面监控**: 系统必须有一个专用的 `MonitoringModule`，它通过订阅 `MetricsUpdateEvent` 事件，以非侵入的方式聚合来自所有业务模块的性能指标。监控指标体系应覆盖基础设施、系统、性能和业务四个层面。同时，关键模块必须实现 `IMonitorable` 接口，以支持低频的、同步的健康状态拉取。
      * **结构化日志**: 所有日志**必须**通过统一的日志宏（`RADAR_INFO`, `RADAR_ERROR` 等）进行记录。这些宏必须能自动将日志格式化为结构化的文本，并注入当前线程上下文中的 `TraceID`，确保日志的机器可读性和可追踪性。
      * **端到端追踪**: 作为**基石四**的核心要求，`TraceID` **必须**在系统的每一次交互中被严格传递。这包括：
          * 在数据面的 `DataPacket<T>` 头部中传递。
          * 在控制面的 `BaseEvent` 中传递。
          * 在跨线程派发任务时作为参数传递。
          * 在对外暴露的 RESTful API 的请求头和响应体中传递，将追踪链延伸至外部客户端。

### 3.3 可维护性原则

  - **概要**: 代码和文档都必须清晰、一致、易于理解，以降低长期维护成本和新成员的学习曲线。可维护性是我们能否在项目生命周期内持续、高效地交付价值的关键。

  - **实践要点**:

      * **代码组织**: 遵循统一的模块化代码组织策略，每个模块的代码位于独立的目录中，接口、实现和测试文件分离清晰。
      * **文档同步**: 任何设计决策和代码变更都**必须**在相应的文档中同步体现。所有设计文档都必须包含“变更历史”章节，以记录其演进过程。文档本身也必须遵循标准化的模板和编写指南。
      * **接口版本管理**: 所有对外和对内的接口**必须**遵循[**`05_接口版本管理.md`**](../05_接口设计/01_模块接口规范.md)中定义的语义化版本控制（Semantic Versioning）规范。任何破坏性变更都必须在主版本号中体现，并遵循标准的弃用策略，为接口的消费者提供稳定、可预测的演进路径。

-----

## 4 核心实现原则

-   **概要**: 本章定义了开发者在日常编码和具体设计工作中需要遵循的**实践准则**。它们是将宏观架构和质量目标落地为高质量代码和文档的“最后一公里”。

### 4.1 接口设计原则

-   **概要**: 接口是模块间的契约，其设计质量直接决定了系统的可维护性。
-   **实践要点**:
    * **接口隔离**: 遵循 [**`01_模块接口规范.md`**](../05_接口设计/01_模块接口规范.md)，接口的定义应追求“小而专”。系统将庞大的 `IModule` 接口，根据职责拆分为多个更小的、基于角色的接口，如 `ILifecycleManaged`、`IPausable` 和 `IMonitorable`。模块则根据自身需要，组合实现一个或多个这样的角色接口。
    * **版本管理**: 遵循 [**`05_接口版本管理.md`**](../05_接口设计/01_模块接口规范.md)，所有接口都必须遵循语义化版本控制（vMAJOR.MINOR.PATCH）规范。任何破坏性变更都必须在主版本号中体现，并且必须遵循标准的接口弃用策略，为接口的消费者提供稳定、可预测的演进路径。

### 4.2 模块化设计原则

-   **概要**: 模块是系统可维护性和可扩展性的基础。
-   **实践要点**:
    * **单一职责**: 每个模块和组件都应只有一个变更的理由，以降低复杂性。例如，`数据处理模块`将航迹的存储 (`TrackManager`) 与其生命周期逻辑 (`TrackLifecycleManager`) 分离。日志服务 (`LoggingService`) 与监控服务 (`MonitoringModule`) 也被拆分为两个独立的模块，职责清晰。
    * **无状态逻辑**: 模块的核心业务逻辑（如算法）应设计为无状态的，其行为仅依赖于输入，不持有跨次调用的状态。例如，`数据处理模块`中的算法策略类（如 `IAssociator`, `ITrackFilter`）的 `process()` 方法应是可重入的，其行为仅依赖于传入的 `DataContext`。

### 4.3 性能导向原则

-   **概要**: 系统必须满足实时处理的严苛性能要求。
-   **实践要点**:
    * **零拷贝数据流**: 在数据面的核心路径上，必须通过指针传递和共享内存池实现端到端零拷贝。数据在处理管道中通过 `DataPacket<T>` 封装的智能指针进行传递，而非内容拷贝。`数据接收模块`从页锁定内存池中获取内存块，网络数据直接读入，随后将指针封装到 `DataObject` 中推向下游。
    * **并行计算**: 必须充分利用多核CPU与GPU资源。`数据接收模块`采用专用的I/O线程与CPU密集型的解析工作线程池分离的多级流水线模型。`信号处理模块`则利用多CUDA流技术，实现数据传输、核心计算和结果回传的重叠执行，以最大化GPU利用率。

### 4.4 文档驱动原则

-   **概要**: 设计文档是开发活动的起点和最终沉淀。我们坚持“先设计，后编码”。
-   **实践要点**:
    * **结构化与标准化**: 所有设计文档都必须遵循统一的[**`模块设计文档基准模板.md`**](../02_模块设计/00_模块设计文档基准模板.md) 进行编写。
    * **可视化表达**: 复杂的设计必须使用Mermaid图表进行可视化，并遵循[**`Mermaid可视化设计指南.md`**](../../03_技术规范/Mermaid可视化设计指南.md)。
    * **意图阐明**: 每个章节和子章节都必须包含“概要”部分，向读者解释“本节写什么”以及“为什么要写”。

-----

## 5 原则优先级

  - **概要**: 在复杂的系统设计中，不同的设计原则有时会产生冲突。例如，一个为了极致性能的方案可能会牺牲一定的可维护性。本节定义了一个清晰的决策框架，规定了在发生冲突时，我们应遵循的优先级顺序。

  - **决策顺序**:
    当原则之间出现矛盾时，必须按照以下优先级进行权衡和决策：

    1.  **安全性 / 正确性 (最高)**: 系统的稳定运行、数据的准确无误是不可动摇的底线。任何设计都不得以牺牲正确性为代价。
    2.  **性能**: 对于本实时处理系统，性能是核心需求。在保证正确性的前提下，应优先选择能满足KPIs的方案。
    3.  **可维护性**: 方案应易于理解、修改和扩展，以降低长期拥有成本。只有在性能瓶颈确实存在且无法通过其他方式解决时，才可适度牺牲可维护性。
    4.  **开发速度 (最低)**: 快速实现固然重要，但不应以牺牲前三者为代价。

-----

## 6 术语表

  - **概要**: 本章旨在为文档中出现的**特定术语、缩写**提供一个集中的、**明确的定义**，以消除歧义，确保所有读者拥有一致的专业理解。
      - 链接到 [`术语表.md`](/docs/01_项目设计/11_参考资料/04_术语表.md) 以获取标准术语表格式。

-----

## 7 相关文档

  - **概要**: 本节列出与本设计原则文档密切相关的其他文档，便于读者查阅和深入理解。

     - [模块接口规范](../05_接口设计/01_模块接口规范.md)
     - [接口版本管理](../05_接口设计/05_接口版本管理.md)

-----

## 8 变更历史

| 版本   | 日期       | 作者  | 变更描述                                                                                                           |
| ------ | ---------- | ----- | ------------------------------------------------------------------------------------------------------------------ |
| v2.0.0 | 2025-10-13 | Klein | 大幅重构：重新组织章节结构，增加“核心实现原则”章节，细化各设计原则的实践要点，补充“原则优先级”决策框架，完善术语表 |
| v1.2.0 | 2025-09-23 | Klein | 基于实际模块设计反向修改：更新模块化设计原则、性能目标、错误处理策略、监控架构等，确保原则与实际设计实践完全一致   |
| v1.1.0 | 2025-09-22 | Klein | 更新：移除部分章节、合并实施与冲突处理章节；为文中示例代码添加 Doxygen 注释                                        |
| v1.0.0 | 2025-09-22 | Klein | 基于MVP设计文档和技术规范创建核心设计原则，包含完整的原则体系和实施指导                                            |
