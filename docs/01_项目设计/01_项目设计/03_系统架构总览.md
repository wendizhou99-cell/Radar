# 系统架构总览

**文档版本**: v1.1.0
**最后更新**: 2025-09-22
**负责人**: Kelin
**适用阶段**: MVP及向 V2.0 性能优化过渡阶段
**来源依据**: 基于《[MVP系统设计文档](../MVP系统设计文档.md)》第2章系统概述和第5章核心模块设计

---

## 1 文档职责

本文件提供雷达数据处理系统的详细架构视图，覆盖：
1) 系统整体架构和模块组织
2) 模块间依赖关系和交互模式
3) 数据流向和控制流程设计
4) 接口规范和通信协议
5) 部署架构和运行时组织
6) 架构质量属性和约束条件

已明确不在本文件范围内的内容：具体的技术实现细节、代码级别的接口定义、性能调优参数等（这些在各专项设计文档中维护）。

### 1.1 目录

- [系统架构总览](#系统架构总览)
  - [1 文档职责](#1-文档职责)
    - [1.1 目录](#11-目录)
  - [2 架构总体视图](#2-架构总体视图)
    - [2.1 系统上下文图](#21-系统上下文图)
    - [2.2 架构分层视图](#22-架构分层视图)
  - [3 模块架构设计](#3-模块架构设计)
    - [3.1 核心模块组织](#31-核心模块组织)
    - [3.2 模块职责矩阵](#32-模块职责矩阵)
    - [3.3 模块依赖关系](#33-模块依赖关系)
  - [4 数据流架构](#4-数据流架构)
    - [4.1 数据流总览](#41-数据流总览)
    - [4.2 数据处理管道](#42-数据处理管道)
    - [4.3 控制流设计](#43-控制流设计)
  - [5 接口架构设计](#5-接口架构设计)
    - [5.1 接口层次模型](#51-接口层次模型)
    - [5.2 通信协议架构](#52-通信协议架构)
  - [6 部署架构视图](#6-部署架构视图)
    - [6.1 物理部署架构](#61-物理部署架构)
    - [6.2 进程组织架构](#62-进程组织架构)
  - [7 质量属性架构](#7-质量属性架构)
  - [8 架构约束说明](#8-架构约束说明)
  - [9 相关文档](#9-相关文档)
  - [10 变更历史](#10-变更历史)

---

## 2 架构总体视图

### 2.1 系统上下文图

系统在整体环境中的位置和外部交互关系：

```mermaid
graph TB
    subgraph 外部环境
        RADAR_ARRAY[雷达阵面]
        OPERATOR[操作员]
        EXTERNAL_SYS[外部系统]
    end

    subgraph 系统边界
        RADAR_SYSTEM[雷达数据处理系统]
    end

    subgraph 基础设施
        CPU_HARDWARE[CPU硬件]
        GPU_HARDWARE[GPU硬件]
        NETWORK_INFRA[网络基础设施]
        STORAGE_SYS[存储系统]
    end

    %% 外部交互
    RADAR_ARRAY -.->|UDP数据包| RADAR_SYSTEM
    RADAR_SYSTEM -.->|控制命令| RADAR_ARRAY
    OPERATOR -.->|用户操作| RADAR_SYSTEM
    RADAR_SYSTEM -.->|状态显示| OPERATOR
    RADAR_SYSTEM -.->|处理结果| EXTERNAL_SYS

    %% 基础设施依赖
    RADAR_SYSTEM --> CPU_HARDWARE
    RADAR_SYSTEM --> GPU_HARDWARE
    RADAR_SYSTEM --> NETWORK_INFRA
    RADAR_SYSTEM --> STORAGE_SYS

    classDef external fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef infrastructure fill:#fff3e0,stroke:#ef6c00,stroke-width:2px

    class RADAR_ARRAY,OPERATOR,EXTERNAL_SYS external
    class RADAR_SYSTEM system
    class CPU_HARDWARE,GPU_HARDWARE,NETWORK_INFRA,STORAGE_SYS infrastructure
```

### 2.2 架构分层视图

系统内部的分层组织和层间关系：

```mermaid
flowchart TB
    subgraph 表示层
        direction LR
        UI_DISPLAY[数据显示组件]
        UI_CONTROL[用户控制组件]
        UI_STATUS[状态监控组件]
    end
    subgraph 应用层
        direction LR
        APP_COORD[应用协调器]
        APP_CONFIG[配置管理器]
        APP_WORKFLOW[工作流控制器]
    end
    subgraph 业务层
        direction LR
        BIZ_RECEIVE[数据接收模块]
        BIZ_SIGNAL[信号处理模块]
        BIZ_DATA[数据处理模块]
    end
    subgraph 服务层
        direction LR
        SVC_SCHEDULER[任务调度服务]
        SVC_THREAD[线程管理服务]
        SVC_RESOURCE[资源管理服务]
    end
    subgraph 基础设施层
        direction LR
        INFRA_LOG[日志服务]
        INFRA_MONITOR[监控服务]
        INFRA_QUEUE[队列服务]
        INFRA_GPU[GPU服务]
    end
    UI_DISPLAY --> APP_COORD
    UI_CONTROL --> APP_CONFIG
    UI_STATUS --> APP_WORKFLOW
    APP_COORD --> BIZ_RECEIVE
    APP_CONFIG --> BIZ_SIGNAL
    APP_WORKFLOW --> BIZ_DATA
    BIZ_RECEIVE --> SVC_SCHEDULER
    BIZ_SIGNAL --> SVC_THREAD
    BIZ_DATA --> SVC_RESOURCE
    SVC_SCHEDULER --> INFRA_LOG
    SVC_THREAD --> INFRA_MONITOR
    SVC_RESOURCE --> INFRA_QUEUE
    SVC_RESOURCE --> INFRA_GPU
    classDef presentation fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef application fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef business fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef service fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef infrastructure fill:#f8bbd9,stroke:#c2185b,stroke-width:2px
    class UI_DISPLAY,UI_CONTROL,UI_STATUS presentation
    class APP_COORD,APP_CONFIG,APP_WORKFLOW application
    class BIZ_RECEIVE,BIZ_SIGNAL,BIZ_DATA business
    class SVC_SCHEDULER,SVC_THREAD,SVC_RESOURCE service
    class INFRA_LOG,INFRA_MONITOR,INFRA_QUEUE,INFRA_GPU infrastructure
```

---

## 3 模块架构设计

### 3.1 核心模块组织

系统核心模块的组织结构和内部组件：

```mermaid
flowchart TB
    subgraph 数据接收模块
        DR_UDP[UDP接收器]
        DR_PARSER[数据解析]
        DR_VALIDATOR[数据验证]
        DR_BUFFER[缓冲管理]
    end
    subgraph 信号处理模块
        SP_SCHEDULER[信号调度]
        SP_ALGORITHM[算法执行]
        SP_GPU_MGR[GPU管理]
        SP_RESULT[结果汇集]
    end
    subgraph 数据处理模块
        DP_CFAR[CFAR检测]
        DP_TRACKER[航迹关联]
        DP_FILTER[数据滤波]
        DP_ANALYZER[统计分析]
    end
    subgraph 显示控制模块
        DC_RENDERER[图表渲染]
        DC_UI_MGR[界面管理]
        DC_INTERACTION[交互控制]
        DC_EXPORTER[数据导出]
    end
    subgraph 任务调度模块
        TS_LIFECYCLE[生命周期]
        TS_RESOURCE[资源分配]
        TS_PRIORITY[优先级]
        TS_MONITOR[状态监控]
    end
    classDef receiver fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef signal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef data fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef display fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef scheduler fill:#f8bbd9,stroke:#c2185b,stroke-width:2px
    class DR_UDP,DR_PARSER,DR_VALIDATOR,DR_BUFFER receiver
    class SP_SCHEDULER,SP_ALGORITHM,SP_GPU_MGR,SP_RESULT signal
    class DP_CFAR,DP_TRACKER,DP_FILTER,DP_ANALYZER data
    class DC_RENDERER,DC_UI_MGR,DC_INTERACTION,DC_EXPORTER display
    class TS_LIFECYCLE,TS_RESOURCE,TS_PRIORITY,TS_MONITOR scheduler
```

### 3.2 模块职责矩阵

| 模块             | 主要职责               | 输入数据          | 输出数据           | 依赖服务            |
| ---------------- | ---------------------- | ----------------- | ------------------ | ------------------- |
| **数据接收模块** | UDP数据接收和预处理    | 雷达UDP数据包     | 验证后的原始数据   | 网络服务、日志服务  |
| **信号处理模块** | GPU加速信号处理算法    | 原始雷达数据      | 信号处理结果       | GPU服务、线程池服务 |
| **数据处理模块** | CFAR检测和航迹关联     | 信号处理结果      | 目标检测结果       | 算法库、配置服务    |
| **显示控制模块** | 数据可视化和用户交互   | 处理结果数据      | 用户界面显示       | Qt服务、图形服务    |
| **任务调度器**   | 系统生命周期和资源管理 | 系统状态信息      | 调度决策和控制命令 | 监控服务、配置服务  |
| **配置管理模块** | 配置加载、校验、热更新 | 配置文件/更新请求 | 标准化配置对象     | 文件系统、日志服务  |

### 3.3 模块依赖关系

模块间的静态依赖和运行时交互关系：

```mermaid
graph LR
    subgraph "依赖关系图"
        DataReceiver[数据接收模块]
        SignalProcessor[信号处理模块]
        DataProcessor[数据处理模块]
        DisplayController[显示控制模块]
        TaskScheduler[任务调度器]

        %% 数据依赖（实线）
        DataReceiver -->|原始数据| SignalProcessor
        SignalProcessor -->|处理结果| DataProcessor
        DataProcessor -->|最终结果| DisplayController

        %% 控制依赖（虚线）
        TaskScheduler -.->|生命周期控制| DataReceiver
        TaskScheduler -.->|任务调度| SignalProcessor
        TaskScheduler -.->|资源分配| DataProcessor
        TaskScheduler -.->|状态通知| DisplayController

        %% 反馈依赖（点线）
        DisplayController -..->|用户命令| TaskScheduler
        DataProcessor -..->|处理状态| TaskScheduler
        SignalProcessor -..->|资源需求| TaskScheduler
        DataReceiver -..->|接收状态| TaskScheduler
    end

    classDef module fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef coordinator fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class DataReceiver,SignalProcessor,DataProcessor,DisplayController module
    class TaskScheduler coordinator
```

---

## 4 数据流架构

### 4.1 数据流总览

系统中数据的完整流动路径和处理阶段：

```mermaid
flowchart LR
    subgraph "数据流处理架构"
        direction LR

        subgraph "数据输入"
            RADAR_INPUT[雷达阵面数据<br/>UDP Packets]
        end

        subgraph "数据接收阶段"
            RECEIVE_STAGE[接收处理<br/>UDP → Raw Data]
            BUFFER_A[环形缓冲区A<br/>Raw Data Buffer]
        end

        subgraph "信号处理阶段"
            SIGNAL_STAGE[信号处理<br/>Raw Data → Signals]
            BUFFER_B[环形缓冲区B<br/>Signal Buffer]
        end

        subgraph "数据处理阶段"
            DATA_STAGE[数据处理<br/>Signals → Targets]
            RESULT_QUEUE[结果队列<br/>Target Queue]
        end

        subgraph "数据输出"
            DISPLAY_OUTPUT[用户界面<br/>Visualization]
        end

        %% 数据流向
        RADAR_INPUT --> RECEIVE_STAGE
        RECEIVE_STAGE --> BUFFER_A
        BUFFER_A --> SIGNAL_STAGE
        SIGNAL_STAGE --> BUFFER_B
        BUFFER_B --> DATA_STAGE
        DATA_STAGE --> RESULT_QUEUE
        RESULT_QUEUE --> DISPLAY_OUTPUT
    end

    classDef input fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef process fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef buffer fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef output fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class RADAR_INPUT input
    class RECEIVE_STAGE,SIGNAL_STAGE,DATA_STAGE process
    class BUFFER_A,BUFFER_B,RESULT_QUEUE buffer
    class DISPLAY_OUTPUT output
```

### 4.2 数据处理管道

详细的数据处理管道设计和阶段特征：

```mermaid
sequenceDiagram
    participant Radar as 雷达阵面
    participant Receiver as 数据接收器
    participant SignalProc as 信号处理器
    participant DataProc as 数据处理器
    participant Display as 显示控制器
    participant User as 用户界面

    Radar->>+Receiver: 1. 发送UDP数据包
    Receiver->>Receiver: 2. 解析与验证
    Receiver->>-SignalProc: 3. 推送环形缓冲A
    SignalProc->>+SignalProc: 4. GPU信号处理
    SignalProc->>-DataProc: 5. 推送环形缓冲B
    DataProc->>+DataProc: 6. 检测/关联
    DataProc->>-Display: 7. 推送结果队列
    Display->>+Display: 8. 渲染输出
    Display->>-User: 9. 界面更新
```

### 4.3 控制流设计

系统控制流和命令传递机制：

```mermaid
flowchart TB
    subgraph "控制流架构"
        direction TB

        subgraph "用户层"
            USER_CMD[用户命令<br/>User Commands]
        end

        subgraph "控制层"
            CMD_PARSER[命令解析器<br/>Command Parser]
            CMD_VALIDATOR[命令验证器<br/>Command Validator]
            CMD_DISPATCHER[命令分发器<br/>Command Dispatcher]
        end

        subgraph "执行层"
            MODULE_CTRL[模块控制器<br/>Module Controllers]
            RESOURCE_CTRL[资源控制器<br/>Resource Controllers]
            SYSTEM_CTRL[系统控制器<br/>System Controllers]
        end

        subgraph "反馈层"
            STATUS_COLLECTOR[状态收集器<br/>Status Collector]
            EVENT_AGGREGATOR[事件聚合器<br/>Event Aggregator]
            FEEDBACK_PROCESSOR[反馈处理器<br/>Feedback Processor]
        end

        %% 控制流向
        USER_CMD --> CMD_PARSER
        CMD_PARSER --> CMD_VALIDATOR
        CMD_VALIDATOR --> CMD_DISPATCHER

        CMD_DISPATCHER --> MODULE_CTRL
        CMD_DISPATCHER --> RESOURCE_CTRL
        CMD_DISPATCHER --> SYSTEM_CTRL

        MODULE_CTRL --> STATUS_COLLECTOR
        RESOURCE_CTRL --> EVENT_AGGREGATOR
        SYSTEM_CTRL --> FEEDBACK_PROCESSOR

        %% 反馈回路
        FEEDBACK_PROCESSOR -.->|状态反馈| USER_CMD
    end

    classDef user fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef control fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef execute fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef feedback fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class USER_CMD user
    class CMD_PARSER,CMD_VALIDATOR,CMD_DISPATCHER control
    class MODULE_CTRL,RESOURCE_CTRL,SYSTEM_CTRL execute
    class STATUS_COLLECTOR,EVENT_AGGREGATOR,FEEDBACK_PROCESSOR feedback
```

---

## 5 接口架构设计

### 5.1 接口层次模型

系统接口的分层组织和继承关系：

```mermaid
graph TB
    subgraph "接口层次架构"
        direction TB

        subgraph "基础接口层"
            IComponent[IComponent<br/>组件基础接口]
            ILifecycle[ILifecycle<br/>生命周期接口]
            IConfigurable[IConfigurable<br/>可配置接口]
        end

        subgraph "通用接口层"
            IModule[IModule<br/>模块接口]
            IDataSource[IDataSource<br/>数据源接口]
            IDataConsumer[IDataConsumer<br/>数据消费接口]
            ISchedulable[ISchedulable<br/>可调度接口]
        end

        subgraph "专用接口层"
            IDataReceiver[IDataReceiver<br/>数据接收接口]
            ISignalProcessor[ISignalProcessor<br/>信号处理接口]
            IDataProcessor[IDataProcessor<br/>数据处理接口]
            IDisplayController[IDisplayController<br/>显示控制接口]
        end

        subgraph "实现层"
            DataReceiverImpl[DataReceiver<br/>具体实现]
            SignalProcessorImpl[SignalProcessor<br/>具体实现]
            DataProcessorImpl[DataProcessor<br/>具体实现]
            DisplayControllerImpl[DisplayController<br/>具体实现]
        end

        %% 继承关系
        IComponent --> IModule
        ILifecycle --> IModule
        IConfigurable --> IModule

        IModule --> IDataReceiver
        IDataSource --> IDataReceiver
        ISchedulable --> IDataReceiver

        IModule --> ISignalProcessor
        IDataConsumer --> ISignalProcessor
        IDataSource --> ISignalProcessor

        IModule --> IDataProcessor
        IDataConsumer --> IDataProcessor
        IDataSource --> IDataProcessor

        IModule --> IDisplayController
        IDataConsumer --> IDisplayController

        %% 实现关系
        IDataReceiver --> DataReceiverImpl
        ISignalProcessor --> SignalProcessorImpl
        IDataProcessor --> DataProcessorImpl
        IDisplayController --> DisplayControllerImpl
    end

    classDef base fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef generic fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef specific fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef impl fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class IComponent,ILifecycle,IConfigurable base
    class IModule,IDataSource,IDataConsumer,ISchedulable generic
    class IDataReceiver,ISignalProcessor,IDataProcessor,IDisplayController specific
    class DataReceiverImpl,SignalProcessorImpl,DataProcessorImpl,DisplayControllerImpl impl
```

### 5.2 通信协议架构

模块间通信协议和消息传递机制：

```mermaid
graph LR
    %% 左右两栏总体布局
    subgraph "协议类别"
        direction TB
        CAT_SYNC[同步通信]
        CAT_ASYNC[异步通信]
        CAT_DATA[数据通信]
        CAT_CTRL[控制通信]
    end

    subgraph "实现示例"
        direction TB
        subgraph SYNC_ROW["同步实现"]
            direction LR
            SYNC_A[直接调用] --> SYNC_B[接口调用] --> SYNC_C[回调函数]
        end
        subgraph ASYNC_ROW["异步实现"]
            direction LR
            ASYNC_A[消息队列] --> ASYNC_B[事件总线] --> ASYNC_C[信号槽]
        end
        subgraph DATA_ROW["数据实现"]
            direction LR
            DATA_A[共享内存] --> DATA_B[环形缓冲区] --> DATA_C[无锁队列]
        end
        subgraph CTRL_ROW["控制实现"]
            direction LR
            CTRL_A[命令模式] --> CTRL_B[观察者模式] --> CTRL_C[状态机]
        end
    end

    %% 类别到实现的关联（纵向到横向）
    CAT_SYNC --> SYNC_A
    CAT_ASYNC --> ASYNC_A
    CAT_DATA --> DATA_A
    CAT_CTRL --> CTRL_A

    %% 配色定义
    classDef cat fill:#f5f5f5,stroke:#9e9e9e,stroke-width:1px
    classDef sync fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef async fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef data fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef control fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class CAT_SYNC,CAT_ASYNC,CAT_DATA,CAT_CTRL cat
    class SYNC_A,SYNC_B,SYNC_C sync
    class ASYNC_A,ASYNC_B,ASYNC_C async
    class DATA_A,DATA_B,DATA_C data
    class CTRL_A,CTRL_B,CTRL_C control
```

---

## 6 部署架构视图

### 6.1 物理部署架构

系统的物理部署和硬件组织：

```mermaid
graph TB
    subgraph "物理部署架构"
        direction TB

        subgraph "雷达前端"
            ANTENNA[天线阵面<br/>Antenna Array]
            RF_FRONTEND[射频前端<br/>RF Frontend]
            ADC[模数转换器<br/>ADC]
        end

        subgraph "数据传输"
            FIBER_NETWORK[光纤网络<br/>Fiber Network]
            NETWORK_SWITCH[网络交换机<br/>Network Switch]
        end

        subgraph "处理节点"
            CPU_SERVER[CPU服务器<br/>CPU Server]
            GPU_SERVER[GPU服务器<br/>GPU Server]
            STORAGE_SERVER[存储服务器<br/>Storage Server]
        end

        subgraph "显示控制"
            DISPLAY_SERVER[显示服务器<br/>Display Server]
            MONITOR_ARRAY[监视器阵列<br/>Monitor Array]
            CONTROL_CONSOLE[控制台<br/>Control Console]
        end

        %% 连接关系
        ANTENNA --> RF_FRONTEND
        RF_FRONTEND --> ADC
        ADC -->|高速数据| FIBER_NETWORK

        FIBER_NETWORK --> NETWORK_SWITCH
        NETWORK_SWITCH --> CPU_SERVER
        NETWORK_SWITCH --> GPU_SERVER

        CPU_SERVER -.->|控制| GPU_SERVER
        GPU_SERVER -.->|结果| STORAGE_SERVER

        STORAGE_SERVER --> DISPLAY_SERVER
        DISPLAY_SERVER --> MONITOR_ARRAY
        DISPLAY_SERVER --> CONTROL_CONSOLE
    end

    classDef frontend fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef network fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef processing fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef display fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class ANTENNA,RF_FRONTEND,ADC frontend
    class FIBER_NETWORK,NETWORK_SWITCH network
    class CPU_SERVER,GPU_SERVER,STORAGE_SERVER processing
    class DISPLAY_SERVER,MONITOR_ARRAY,CONTROL_CONSOLE display
```

### 6.2 进程组织架构

系统进程和线程的组织结构：

```mermaid
graph TB
    subgraph "进程组织架构"
        direction TB

        subgraph "主进程 (Main Process)"
            MAIN_THREAD[主线程<br/>Main Thread]
            UI_THREAD[UI线程<br/>UI Thread]
        end

        subgraph "数据处理进程 (Data Process)"
            RECEIVER_THREAD[接收线程<br/>Receiver Thread]
            SIGNAL_THREAD_POOL[信号处理线程池<br/>Signal Thread Pool]
            DATA_THREAD[数据处理线程<br/>Data Thread]
        end

        subgraph "GPU计算进程 (GPU Process)"
            GPU_CONTEXT[GPU上下文<br/>GPU Context]
            CUDA_STREAMS[CUDA流<br/>CUDA Streams]
            GPU_MEMORY_MGR[GPU内存管理<br/>GPU Memory Manager]
        end

        subgraph "监控进程 (Monitor Process)"
            MONITOR_THREAD[监控线程<br/>Monitor Thread]
            LOG_THREAD[日志线程<br/>Log Thread]
            HEALTH_CHECKER[健康检查器<br/>Health Checker]
        end

        %% 进程间通信
        MAIN_THREAD -.->|IPC| RECEIVER_THREAD
        UI_THREAD -.->|消息队列| DATA_THREAD
        SIGNAL_THREAD_POOL -.->|GPU调用| GPU_CONTEXT
        DATA_THREAD -.->|状态报告| MONITOR_THREAD

        %% 线程池内部
        SIGNAL_THREAD_POOL --> CUDA_STREAMS
        GPU_CONTEXT --> GPU_MEMORY_MGR
        MONITOR_THREAD --> LOG_THREAD
    end

    classDef main fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    classDef data fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef gpu fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    classDef monitor fill:#f8bbd9,stroke:#c2185b,stroke-width:2px

    class MAIN_THREAD,UI_THREAD main
    class RECEIVER_THREAD,SIGNAL_THREAD_POOL,DATA_THREAD data
    class GPU_CONTEXT,CUDA_STREAMS,GPU_MEMORY_MGR gpu
    class MONITOR_THREAD,LOG_THREAD,HEALTH_CHECKER monitor
```

---

## 7 质量属性架构

| 质量属性     | 架构策略              | 关键机制             |
| ------------ | --------------------- | -------------------- |
| **性能**     | 流水线并行 + GPU加速  | 无锁队列、零拷贝     |
| **可靠性**   | 模块隔离 + 错误恢复   | 异常处理、健康检查   |
| **可扩展性** | 插件化架构 + 接口抽象 | 工厂模式、依赖注入   |
| **可维护性** | 分层设计 + 职责分离   | 标准接口、配置外部化 |
| **可测试性** | 模块解耦 + 依赖注入   | Mock对象、接口隔离   |
| **安全性**   | 数据验证 + 权限控制   | 输入验证、访问控制   |

---

## 8 架构约束说明

**设计约束**：
- 必须支持实时数据处理，端到端延迟不超过10ms
- 必须充分利用GPU并行计算能力，GPU利用率>80%
- 必须采用模块化设计，支持独立开发和测试
- 必须支持跨平台部署（Linux/Windows）

**技术约束**：
- 编程语言限定为C++17和CUDA C++
- GUI框架限定为Qt 6.5+
- GPU计算平台限定为NVIDIA CUDA
- 构建系统限定为CMake 3.20+

**资源约束**：
- 系统内存使用率不超过80%
- CPU使用率不超过70%
- 网络带宽需求不超过10Gbps
- 存储空间需求不超过1TB

**运行环境约束**：
- 支持Ubuntu 22.04 LTS和Windows 10/11
- 需要NVIDIA GPU（计算能力6.0+）
- 需要CUDA Toolkit 12.8.1环境
- 需要网络连接支持UDP协议

---

## 9 相关文档

- [系统总体架构设计](00_总体架构设计.md)
- [技术选型与平台](02_技术选型与平台.md)
- [需求分析与MVP目标](01_需求分析与目标.md)
- [核心设计原则](04_核心设计原则.md)

---

## 10 变更历史

| 版本   | 日期       | 作者    | 变更描述                                                                                                                              |
| ------ | ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| v1.0.0 | 2025-09-22 | Copilot | 基于MVP设计文档创建系统架构总览，包含完整的架构视图和设计说明                                                                         |
| v1.1.0 | 2025-09-22 | Copilot | 增加CPU节点；移除层英文标签；垂直化模块布局；补充配置管理模块；去除延迟注释；通信协议改纵向；重构物理部署图；精简质量属性表；版本升级 |

---

*本系统架构总览为雷达数据处理系统的详细设计和实施提供架构指导，确保系统设计的一致性和完整性。*
