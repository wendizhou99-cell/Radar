# 06\_事件接口规范.md

**文档版本**: v1.1.0
**最后更新**: 2025-09-26
**负责人**: Klein

-----

## 1\. 文档职责

### 1.1. 文档目标

  - **概要**: 本文件旨在为雷达数据处理系统定义一套标准、统一且可扩展的事件接口规范。它是模块间进行异步、解耦通信的**消息契约**，确保所有模块都能以一致的方式发布和订阅系统事件。本文档是实现事件驱动架构和全链路可观测性的核心技术基石。

如果说`01_模块接口规范.md`定义了系统中各个模块的“器官”和“骨架”，那么本事件接口规范则定义了流淌于系统之内，负责传递信号、触发动作的“**神经网络**”。它的核心目标在于：

  * **标准化 (Standardization)**: 建立所有事件都必须继承的`BaseEvent`基类，提供统一的元数据结构（如`TraceID`, `Timestamp`），确保所有“神经信号”都遵循相同的格式。
  * **解耦合 (Decoupling)**: 将模块间的通信从紧耦合的直接方法调用，转变为松耦合的“发布-订阅”模式。模块只需关注自身产生的事件和关心的事件，无需了解其他模块的存在，从而实现真正的关注点分离。
  * **可观测性 (Observability)**: 通过在`BaseEvent`中强制嵌入`TraceID`，将分散在不同模块、不同线程中的异步操作串联成一个完整的、可追踪的业务流，为分布式调试和性能瓶颈分析提供关键线索。
  * **可扩展性 (Extensibility)**: 提供一个清晰的事件分类体系和设计指南，使得未来新增业务功能时，可以方便地通过定义新事件来扩展系统能力，而无需修改现有模块的接口。

### 1.2. 核心原则对齐

  - **概要**: 本文档的设计严格遵循`00_接口设计总览.md`中定义的核心原则，特别是**事件驱动架构**和**全链路可观测性**。所有事件的定义和使用都必须服务于并强化这些核心原则。

| 核心原则                                                | 在本规范中的具体体现                                                                                                                                                                                                                                                        |
| :------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **事件驱动架构**<br>*(Event-Driven Architecture)*       | 本文档是该原则的**核心实现蓝图**。定义的每一个事件、`BaseEvent`基类以及`IEventBus`接口，共同构成了系统事件驱动模型的基础。模块间的所有控制、通知和状态同步都必须通过本规范定义的事件进行。                                                                                  |
| **全链路可观测性**<br>*(End-to-End Observability)*      | **`TraceID`是一等公民**。`BaseEvent`结构体强制要求所有事件实例都必须携带一个`TraceID`。这一设计确保了任何一个控制流，无论它跨越多少模块、经过多少次异步派发，其完整的执行路径都是可被追踪和分析的。                                                                         |
| **数据与控制分离**<br>*(Data/Control Plane Separation)* | 本规范定义的所有事件都属于**控制面 (Control Plane)**。我们在此明确一个关键约束：**事件是轻量级的“信号”，而非重量级的“数据管道”**。事件负载应仅包含必要的标识符和状态信息，严禁用于传输大的数据块（如原始I/Q数据），后者必须通过`01_模块接口规范.md`中定义的数据面接口进行。 |

### 1.3. 目录

- [06\_事件接口规范.md](#06_事件接口规范md)
  - [1. 文档职责](#1-文档职责)
    - [1.1. 文档目标](#11-文档目标)
    - [1.2. 核心原则对齐](#12-核心原则对齐)
    - [1.3. 目录](#13-目录)
  - [2. 基础事件接口 (BaseEvent)](#2-基础事件接口-baseevent)
    - [2.1. 接口职责](#21-接口职责)
    - [2.2. C++ 结构体定义](#22-c-结构体定义)
    - [2.3. 事件总线接口 (`IEventBus`)](#23-事件总线接口-ieventbus)
  - [3. 事件分类体系](#3-事件分类体系)
    - [3.1. 系统生命周期事件 (System Lifecycle Events)](#31-系统生命周期事件-system-lifecycle-events)
      - [3.1.1. `SystemStateChangedEvent`](#311-systemstatechangedevent)
    - [3.2. 模块生命周期事件 (Module Lifecycle Events)](#32-模块生命周期事件-module-lifecycle-events)
      - [3.2.1. `ModuleStateChangedEvent`](#321-modulestatechangedevent)
    - [3.3. 配置管理事件 (Configuration Events)](#33-配置管理事件-configuration-events)
      - [3.3.1. `ConfigChangedEvent`](#331-configchangedevent)
    - [3.4. 故障与恢复事件 (Fault \& Recovery Events)](#34-故障与恢复事件-fault--recovery-events)
      - [3.4.1. `ModuleFailedEvent`](#341-modulefailedevent)
    - [3.5. 性能与监控事件 (Performance \& Monitoring Events)](#35-性能与监控事件-performance--monitoring-events)
      - [3.5.1. `MetricsUpdateEvent`](#351-metricsupdateevent)
      - [3.5.2. `AlertEvent`](#352-alertevent)
  - [4. 事件设计与使用指南](#4-事件设计与使用指南)
    - [4.1. 事件命名约定](#41-事件命名约定)
    - [4.2. 事件负载设计原则](#42-事件负载设计原则)
    - [4.3. 订阅者实现契约](#43-订阅者实现契约)
    - [4.4. 高级主题：事件风暴防护](#44-高级主题事件风暴防护)
    - [4.5. 未来扩展：事务性与批量发布](#45-未来扩展事务性与批量发布)
  - [5. 术语表](#5-术语表)
  - [6. 变更历史](#6-变更历史)

-----

## 2\. 基础事件接口 (BaseEvent)

  - **概要**: `BaseEvent`是系统中所有事件的基类，是事件驱动架构和全链路可观测性的基石。它通过强制所有事件携带通用元数据，为系统通信提供了一致的上下文环境。本章节同时定义了负责传递这些事件的`IEventBus`接口，共同构成了系统控制面的通信基础设施。

### 2.1. 接口职责

  - **概要**: `BaseEvent`的核心职责是为系统中的每一个事件提供一个标准化的“身份标识”。它确保无论事件内容如何，我们总能知道它是什么类型、何时发生、由谁发起，以及它属于哪个业务追踪链。

| 元数据字段         | 核心职责       | 在系统中的价值                                                                                                                          |
| :----------------- | :------------- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| **`EventType`**    | **身份识别**   | 为事件总线（`IEventBus`）提供路由依据，使得订阅者可以精确地过滤并接收其关心的事件类型。                                                 |
| **`Timestamp`**    | **时间溯源**   | 记录事件的精确发生时间，对于分析事件顺序、计算处理延迟和诊断时序问题至关重要。                                                          |
| **`SourceModule`** | **来源追溯**   | 明确事件的发布者，帮助开发者理解事件的业务上下文，并在出现问题时快速定位到源头模块。                                                    |
| **`TraceId`**      | **全链路追踪** | **(核心)** 将跨越多个模块和线程的异步操作串联成一个完整的逻辑链。这是在复杂分布式系统中进行调试、性能分析和根因定位的**唯一可靠手段**。 |

### 2.2. C++ 结构体定义

  - **概要**: `BaseEvent`是一个抽象基类，所有具体的事件都必须公有继承自它。它的构造函数被精心设计，以确保`TraceId`能够从当前线程的上下文中自动继承，如果当前上下文没有`TraceId`（例如在新请求的起点），则会自动生成一个新的根`TraceId`。

```cpp
#pragma once

#include "Trace.h"      // 引入TraceId和TraceContext的定义
#include "Timestamp.h"  // 引入高精度时间戳的定义
#include <string>
#include <memory>

/**
 * @brief 基础事件接口 (所有系统事件的基类)
 * @details 该结构体定义了系统中所有事件都必须携带的通用元数据，
 * 是实现事件驱动架构和全链路可观测性的核心契约。
 */
struct BaseEvent {
    /// @brief 事件发生的高精度时间戳。
    Timestamp timestamp;

    /// @brief 事件发布者的模块名称。
    std::string source_module;

    /**
     * @brief 全链路追踪ID (强制性)。
     * @details 此ID在事件构造时，会自动从当前线程的TraceContext中获取。
     * 如果当前线程没有TraceID（例如，是一个新流程的起点），
     * TraceContext将生成一个新的根ID。
     * 这确保了任何事件链都不会中断追踪。
     */
    TraceId trace_id;

    /**
     * @brief 构造函数，自动填充通用元数据。
     * @param source_module_name 发布此事件的模块名称。
     */
    explicit BaseEvent(std::string source_module_name)
        : timestamp(Timestamp::now()),
          source_module(std::move(source_module_name)),
          trace_id(TraceContext::getCurrentOrGenerate()) {}

    virtual ~BaseEvent() = default;

    /**
     * @brief 获取事件的唯一类型标识符。
     * @details 每个派生事件类都必须重写此方法，返回一个唯一的字符串常量。
     * 这是事件总线进行基于类型的路由和订阅的关键。
     * @return const char* 指向事件类型字符串的指针。
     */
    virtual const char* getEventType() const = 0;
};
```

> 设计抉择（`getEventType()` 返回 `const char*` 而非 `enum class` 或 `std::string`）：
> 1. 与 `std::string` 相比：避免动态分配与拷贝，降低发布-派发热路径开销。
> 2. 与 `enum class` 相比：无需集中预登记即可扩展新事件类型，保持插件/策略类的可插拔性。
> 3. 风险：字符串唯一性需人工保证。
> 4. 缓解：采用集中常量命名空间，消除“魔术字符串”与拼写风险（见下方示例）。
>
> 推荐集中常量：
```cpp
// 事件类型常量集中定义示例（可放置于 events/EventTypes.h）
#pragma once
namespace EventTypes {
    inline constexpr const char* SystemStateChanged  = "SystemStateChangedEvent";
    inline constexpr const char* ModuleStateChanged  = "ModuleStateChangedEvent";
    inline constexpr const char* ConfigChanged       = "ConfigChangedEvent";
    inline constexpr const char* ModuleFailed        = "ModuleFailedEvent";
    inline constexpr const char* MetricsUpdate       = "MetricsUpdateEvent";
    inline constexpr const char* Alert               = "AlertEvent";
    // 新增事件请在此扩展，避免散落的字面量
}
```

### 2.3. 事件总线接口 (`IEventBus`)

  - **概要**: `IEventBus`定义了系统事件总线的抽象接口。它是所有模块与事件系统交互的唯一入口。其实现必须是线程安全的，并保证事件的异步派发，以避免阻塞发布者。

```cpp
#pragma once

#include "BaseEvent.h"
#include "ErrorCode.h"
#include <functional>
#include <memory>

// 为订阅句柄定义一个类型别名，以便未来扩展
using SubscriptionHandle = uint64_t;

/**
 * @brief 事件总线的核心接口。
 * @details 负责事件的发布和订阅，是模块间异步通信的中枢。
 * 其实现必须是线程安全的。
 */
class IEventBus {
public:
    virtual ~IEventBus() = default;

    /**
     * @brief 异步发布一个事件。
     * @details 此方法必须是非阻塞的。它应将事件放入内部队列后立即返回，
     * 由事件总线的内部工作线程负责派发给订阅者。
     * @param event 指向要发布的事件的共享指针。
     */
    virtual void publish(std::shared_ptr<BaseEvent> event) = 0;

    /**
     * @brief 订阅特定类型的事件。
     * @details 这是一个类型安全的订阅方法。
     * @tparam EventType 要订阅的具体事件类型，必须是BaseEvent的派生类。
     * @param handler 当订阅的事件发生时将被调用的回调函数。
     * 注意：此回调将在事件总线的工作线程中执行，
     * 因此其实现必须是线程安全的且非阻塞的。
     * @return SubscriptionHandle 一个唯一的订阅句柄，可用于取消订阅。
     */
    template<typename EventType>
    SubscriptionHandle subscribe(std::function<void(const EventType&)> handler);

    /**
     * @brief 取消一个事件订阅。
     * @param handle subscribe方法返回的订阅句柄。
     * @return ErrorCode 操作结果。
     */
    virtual ErrorCode unsubscribe(SubscriptionHandle handle) = 0;
};
```

> **实现契约**: `IEventBus` 的实现者（例如 `EventBus` 类）**必须**保证：
>
> 1. `publish()` 调用**非阻塞**。
> 2. 回调在独立**工作线程**执行，而非调用线程。
> 3. 派发前恢复事件的 `trace_id` 到该工作线程的 `TraceContext`。
> 4. **派发顺序**：对同一事件的多个订阅者之间的调用顺序**不做保证**；订阅者不得依赖或推断其他订阅者的执行次序。
> 5. **异常隔离**：任一订阅者回调抛出的异常必须被事件总线捕获并记录日志；不得影响其他订阅者对同一事件的处理，也不得中断后续事件派发。
>
> 说明：上述第4,5条用于防止“隐式顺序依赖”与“异常扩散”导致的系统性脆弱性。

-----

## 3\. 事件分类体系

  - **概要**: 为了有序地管理系统中的各种通信，本章节将所有事件划分为清晰的类别。每个类别对应系统的一个核心切面（如生命周期、配置、故障等）。开发者可以根据类别快速找到自己需要发布或订阅的事件，这种分类方法是构建可理解、可维护的事件驱动系统的基础。

### 3.1. 系统生命周期事件 (System Lifecycle Events)

  - **概要**: 这类事件由`TaskScheduler`发布，用于广播整个系统的宏观状态变化。模块可以订阅这些事件来执行与系统状态相关的协调动作，例如在系统准备就绪时进行最终初始化，或在系统关闭时执行数据清理。

#### 3.1.1. `SystemStateChangedEvent`

  - **发布者**: `TaskScheduler`
  - **核心订阅者**: `DisplayController`, `MonitoringModule`, 各业务模块
  - **职责**: 广播系统级别的整体状态变更。

```cpp
#pragma once

#include "BaseEvent.h"
#include "SystemState.h" // 假设定义了系统状态的枚举

/**
 * @brief 当整个系统的宏观状态发生变化时发布。
 * @details 例如，当所有模块都成功启动后，TaskScheduler会将系统状态
 * 从 STARTING 切换到 RUNNING，并发布此事件。
 */
struct SystemStateChangedEvent : public BaseEvent {
    SystemState old_state; ///< 系统之前的状态。
    SystemState new_state; ///< 系统当前的新状态。
    std::string reason;    ///< 状态变更的原因（例如 "所有模块已启动"）。

    /**
     * @brief 构造函数。
     * @param source_module 通常是 "TaskScheduler"。
     * @param old_s 旧状态。
     * @param new_s 新状态。
     * @param r 原因。
     */
    SystemStateChangedEvent(const std::string& source_module, SystemState old_s, SystemState new_s, std::string r)
        : BaseEvent(source_module), old_state(old_s), new_state(new_s), reason(std::move(r)) {}

    const char* getEventType() const override {
        return "SystemStateChangedEvent";
    }
};
```

-----

### 3.2. 模块生命周期事件 (Module Lifecycle Events)

  - **概要**: 这类事件同样主要由`TaskScheduler`发布，但关注点是**单个模块**的生命周期状态。这为需要了解其他特定模块状态的场景提供了更精细的通信机制，是实现模块间依赖启动和协调的基础。

#### 3.2.1. `ModuleStateChangedEvent`

  - **发布者**: `TaskScheduler`
  - **核心订阅者**: 依赖于其他模块的业务模块
  - **职责**: 通知一个特定模块的生命周期状态发生了改变。

```cpp
#pragma once

#include "BaseEvent.h"
#include "ModuleState.h" // 从 01_模块接口规范.md 引入

/**
 * @brief 当单个模块的生命周期状态发生变化时发布。
 * @details 例如，一个模块可以等待其上游数据提供模块进入 RUNNING 状态后，
 * 才开始自己的数据处理逻辑。
 */
struct ModuleStateChangedEvent : public BaseEvent {
    std::string module_name; ///< 状态发生变化的模块名称。
    ModuleState old_state;   ///< 模块之前的状态。
    ModuleState new_state;   ///< 模块当前的新状态。

    ModuleStateChangedEvent(const std::string& source_module, std::string name, ModuleState old_s, ModuleState new_s)
        : BaseEvent(source_module), module_name(std::move(name)), old_state(old_s), new_state(new_s) {}

    const char* getEventType() const override {
        return "ModuleStateChangedEvent";
    }
};
```

-----

### 3.3. 配置管理事件 (Configuration Events)

  - **概要**: 这类事件由`ConfigManager`发布，是实现**配置热更新**的核心机制。通过订阅这些事件，模块可以在运行时动态地调整其行为，而无需重启。

#### 3.3.1. `ConfigChangedEvent`

  - **发布者**: `ConfigManager`
  - **核心订阅者**: 所有需要支持配置热更新的模块
  - **职责**: 当一个或多个配置项的值在经过验证并成功应用后，发布此事件进行全系统广播。

```cpp
#pragma once

#include "BaseEvent.h"
#include <yaml-cpp/yaml.h> // 用于承载配置值

/**
 * @brief 当配置项的值发生变更时发布。
 * @details 模块应订阅此事件，并检查变更的key是否与自身相关，
 * 如果相关，则安全地更新内部的配置参数。
 */
struct ConfigChangedEvent : public BaseEvent {
    std::string key;         ///< 发生变更的配置项键名（例如 "signal_processor.fft.size"）。
    YAML::Node old_value;    ///< 配置项的旧值。
    YAML::Node new_value;    ///< 配置项的新值。

    ConfigChangedEvent(const std::string& source_module, std::string k, const YAML::Node& old_v, const YAML::Node& new_v)
        : BaseEvent(source_module), key(std::move(k)), old_value(old_v), new_value(new_v) {}

    const char* getEventType() const override {
        return "ConfigChangedEvent";
    }
};
```

> 设计决策说明：此处直接携带 `YAML::Node` 以减少解析/复制开销并保留结构信息；代价是所有订阅者需包含 `yaml-cpp` 依赖。未来若需进一步解耦，可演进为：
> - 传递序列化后的 `std::string`（YAML/JSON），由订阅者自行解析；
> - 使用 `std::variant<int64_t,double,std::string,bool>` 等精简类型；
> - 引入轻量型中间抽象（如 `ConfigValueView`）。
> 在当前阶段，优先保障实现简洁与快速迭代。

-----

### 3.4. 故障与恢复事件 (Fault & Recovery Events)

  - **概要**: 这类事件是系统容错和自愈能力的**通信命脉**。当模块自身无法处理某个错误时，通过发布故障事件将问题上报给`TaskScheduler`进行集中的、基于策略的决策。

#### 3.4.1. `ModuleFailedEvent`

  - **发布者**: 任何遇到致命错误的业务模块
  - **核心订阅者**: `TaskScheduler`
  - **职责**: 当一个模块遇到无法自我恢复的致命错误并进入`FAILED`状态时，**必须**发布此事件，将故障的上下文信息上报。

```cpp
#pragma once

#include "BaseEvent.h"
#include "ErrorCode.h" // 引入项目统一的错误码

/**
 * @brief 在模块遇到不可恢复的错误时发布。
 * @details 这是触发系统故障恢复机制的关键信号。TaskScheduler在收到此事件后，
 * 会根据预设的恢复策略（如重启模块、优雅降级等）进行处理。
 */
struct ModuleFailedEvent : public BaseEvent {
    ErrorCode error_code;       ///< 导致失败的精确错误码。
    std::string error_message;  ///< 详细的错误描述信息。
    // 未来可扩展：可在此加入更多上下文，如堆栈跟踪、资源快照等。

    ModuleFailedEvent(const std::string& source_module, ErrorCode code, std::string msg)
        : BaseEvent(source_module), error_code(code), error_message(std::move(msg)) {}

    const char* getEventType() const override {
        return "ModuleFailedEvent";
    }
};
```

-----

### 3.5. 性能与监控事件 (Performance & Monitoring Events)

  - **概要**: 这类事件用于解耦的系统性能监控和告警，实现了数据的“推送”模型。各个模块主动上报其状态，而监控模块则被动地聚合和分析，避免了监控模块对业务模块的侵入式查询。

#### 3.5.1. `MetricsUpdateEvent`

  - **发布者**: 所有需要被监控的业务模块
  - **核心订阅者**: `MonitoringModule`
  - **职责**: 模块定期（例如每秒）发布此事件，携带其最新的关键性能指标。

```cpp
#pragma once

#include "BaseEvent.h"
#include <map>
#include <string>
#include <variant>

/**
 * @brief 模块定期发布自身的性能指标。
 * @details MonitoringModule 订阅此事件来构建全系统的性能视图。
 */
struct MetricsUpdateEvent : public BaseEvent {
    using MetricVariant = std::variant<int64_t, double, std::string>;

    /// @brief 一个包含多个指标键值对的映射。
    /// @details key: 指标名称 (e.g., "queue_depth", "throughput_mbps")
    /// @details value: 指标值
    std::map<std::string, MetricVariant> metrics;

    explicit MetricsUpdateEvent(const std::string& source_module) : BaseEvent(source_module) {}

    const char* getEventType() const override {
        return "MetricsUpdateEvent";
    }
};
```

#### 3.5.2. `AlertEvent`

  - **发布者**: `MonitoringModule`
  - **核心订阅者**: `DisplayController`, `LoggingService`
  - **职责**: 当`MonitoringModule`分析`MetricsUpdateEvent`并检测到某个指标超出预设阈值时，发布此告警事件。

```cpp
#pragma once

#include "BaseEvent.h"
#include <string>

/**
 * @brief 当系统发生需要关注的告警时发布。
 * @details DisplayController 可以订阅此事件以在UI上向用户显示告警信息。
 */
struct AlertEvent : public BaseEvent {
    enum class AlertLevel {
        INFO,
        WARNING,
        CRITICAL
    };

    AlertLevel level;          ///< 告警的严重级别。
    std::string alert_name;    ///< 告警的名称（例如 "CPU_OVERLOAD"）。
    std::string description;   ///< 对告警的详细描述。

    AlertEvent(const std::string& source_module, AlertLevel lvl, std::string name, std::string desc)
        : BaseEvent(source_module), level(lvl), alert_name(std::move(name)), description(std::move(desc)) {}

    const char* getEventType() const override {
        return "AlertEvent";
    }
};
```

-----

## 4\. 事件设计与使用指南

  - **概要**: 本章节为开发者提供在系统中创建和使用事件的最佳实践。遵循这些指南是确保事件系统保持清晰、高效和可维护的关键。

### 4.1. 事件命名约定

  - **概要**: 规定所有事件类名必须以`Event`结尾，并采用清晰的“主语-谓语”格式（如`ModuleStateChangedEvent`），以增强代码可读性。

| 规则              | 示例 (推荐)                    | 示例 (不推荐)                   | 理由                                                       |
| :---------------- | :----------------------------- | :------------------------------ | :--------------------------------------------------------- |
| **后缀为`Event`** | `ConfigChangedEvent`           | `ConfigChange`, `Configuration` | 清晰地表明该结构体是一个事件类型。                         |
| **主语-谓语格式** | `ModuleFailedEvent`            | `FailureEvent`, `ModuleError`   | 明确了事件的主体（Module）和发生的动作（Failed），无歧义。 |
| **时态为过去时**  | `DataReadyEvent` (数据已就绪)  | `DataIsReadyEvent`              | 事件描述的是已经发生的事情，使用过去时态更符合其本质。     |
| **清晰具体**      | `SystemShutdownInitiatedEvent` | `StopEvent`                     | 名称应足够具体，以避免与其他事件混淆。                     |

> 补充：为防止“魔术字符串”，所有事件类型应使用集中常量（参考 2.2 节 `EventTypes` 命名空间）。新增事件流程：
> 1. 定义事件结构。
> 2. 将类型字面量加入 `EventTypes`。
> 3. `getEventType()` 返回对应常量。

### 4.2. 事件负载设计原则

  - **概要**: 强调事件应是轻量级的“通知”，而非重量级的“数据传输工具”。负载应只包含必要的上下文信息，避免携带大的数据块。大数据应通过数据面接口传递。

**核心原则**:

1.  **保持轻量 (Keep it Lightweight)**: 事件应尽可能小。只包含用于标识和提供上下文的必要信息，如ID、状态、时间戳等。

      * **正例**: `ModuleFailedEvent`只包含错误码和消息，而非模块的完整内存转储。
      * **反例**: 在事件中直接嵌入一个大的`std::vector<DetectionResult>`。

2.  **传递标识符，而非实体 (Pass IDs, not Objects)**: 如果事件需要关联到大的数据对象，应在负载中传递该对象的唯一标识符（如`track_id`），而不是对象本身。订阅者可以根据ID从相应的数据管理器中查询完整的对象。

3.  **数据不可变性 (Immutability)**: 事件一旦发布，其内容就不应被修改。在C++中，可以通过将负载成员声明为`const`或在订阅者回调中使用`const&`引用来实现。

4.  **避免业务逻辑 (No Business Logic)**: 事件结构体应是纯粹的数据容器（Plain Old Data），不应包含任何业务逻辑方法。

### 4.3. 订阅者实现契约

  - **概要**: 定义事件处理器（订阅者）必须遵守的规则，最重要的是：**事件处理器必须是非阻塞的，且必须是线程安全的**。任何耗时操作都应派发到模块自己的工作线程中，以避免阻塞`EventBus`的派发线程，从而影响整个系统的事件处理能力。

**强制性契约**:

1.  **非阻塞执行 (Non-Blocking)**: 事件处理回调函数**严禁**执行任何可能阻塞的操作，包括但不限于：

      * 同步文件I/O或网络I/O。
      * 长时间的计算密集型任务。
      * 获取可能产生争抢的锁并长时间持有。
      * 等待其他事件。

2.  **线程安全 (Thread-Safe)**: 事件处理回调函数将在`IEventBus`的内部工作线程中被调用。因此，回调函数访问的任何模块成员变量都**必须**通过互斥锁、原子操作或其他同步机制来保护。

3.  **快速完成 (Complete Quickly)**: 回调的执行时间应尽可能短，通常应在微秒（μs）级别完成。

4.  **任务派发 (Dispatching Heavy Work)**: 如果收到事件后需要执行耗时操作，正确的模式是：

      * 在回调函数中，解析事件，获取必要数据。
      * 将这些数据打包成一个任务。
      * 将该任务提交到模块自身的内部线程池或工作队列中。
      * 回调函数立即返回。

**正确实现的示例**:

```cpp
// 在 DataProcessor 模块中
void DataProcessor::onConfigChanged(const ConfigChangedEvent& event) {
    // 1. (快速) 检查是否是自己关心的配置
    if (event.key != "data_processor.algorithm.threshold") {
        return; // 立即返回
    }

    // 2. (快速) 解析新值
    auto new_threshold = event.new_value.as<double>();

    // 3. (派发) 将耗时的重新初始化任务提交到自己的线程池
    //    这里的 lambda 捕获了必要的数据
    my_thread_pool->submit([this, new_threshold, trace_id = event.trace_id]() {
        // 确保在工作线程中恢复追踪上下文
        TraceContextGuard guard(trace_id);

        // 在这里执行可能耗时的操作
        reinitializeAlgorithm(new_threshold);
    });

    // 4. (快速) 回调函数立即返回，不等待 reinitializeAlgorithm 完成
}
```

### 4.4. 高级主题：事件风暴防护
- 场景：模块频繁抖动（启动/失败循环）、瞬间大量指标上报、链式故障引起级联事件。
- 风险：监控/告警模块被淹没、日志爆量、下游二次放大（AlertEvent 风暴）。
- 建议策略：
  1. 去抖 (Debounce)：对同一 key（如 module_name+state）在窗口内仅处理最后一次。
  2. 节流 (Throttle / Rate Limit)：限制单位时间内同类型事件处理/转发次数（例如滑动窗口计数）。
  3. 合并 (Coalesce)：将高频同类事件聚合为单个聚合事件（可新增自定义 Aggregated*Event）。
  4. 指标采样 (Sampling)：对高频 MetricsUpdateEvent 采用 1/N 采样或分层采样。
  5. 熔断 (Circuit Break)：检测到异常突增后，临时抑制或降级处理（同时发布一条高等级 AlertEvent 说明被抑制的数量）。
- 实现提示（伪代码）：
```cpp
if (rateLimiter.shouldDrop(event.getEventType())) {
    dropped_counter++;
    return;
}
dispatch(event);
```
- 监控：建议对 “原始接收数 / 实际处理数” 做比率指标上报以评估策略效果。

### 4.5. 未来扩展：事务性与批量发布
- 当前设计：`publish()` 为单事件粒度，不支持“多事件原子性”或“同线程顺序强制”事务。
- 设计理由：保持核心总线最小可行 & 简化锁/排队模型；避免引入跨事件回滚复杂度。
- 当出现需要“多事件表达同一业务动作”的场景，推荐：
  1. 定义聚合事件（AggregateEvent）封装全部必要上下文，订阅端一次性解析。
  2. 或使用单事件 + 追踪ID + 业务内关联ID，让订阅者自行关联（最终一致性）。
- 若未来确需事务特性，可考虑引入：
  - 批量接口：`publishBatch(span<shared_ptr<BaseEvent>>)`
  - 事务句柄：`beginTransaction() -> tx_id`, `commit(tx_id)`，在同一工作队列顺序派发。
- 结论：当前阶段不实现，保持文档可扩展性提示，避免误用多事件模拟“伪事务”导致的竞态。

-----

## 5\. 术语表

| 术语                     | 英文全称 | 定义                                                                                             |
| :----------------------- | :------- | :----------------------------------------------------------------------------------------------- |
| **事件 (Event)**         | -        | 一个表示系统中发生了某个重要事情的、不可变的数据记录。它是模块间异步通信的基础。                 |
| **事件总线 (Event Bus)** | -        | 负责接收事件并将其派发给所有已注册订阅者的核心组件。                                             |
| **发布者 (Publisher)**   | -        | 创建并向事件总线发送事件的模块或组件。                                                           |
| **订阅者 (Subscriber)**  | -        | 向事件总线注册，以接收特定类型事件的模块或组件。                                                 |
| **事件处理器 (Handler)** | -        | 订阅者内部用于处理接收到的事件的回调函数。                                                       |
| **事件负载 (Payload)**   | -        | 事件结构体中携带的具体业务数据。                                                                 |
| **异步 (Asynchronous)**  | -        | 指操作的发起和完成不在同一时间点，调用者无需等待操作完成即可继续执行。事件通信是典型的异步模式。 |

-----

## 6\. 变更历史

| 版本号 | 日期       | 作者    | 变更描述                                                                                                      |
| :----- | :--------- | :------ | :------------------------------------------------------------------------------------------------------------ |
| v1.1.0 | 2025-09-26 | Copilot | 增补事件类型常量规范、派发顺序与异常隔离契约、事件风暴防护、事务性扩展展望、ConfigChangedEvent 设计决策说明。 |
| v1.0.0 | 2025-09-26 | Klein   | 初始版本创建，定义 `BaseEvent`、事件分类体系及使用指南。                                                      |
