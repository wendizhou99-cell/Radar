# 02_外部接口设计.md

**文档版本**: v1.1.0
**最后更新**: 2025-09-28
**负责人**: Klein

---
## 1\. 文档职责

### 1.1. 文档目标

  - **概要**: 本文件旨在为雷达数据处理系统定义一套标准、统一且安全的**外部应用程序接口 (API)**。它作为外部客户端（如用户界面、第三方集成系统、运维脚本）与本系统交互的**唯一官方契约**。本文档详细规定了API的架构风格、设计原则、安全机制以及所有可用的端点 (Endpoints)。

本文件的核心目标是构建一座连接系统内部复杂世界与外部使用者之间的“**桥梁**”。这座桥梁必须是：

  * **稳定可靠 (Stable & Reliable)**: 为UI和第三方开发者提供一个长期稳定的接口契约，避免因内部实现重构而导致外部集成的频繁中断。
  * **安全可控 (Secure & Controlled)**: 确保所有外部访问都经过认证和授权，保护系统核心数据和功能不被未授权访问。
  * **清晰易用 (Clear & Usable)**: 提供一致、可预测且有良好文档的接口，极大地降低外部开发者的集成成本和学习曲线。
  * **关注点分离 (Separation of Concerns)**: 将外部通信的复杂性（如HTTP协议处理、认证、请求验证）与内部核心业务逻辑完全隔离。

### 1.2. 核心原则对齐

  - **概要**: 本文档的设计严格遵循`00_接口设计总览.md`中定义的核心原则。外部接口模块（`ExternalApiGateway`）将扮演“**适配器 (Adapter)**”和“**翻译官 (Translator)**”的角色，将外部世界的同步、请求-响应式通信模型，优雅地转换为系统内部的异步、事件驱动模型。

| 核心原则                                                | 在本规范中的具体体现                                                                                                                                                                                                                                                                                              |
| :------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **事件驱动架构**<br>*(Event-Driven Architecture)*       | **将外部命令转换为内部事件**。所有会改变系统状态的API请求（如`POST /system/control`），在经过网关层的验证和解析后，都**必须**被转换为一个对应的内部事件（如`StartSystemCommandEvent`），并发布到`EventBus`。系统的核心业务模块只关心事件，完全不知道该命令最初来源于一个HTTP请求。                                |
| **全链路可观测性**<br>*(End-to-End Observability)*      | **`TraceID`的生命周期始于网关**。每个进入系统的API请求，**必须**在网关层为其生成一个唯一的`TraceID`。此`TraceID`不仅需要在API响应头中返回给客户端（如`X-Trace-ID`），还**必须**注入到后续由此请求触发的所有内部事件和数据包中，从而将一次外部调用与其在系统内部引发的所有连锁反应串联起来，实现真正的端到端追踪。 |
| **数据与控制分离**<br>*(Data/Control Plane Separation)* | **API端点严格区分数据与控制**。本规范明确划分了**系统管理接口（第3章）和数据服务接口（第4章）**。前者用于控制系统行为（控制面），后者用于查询处理结果（数据面），职责清晰。                                                                                                                                       |
| **接口隔离原则**<br>*(Interface Segregation Principle)* | **外部接口是粗粒度的，内部接口是细粒度的**。外部API（如`GET /system/status`）可能需要从内部多个模块（如`TaskScheduler`, `MonitoringModule`）收集信息。网关层负责调用这些内部细粒度接口并聚合结果，对外只暴露一个单一、统一的粗粒度接口，向外部客户端隐藏了内部的复杂性。                                          |

### 1.3 目录

- [02\_外部接口设计.md](#02_外部接口设计md)
  - [1. 文档职责](#1-文档职责)
    - [1.1. 文档目标](#11-文档目标)
    - [1.2. 核心原则对齐](#12-核心原则对齐)
    - [1.3 目录](#13-目录)
  - [2. RESTful API 设计原则](#2-restful-api-设计原则)
    - [2.1. URL 结构与版本管理](#21-url-结构与版本管理)
    - [2.2. HTTP 方法使用规范](#22-http-方法使用规范)
    - [2.3. 认证与授权 (Authentication \& Authorization)](#23-认证与授权-authentication--authorization)
    - [2.4. 统一响应格式](#24-统一响应格式)
    - [2.5. 错误处理与HTTP状态码](#25-错误处理与http状态码)
  - [3. 系统管理接口 (System Management API)](#3-系统管理接口-system-management-api)
    - [3.1. 获取系统状态 - `GET /api/v1/system/status`](#31-获取系统状态---get-apiv1systemstatus)
    - [3.2. 控制系统状态 - `POST /api/v1/system/control`](#32-控制系统状态---post-apiv1systemcontrol)
    - [3.3. 获取系统配置 - `GET /api/v1/system/config`](#33-获取系统配置---get-apiv1systemconfig)
    - [3.4. 获取系统告警 - `GET /api/v1/system/alerts`](#34-获取系统告警---get-apiv1systemalerts)
  - [4. 数据服务接口 (Data Services API)](#4-数据服务接口-data-services-api)
    - [4.1. 获取航迹列表 - `GET /api/v1/tracks`](#41-获取航迹列表---get-apiv1tracks)
    - [4.2. 获取单个航迹详情 - `GET /api/v1/tracks/{trackId}`](#42-获取单个航迹详情---get-apiv1trackstrackid)
    - [4.3. 获取实时性能指标 - `GET /api/v1/metrics`](#43-获取实时性能指标---get-apiv1metrics)
  - [5. (未来) 实时数据接口 (Real-time Data API)](#5-未来-实时数据接口-real-time-data-api)
    - [5.1. 航迹实时推送 - `WS /api/v1/ws/tracks`](#51-航迹实时推送---ws-apiv1wstracks)
  - [6. 术语表](#6-术语表)
  - [7. 变更历史](#7-变更历史)

---
## 2\. RESTful API 设计原则

  - **概要**: 为保证API的一致性、可预测性和易用性，所有外部接口**必须**遵循以下RESTful设计原则。这些原则是构建高质量、专业级API的行业标准。

### 2.1. URL 结构与版本管理

  - **概要**: API的URL结构应清晰、直观，并包含版本号以确保向后兼容性。所有端点都必须以统一的前缀`/api/v1`开始，其中`v1`代表API的主版本号。

**规范**:

  * **统一前缀**: 所有API端点必须以`/api/v1`作为路径前缀。
  * **资源用名词**: URL中应使用**复数名词**来表示资源集合。
      * **正例**: `/api/v1/tracks`, `/api/v1/alerts`
      * **反例**: `/api/v1/getAllTracks`, `/api/v1/createAlert`
  * **层级关系**: 使用`/`来表示资源的层级关系。
      * **正例**: `/api/v1/tracks/{trackId}/history` (获取指定航迹的历史点)
  * **参数化**: 使用`{}`来表示路径参数。
      * **正例**: `/api/v1/tracks/{trackId}`

### 2.2. HTTP 方法使用规范

  - **概要**: 严格按照HTTP动词的语义来定义操作，实现资源与动作的清晰分离。

| HTTP 方法    | 操作                         | 示例                                                                           | 是否幂等 (Idempotent) |
| :----------- | :--------------------------- | :----------------------------------------------------------------------------- | :-------------------- |
| **`GET`**    | **读取**资源                 | `GET /api/v1/tracks/{trackId}`                                                 | 是                    |
| **`POST`**   | **创建**新资源或**触发动作** | `POST /api/v1/tracks` (创建新航迹)<br>`POST /api/v1/system/control` (触发动作) | 否                    |
| **`PUT`**    | **完整替换**一个现有资源     | `PUT /api/v1/config/signal_processor`                                          | 是                    |
| **`PATCH`**  | **部分更新**一个现有资源     | `PATCH /api/v1/tracks/{trackId}`                                               | 否                    |
| **`DELETE`** | **删除**一个现有资源         | `DELETE /api/v1/tracks/{trackId}`                                              | 是                    |

> **幂等性 (Idempotency)**: 指的是一次和多次请求某一个资源应该具有同样的副作用。简单来说，就是“做一次”和“做N次”的效果是一样的。这对于构建可靠的客户端重试逻辑至关重要。

### 2.3. 认证与授权 (Authentication & Authorization)

  - **概要**: 所有对API的访问都必须经过认证和授权检查，以保障系统安全。MVP阶段采用基于API密钥（API Key）的简单认证方案。

**认证流程**:

1.  客户端在请求的HTTP头中包含`Authorization`字段。
2.  认证方案采用`Bearer`类型。
3.  API网关层负责解析并验证此密钥的有效性。
4.  无效或缺失密钥的请求将被拒绝，并返回`401 Unauthorized`状态码。

**请求头示例**:

```http
Authorization: Bearer your_secret_api_key_here
```

> **未来规划**: 随着系统功能的扩展，将引入基于角色的访问控制（RBAC），为不同的API密钥分配不同的权限（如“只读”、“管理员”），以实现更精细化的安全管理。

### 2.4. 统一响应格式

  - **概要**: 为简化客户端处理逻辑，所有API的响应体**必须**遵循统一的JSON包装格式。这使得客户端可以用一致的方式处理成功和失败的响应。

**成功响应 (`2xx`状态码) 格式**:

```json
{
  "success": true,
  "traceId": "trace-a1b2c3d4-xyz789",
  "data": {
    // ... 实际的业务数据放在这里 ...
  }
}
```

**失败响应 (`4xx`或`5xx`状态码) 格式**:

```json
{
  "success": false,
  "traceId": "trace-e5f6g7h8-uvw456",
  "error": {
    "code": "VALIDATION_ERROR", // 业务错误码
    "message": "Invalid track ID format. Expected an integer.", // 供开发者阅读的错误信息
    "details": [ // (可选) 详细的错误列表
      {
        "field": "trackId",
        "issue": "must be a positive integer"
      }
    ]
  }
}
```

### 2.5. 错误处理与HTTP状态码

  - **概要**: API的错误处理必须清晰、一致。通过合理使用HTTP状态码和在响应体中提供详细的错误信息，帮助客户端快速定位和解决问题。

| HTTP 状态码                     | 含义           | 触发场景示例                                               |
| :------------------------------ | :------------- | :--------------------------------------------------------- |
| **`200 OK`**                    | 成功           | `GET`, `PUT`, `PATCH` 请求成功。                           |
| **`201 Created`**               | 成功创建       | `POST` 请求成功创建了新资源。                              |
| **`204 No Content`**            | 成功无内容     | `DELETE` 请求成功。                                        |
| **`400 Bad Request`**           | 客户端请求错误 | 请求体JSON格式错误、参数类型不匹配、业务验证失败。         |
| **`401 Unauthorized`**          | 未认证         | 未提供API密钥或密钥无效。                                  |
| **`403 Forbidden`**             | 已认证但无权限 | 提供的API密钥权限不足，无法执行该操作。                    |
| **`404 Not Found`**             | 资源未找到     | 请求的URL对应的资源不存在（如查询一个不存在的`trackId`）。 |
| **`500 Internal Server Error`** | 服务器内部错误 | 系统内部发生未预期的错误，无法完成请求。                   |

-----

## 3\. 系统管理接口 (System Management API)

  - **概要**: 这组接口提供了对整个雷达处理系统进行宏观监控和控制的能力，属于**控制面**的核心API。它们是运维人员、监控系统和高级用户界面与系统交互的主要入口。

### 3.1. 获取系统状态 - `GET /api/v1/system/status`

  - **概要**: 提供一个只读端点，用于快速获取系统及其核心模块的总体健康状况。这是外部监控系统（如Prometheus、Zabbix）和UI仪表盘的核心数据来源。

  * **HTTP 请求**

    ```http
    GET /api/v1/system/status
    Authorization: Bearer <your_api_key>
    ```

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-sys-status-123456",
      "data": {
        "overallStatus": "HEALTHY", // HEALTHY, DEGRADED, UNHEALTHY
        "message": "All modules are operating normally.",
        "timestamp": "2025-09-28T10:10:05Z",
        "modules": [
          {
            "name": "DataReceiver",
            "status": "HEALTHY",
            "message": "Receiving data from 1 sources."
          },
          {
            "name": "SignalProcessor",
            "status": "HEALTHY",
            "message": "GPU utilization at 65%."
          },
          {
            "name": "DataProcessor",
            "status": "HEALTHY",
            "message": "Tracking 128 targets."
          }
        ]
      }
    }
    ```

  * **错误响应**

      * `401 Unauthorized`: 认证失败。
      * `500 Internal Server Error`: 系统内部错误，无法获取状态。

  * **内部实现逻辑**

    1.  API网关层收到请求，生成`TraceID`。
    2.  调用`TaskScheduler`提供的服务接口，该接口会遍历所有已注册且实现`IMonitorable`接口的模块。
    3.  对每个模块调用其`getHealthStatus()`方法。
    4.  聚合所有模块的`HealthStatus`，计算出系统的`overallStatus`。
    5.  封装成统一的JSON响应格式返回。

### 3.2. 控制系统状态 - `POST /api/v1/system/control`

  - **概要**: 提供一个用于向系统下发高级控制命令（如`START`, `STOP`, `RESTART`）的动作型端点。该接口是运维自动化和远程管理的关键。

  * **HTTP 请求**

    ```http
    POST /api/v1/system/control
    Authorization: Bearer <your_admin_api_key>
    Content-Type: application/json

    {
      "action": "RESTART" // 支持 START, STOP, PAUSE, RESUME, RESTART
    }
    ```

  * **成功响应 (`202 Accepted`)**

    > **设计决策**: 使用 `202 Accepted` 而非 `200 OK`，因为系统状态转换是一个异步过程。本响应仅表示“命令已接受并开始执行”，而不代表“操作已完成”。

    ```json
    {
      "success": true,
      "traceId": "trace-sys-control-789012",
      "data": {
        "status": "ACCEPTED",
        "message": "System restart command has been accepted and is being processed."
      }
    }
    ```

  * **错误响应**

      * `400 Bad Request`: `action`字段无效或缺失。
      * `401 Unauthorized`: 认证失败。
      * `403 Forbidden`: 认证成功，但API密钥无权执行控制操作。
      * `409 Conflict`: 系统当前状态无法执行该操作（例如，对一个已经是`RUNNING`的系统发送`START`命令）。

  * **内部实现逻辑**

    1.  API网关层收到请求，生成`TraceID`。
    2.  验证`action`参数的合法性。
    3.  根据`action`的类型，创建一个对应的内部事件（如`StartSystemCommandEvent`）。
    4.  将该事件（携带`TraceID`）发布到`EventBus`。
    5.  `TaskScheduler`作为事件的订阅者，接收到命令后开始执行相应的生命周期管理流程。
    6.  网关层不等待流程执行完毕，立即返回`202 Accepted`响应。

### 3.3. 获取系统配置 - `GET /api/v1/system/config`

  - **概要**: 提供一个只读端点，用于获取当前正在运行的、经过合并后的**非敏感**配置信息。这对于远程诊断和配置审计非常有用。

  * **HTTP 请求**

    ```http
    GET /api/v1/system/config
    Authorization: Bearer <your_api_key>
    ```

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-get-config-345678",
      "data": {
        "system": {
          "name": "RadarProcessingSystem",
          "version": "v2.0.0"
        },
        "DataReceiver": {
          "network": {
            "bind_address": "0.0.0.0",
            "port": 8888
          }
        },
        "SignalProcessor": {
          "gpu_device_id": 0
        }
        // ... 其他非敏感配置 ...
      }
    }
    ```

  * **内部实现逻辑**

    1.  API网关层注入`IConfigManager`服务。
    2.  调用`IConfigManager`的一个新方法（如`getFullSanitizedConfig()`），该方法返回完整的、但已过滤掉所有敏感信息（如密码、密钥）的配置树。
    3.  封装成JSON响应返回。

### 3.4. 获取系统告警 - `GET /api/v1/system/alerts`

  - **概要**: 提供一个用于查询当前活跃系统告警的端点。这是显控终端轮询获取告警信息的主要接口，支持分布式架构下的告警信息传递。

  * **HTTP 请求**

    ```http
    GET /api/v1/system/alerts?level=WARNING&limit=100
    Authorization: Bearer <your_api_key>
    ```

    **查询参数 (Query Parameters)**:

      * `level` (string, optional): 按告警级别过滤 (`INFO`, `WARNING`, `CRITICAL`, `FATAL`)。
      * `source_module` (string, optional): 按来源模块过滤 (如 `MonitoringModule`, `DataProcessor`)。
      * `limit` (integer, optional): 返回的最大告警数量，默认100。

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-get-alerts-456789",
      "data": {
        "alerts": [
          {
            "id": "MonitoringModule:cpu_usage",
            "level": "WARNING",
            "source_module": "MonitoringModule",
            "metric_name": "cpu_usage",
            "current_value": 85.2,
            "threshold_value": 80.0,
            "message": "CPU使用率持续超过告警阈值",
            "trigger_time": "2025-09-28T10:05:00Z",
            "last_update": "2025-09-28T10:10:00Z"
          },
          {
            "id": "DataProcessor:processing_latency",
            "level": "CRITICAL",
            "source_module": "DataProcessor",
            "metric_name": "processing_latency",
            "current_value": 15.6,
            "threshold_value": 10.0,
            "message": "数据处理延迟严重超标",
            "trigger_time": "2025-09-28T10:08:30Z",
            "last_update": "2025-09-28T10:08:30Z"
          }
        ],
        "total_count": 2,
        "query_time": "2025-09-28T10:10:05Z"
      }
    }
    ```

  * **错误响应**

      * `401 Unauthorized`: 认证失败。
      * `500 Internal Server Error`: 系统内部错误，无法获取告警信息。

  * **内部实现逻辑**

    1.  API网关层收到请求，生成`TraceID`。
    2.  调用数据网关模块 (`DisplayController`) 的 `getActiveAlerts()` 方法。
    3.  该方法返回当前维护的活跃告警列表。
    4.  根据查询参数进行过滤和分页。
    5.  封装成统一的JSON响应格式返回。

-----

## 4\. 数据服务接口 (Data Services API)

  - **概要**: 这组接口提供了对系统处理后的**成品数据**的访问能力，属于**数据面**的核心API。它们使得UI和其他客户端可以查询和展示有价值的雷达信息。

### 4.1. 获取航迹列表 - `GET /api/v1/tracks`

  - **概要**: 提供一个用于查询和筛选当前所有已确认航迹（`TrackData`）的列表端点。支持分页和按条件过滤，是UI显示和第三方数据分析的主要入口。

  * **HTTP 请求**

    ```http
    GET /api/v1/tracks?status=CONFIRMED&limit=50&offset=0
    Authorization: Bearer <your_api_key>
    ```

    **查询参数 (Query Parameters)**:

      * `status` (string, optional): 按航迹状态过滤 (`TENTATIVE`, `CONFIRMED`, `COAST`)。
      * `limit` (int, optional, default: 100): 每页返回的记录数。
      * `offset` (int, optional, default: 0): 分页偏移量。

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-get-tracks-456789",
      "data": {
        "pagination": {
          "total": 128,
          "limit": 50,
          "offset": 0
        },
        "tracks": [
          {
            "trackId": "1001",
            "status": "CONFIRMED",
            "position": { "x": 1234.5, "y": 5678.9, "z": 200.0 },
            "velocity": { "vx": 50.1, "vy": -10.2, "vz": 2.0 }
          }
          // ... 其他航迹 ...
        ]
      }
    }
    ```

  * **内部实现逻辑**

    1.  API网关层通过依赖注入获取到`DataProcessor`模块提供的一个查询服务接口（`ITrackQueryService`）。
    2.  调用`ITrackQueryService::queryTracks(filter, pagination)`方法。
    3.  `DataProcessor`内部在其线程安全的航迹数据库中执行查询，并返回结果。
    4.  网关层将结果封装为标准响应格式。

### 4.2. 获取单个航迹详情 - `GET /api/v1/tracks/{trackId}`

  - **概要**: 提供一个用于获取指定`trackId`的航迹详细信息的端点，包括其完整的状态向量、协方差矩阵和历史轨迹点。

  * **HTTP 请求**

    ```http
    GET /api/v1/tracks/1001
    Authorization: Bearer <your_api_key>
    ```

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-get-track-1001-567890",
      "data": {
        "trackId": "1001",
        "status": "CONFIRMED",
        "stateVector": [1234.5, 5678.9, 200.0, 50.1, -10.2, 2.0],
        "covarianceMatrix": [
          [1.5, 0.1, 0.0, ...],
          [0.1, 1.8, 0.0, ...],
          ...
        ],
        "history": [
          { "timestamp": "2025-09-28T10:10:04Z", "position": { ... } },
          { "timestamp": "2025-09-28T10:10:03Z", "position": { ... } }
        ]
      }
    }
    ```

  * **错误响应**

      * `404 Not Found`: 指定的`trackId`不存在。

### 4.3. 获取实时性能指标 - `GET /api/v1/metrics`

  - **概要**: 提供一个只读端点，用于获取由`MonitoringModule`聚合的全系统实时性能指标。这与`GET /system/status`互为补充，前者关注健康度，后者关注性能数据。

  * **HTTP 请求**

    ```http
    GET /api/v1/metrics
    Authorization: Bearer <your_api_key>
    ```

  * **成功响应 (`200 OK`)**

    ```json
    {
      "success": true,
      "traceId": "trace-get-metrics-678901",
      "data": {
        "timestamp": "2025-09-28T10:10:05Z",
        "metrics": {
          "datareceiver.network.packets_received": 10240,
          "datareceiver.buffer.queue_depth.percent": 15.6,
          "signalprocessor.gpu.utilization.percent": 65.2,
          "signalprocessor.processing.latency.ms": 4.5,
          "dataprocessor.tracks.active_count": 128
        }
      }
    }
    ```

  * **内部实现逻辑**

    1.  API网关层通过注入的服务接口，向`MonitoringModule`请求最新的指标快照。
    2.  `MonitoringModule`返回其内部聚合的最新`MetricsUpdateEvent`数据。
    3.  网关层将数据格式化后返回。

-----

## 5. (未来) 实时数据接口 (Real-time Data API)
- **概要**: (规划中) RESTful API本质上是请求-响应模式，客户端需要不断轮询才能获取最新数据，这对于需要高频更新的用户界面来说，既不高效也非实时。为了满足UI界面的实时航迹更新需求，未来版本将规划引入基于**WebSocket**或**Server-Sent Events (SSE)**的实时数据接口。

### 5.1. 航迹实时推送 - `WS /api/v1/ws/tracks`
- **概要**: (规划中) 客户端可以通过建立一个WebSocket连接来订阅航迹的实时更新。每当`DataProcessor`生成新的或更新的`TrackData`时，系统会通过此连接主动将数据推送给所有已连接的客户端，实现真正的实时数据展示。

* **交互流程**
    1.  **连接**: 客户端（如UI）向`WS /api/v1/ws/tracks`发起WebSocket握手请求。
    2.  **认证**: 握手请求中包含认证信息（如API Key）。
    3.  **订阅**: 连接建立后，API网关层会在内部订阅一个特定的实时事件（例如`TrackUpdateEvent`）。
    4.  **推送**: 当`DataProcessor`模块更新航迹并通过`EventBus`发布`TrackUpdateEvent`时，API网关层会接收到该事件。
    5.  **广播**: 网关层将事件中的航迹数据格式化为JSON，并通过WebSocket连接主动推送（`push`）给所有订阅的客户端。

* **数据格式**
    推送的数据将是单个航迹对象的JSON，与`GET /api/v1/tracks/{trackId}`返回的格式类似。

* **优势**
    * **真实时**: 数据在服务器端产生后被立即推送，延迟极低。
    * **高效率**: 避免了客户端无效的轮询请求，节省了客户端和服务器的网络和计算资源。
    * **双向通信**: WebSocket还允许客户端向服务器发送消息，未来可用于实现更复杂的交互，如动态设置数据推送的过滤条件。

---
## 6. 术语表

| 术语                     | 英文全称 / 缩写                   | 定义                                                                                               |
| :----------------------- | :-------------------------------- | :------------------------------------------------------------------------------------------------- |
| **API**                  | Application Programming Interface | 应用程序编程接口，定义了软件组件之间交互的契约和规范。                                             |
| **REST**                 | Representational State Transfer   | 一种用于设计网络应用的架构风格，强调无状态、资源导向和统一接口。                                   |
| **端点 (Endpoint)**      | -                                 | API中用于访问特定资源的URL，例如`/api/v1/tracks`。                                                 |
| **幂等性 (Idempotency)** | -                                 | 指一次和多次请求某一个资源应该具有相同的副作用。例如，`GET`和`PUT`请求是幂等的，而`POST`请求不是。 |
| **门面模式 (Facade)**    | -                                 | 一种设计模式，为复杂的内部子系统提供一个单一、简化的外部接口。本系统中的API网关即扮演此角色。      |
| **API 密钥 (API Key)**   | -                                 | 一个用于识别和认证调用API的客户端的唯一字符串令牌。                                                |
| **WebSocket**            | -                                 | 一种在单个TCP连接上进行全双工通信的协议，允许服务器主动向客户端推送数据。                          |

---
## 7. 变更历史

| 版本号 | 日期       | 作者    | 变更描述                                                                                                                                                                                                                                |
| :----- | :--------- | :------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| v1.1.0 | 2025-09-28 | Copilot | **分布式架构适配**：新增系统告警API端点<br/>- **新增端点**: `GET /api/v1/system/alerts`支持显控终端轮询查询告警<br/>- **分布式支持**: 适应数据网关模块设计，支持告警信息的外部暴露<br/>- **查询参数**: 支持按级别、来源模块过滤告警信息 |
| v1.0.0 | 2025-09-28 | Klein   | 初始版本创建，定义了RESTful API的设计原则、系统管理接口和数据服务接口，并规划了未来的实时数据接口。                                                                                                                                     |
